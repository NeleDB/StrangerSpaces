// (function e(t, n, r) {function s(o, u) {if (!n[o]) {if (!t[o]) {const a = typeof require == `function` && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);const f = new Error(`Cannot find module '${o  }'`);throw f.code = `MODULE_NOT_FOUND`, f;} const l = n[o] = {exports: {}};t[o][0].call(l.exports, function(e) {const n = t[o][1][e];return s(n ? n : e);}, l, l.exports, e, t, n, r);} return n[o].exports;} var i = typeof require == `function` && require;for (let o = 0;o < r.length;o ++)s(r[o]);return s;})({1: [function(require, module, exports) {
//
// }, {}], 2: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../math/ndarray`);
//   const MANIFEST_FILE = `manifest.json`;
//   const CheckpointLoader = (function () {
//     function CheckpointLoader(urlPath) {
//       this.urlPath = urlPath;
//       if (this.urlPath.charAt(this.urlPath.length - 1) !== `/`) {
//         this.urlPath += `/`;
//       }
//     }
//     CheckpointLoader.prototype.loadManifest = function () {
//       const _this = this;
//       return new Promise(function (resolve, reject) {
//         const xhr = new XMLHttpRequest();
//         xhr.open(`GET`, _this.urlPath + MANIFEST_FILE);
//         xhr.onload = function () {
//           _this.checkpointManifest = JSON.parse(xhr.responseText);
//           resolve();
//         };
//         xhr.onerror = function (error) {
//           throw new Error(`${MANIFEST_FILE  } not found at ${  _this.urlPath  }. ${  error}`);
//         };
//         xhr.send();
//       });
//     };
//     CheckpointLoader.prototype.getCheckpointManifest = function () {
//       const _this = this;
//       if (this.checkpointManifest == null) {
//         return new Promise(function (resolve, reject) {
//           _this.loadManifest().then(function () {
//             resolve(_this.checkpointManifest);
//           });
//         });
//       }
//       return new Promise(function (resolve, reject) {
//         resolve(_this.checkpointManifest);
//       });
//     };
//     CheckpointLoader.prototype.getAllVariables = function () {
//       const _this = this;
//       if (this.variables != null) {
//         return new Promise(function (resolve, reject) {
//           resolve(_this.variables);
//         });
//       }
//       return new Promise(function (resolve, reject) {
//         _this.getCheckpointManifest().then(function (checkpointDefinition) {
//           const variableNames = Object.keys(_this.checkpointManifest);
//           const variablePromises = [];
//           for (let i = 0;i < variableNames.length;i ++) {
//             variablePromises.push(_this.getVariable(variableNames[i]));
//           }
//           Promise.all(variablePromises).then(function (variables) {
//             _this.variables = {};
//             for (let i = 0;i < variables.length;i ++) {
//               _this.variables[variableNames[i]] = variables[i];
//             }
//             resolve(_this.variables);
//           });
//         });
//       });
//     };
//     CheckpointLoader.prototype.getVariable = function (varName) {
//       const _this = this;
//       if (!(varName in this.checkpointManifest)) {
//         throw new Error(`Cannot load non-existant variable ${  varName}`);
//       }
//       const variableRequestPromiseMethod = function (resolve, reject) {
//         const xhr = new XMLHttpRequest();
//         xhr.responseType = `arraybuffer`;
//         const fname = _this.checkpointManifest[varName].filename;
//         xhr.open(`GET`, _this.urlPath + fname);
//         xhr.onload = function () {
//           const values = new Float32Array(xhr.response);
//           const ndarray = ndarray_1.NDArray.make(_this.checkpointManifest[varName].shape, {values: values});
//           resolve(ndarray);
//         };
//         xhr.onerror = function (error) {
//           throw new Error(`Could not fetch variable ${  varName  }: ${  error}`);
//         };
//         xhr.send();
//       };
//       if (this.checkpointManifest == null) {
//         return new Promise(function (resolve, reject) {
//           _this.loadManifest().then(function () {
//             new Promise(variableRequestPromiseMethod).then(resolve);
//           });
//         });
//       }
//       return new Promise(variableRequestPromiseMethod);
//     };
//     return CheckpointLoader;
//   }());
//   exports.CheckpointLoader = CheckpointLoader;
//
// }, {"../math/ndarray": 55}], 3: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../math/ndarray`);
//   const util = require(`../util`);
//   const STATS_SAMPLE_PERCENTAGE = 0.1;
//   const InMemoryDataset = (function () {
//     function InMemoryDataset(dataShapes) {
//       this.dataShapes = dataShapes;
//       this.normalizationInfo = {};
//     }
//     InMemoryDataset.prototype.getDataShape = function (dataIndex) {
//       return this.dataShapes[dataIndex];
//     };
//     InMemoryDataset.prototype.getData = function () {
//       return this.dataset;
//     };
//     InMemoryDataset.prototype.getStats = function () {
//       const _this = this;
//       if (this.dataset == null) {
//         throw new Error(`Data is null.`);
//       }
//       return this.dataset.map(function (d) { return _this.getStatsForData(d); });
//     };
//     InMemoryDataset.prototype.getStatsForData = function (data) {
//       let inputMin = Number.POSITIVE_INFINITY;
//       let inputMax = Number.NEGATIVE_INFINITY;
//       let exampleIndices = data.map(function (example, i) { return i; });
//       util.shuffle(exampleIndices);
//       exampleIndices =
//             exampleIndices.slice(exampleIndices.length * STATS_SAMPLE_PERCENTAGE);
//       for (let i = 0;i < exampleIndices.length;i ++) {
//         const inputValues = data[exampleIndices[i]].getValues();
//         for (let j = 0;j < inputValues.length;j ++) {
//           inputMin = Math.min(inputMin, inputValues[j]);
//           inputMax = Math.max(inputMax, inputValues[j]);
//         }
//       }
//       return {
//         inputMin: inputMin,
//         inputMax: inputMax,
//         exampleCount: data.length,
//         shape: data[0].shape,
//       };
//     };
//     InMemoryDataset.prototype.normalizeExamplesToRange = function (examples, curLowerBounds, curUpperBounds, newLowerBounds, newUpperBounds) {
//       const curBoundsIsPerDimension = (curUpperBounds instanceof Float32Array &&
//             curLowerBounds instanceof Float32Array);
//       const newBoundsIsPerDimension = (newLowerBounds instanceof Float32Array &&
//             newUpperBounds instanceof Float32Array);
//       const inputSize = util.sizeFromShape(examples[0].shape);
//       const newExamples = [];
//       examples.forEach(function (example) {
//         const inputValues = example.getValues();
//         const normalizedValues = new Float32Array(inputSize);
//         for (let j = 0;j < inputSize;j ++) {
//           const curLowerBound = curBoundsIsPerDimension ?
//                     curLowerBounds[j] :
//                     curLowerBounds;
//           const curUpperBound = curBoundsIsPerDimension ?
//                     curUpperBounds[j] :
//                     curUpperBounds;
//           const curRange = curUpperBound - curLowerBound;
//           const newLowerBound = newBoundsIsPerDimension ?
//                     newLowerBounds[j] :
//                     newLowerBounds;
//           const newUpperBound = newBoundsIsPerDimension ?
//                     newUpperBounds[j] :
//                     newUpperBounds;
//           const newRange = newUpperBound - newLowerBound;
//           if (curRange === 0) {
//             normalizedValues[j] = newLowerBound;
//           }
//           else {
//             normalizedValues[j] = newLowerBound +
//                         newRange * (inputValues[j] - curLowerBound) / curRange;
//           }
//         }
//         newExamples.push(ndarray_1.NDArray.make(example.shape, {values: normalizedValues}));
//       });
//       return newExamples;
//     };
//     InMemoryDataset.prototype.computeBounds = function (dataIndex) {
//       const _this = this;
//       if (this.dataset == null) {
//         throw new Error(`Data is null.`);
//       }
//       const size = util.sizeFromShape(this.dataset[dataIndex][0].shape);
//       this.normalizationInfo[dataIndex] = {
//         isNormalized: false,
//         minValues: new Float32Array(size),
//         maxValues: new Float32Array(size)
//       };
//       for (let i = 0;i < size;i ++) {
//         this.normalizationInfo[dataIndex].minValues[i] = Number.POSITIVE_INFINITY;
//         this.normalizationInfo[dataIndex].maxValues[i] = Number.NEGATIVE_INFINITY;
//       }
//       this.dataset[dataIndex].forEach(function (example) {
//         const inputValues = example.getValues();
//         for (let k = 0;k < size;k ++) {
//           _this.normalizationInfo[dataIndex].minValues[k] = Math.min(_this.normalizationInfo[dataIndex].minValues[k], inputValues[k]);
//           _this.normalizationInfo[dataIndex].maxValues[k] = Math.max(_this.normalizationInfo[dataIndex].maxValues[k], inputValues[k]);
//         }
//       });
//     };
//     InMemoryDataset.prototype.normalizeWithinBounds = function (dataIndex, lowerBound, upperBound) {
//       if (this.dataset == null) {
//         throw new Error(`Data is null.`);
//       }
//       if (dataIndex >= this.dataset.length) {
//         throw new Error(`dataIndex out of bounds.`);
//       }
//       if (this.normalizationInfo[dataIndex] == null) {
//         this.computeBounds(dataIndex);
//       }
//       let curLowerBounds;
//       let curUpperBounds;
//       if (this.normalizationInfo[dataIndex].isNormalized) {
//         curLowerBounds = this.normalizationInfo[dataIndex].lowerBound;
//         curUpperBounds = this.normalizationInfo[dataIndex].upperBound;
//       }
//       else {
//         curLowerBounds = this.normalizationInfo[dataIndex].minValues;
//         curUpperBounds = this.normalizationInfo[dataIndex].maxValues;
//       }
//       this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], curLowerBounds, curUpperBounds, lowerBound, upperBound);
//       this.normalizationInfo[dataIndex].isNormalized = true;
//       this.normalizationInfo[dataIndex].lowerBound = lowerBound;
//       this.normalizationInfo[dataIndex].upperBound = upperBound;
//     };
//     InMemoryDataset.prototype.isNormalized = function (dataIndex) {
//       return this.normalizationInfo != null &&
//             this.normalizationInfo[dataIndex].isNormalized;
//     };
//     InMemoryDataset.prototype.removeNormalization = function (dataIndex) {
//       if (this.dataset == null) {
//         throw new Error(`Training or test data is null.`);
//       }
//       if (!this.isNormalized(dataIndex)) {
//         return;
//       }
//       this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
//       this.normalizationInfo[dataIndex].isNormalized = false;
//     };
//     InMemoryDataset.prototype.unnormalizeExamples = function (examples, dataIndex) {
//       if (!this.isNormalized(dataIndex)) {
//         return examples;
//       }
//       return this.normalizeExamplesToRange(examples, this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
//     };
//     InMemoryDataset.prototype.dispose = function () {
//       if (this.dataset == null) {
//         return;
//       }
//       for (let i = 0;i < this.dataset.length;i ++) {
//         for (let j = 0;j < this.dataset[i].length;j ++) {
//           this.dataset[i][j].dispose();
//         }
//       }
//       this.dataset = [];
//     };
//     return InMemoryDataset;
//   }());
//   exports.InMemoryDataset = InMemoryDataset;
//
// }, {"../math/ndarray": 55, "../util": 88}], 4: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../math/ndarray`);
//   const util = require(`../util`);
//   const InMemoryShuffledInputProviderBuilder = (function () {
//     function InMemoryShuffledInputProviderBuilder(inputs) {
//       this.inputs = inputs;
//       this.idx = 0;
//       this.inputCounter = 0;
//       this.epoch = 0;
//       this.shuffledIndices = util.createShuffledIndices(inputs[0].length);
//       this.numInputs = inputs.length;
//       const numExamples = this.inputs[0].length;
//       for (var i = 0;i < this.numInputs;i ++) {
//         util.assert(this.inputs[i].length === numExamples, `Number of examples must match across different inputs.`);
//       }
//       for (var i = 0;i < this.numInputs;i ++) {
//         const inputShape = this.inputs[i][0].shape;
//         for (let j = 0;j < this.inputs[i].length;j ++) {
//           util.assertShapesMatch(inputShape, this.inputs[i][j].shape);
//         }
//       }
//     }
//     InMemoryShuffledInputProviderBuilder.prototype.getCurrentExampleIndex = function () {
//       const returnIdx = this.idx;
//       this.inputCounter++;
//       if (this.inputCounter >= this.numInputs) {
//         this.idx++;
//         this.inputCounter = 0;
//         if (this.idx >= this.inputs[0].length) {
//           this.idx = 0;
//           this.epoch++;
//         }
//       }
//       return returnIdx;
//     };
//     InMemoryShuffledInputProviderBuilder.prototype.getNextInput = function (inputId) {
//       const currentExampleIndex = this.getCurrentExampleIndex();
//       return this.inputs[inputId][this.shuffledIndices[currentExampleIndex]];
//     };
//     InMemoryShuffledInputProviderBuilder.prototype.getEpoch = function () {
//       return this.epoch;
//     };
//     InMemoryShuffledInputProviderBuilder.prototype.getInputProviders = function () {
//       const inputProviders = [];
//       for (let i = 0;i < this.numInputs;i ++) {
//         inputProviders.push(this.getInputProvider(i));
//       }
//       return inputProviders;
//     };
//     return InMemoryShuffledInputProviderBuilder;
//   }());
//   exports.InMemoryShuffledInputProviderBuilder = InMemoryShuffledInputProviderBuilder;
//   const InCPUMemoryShuffledInputProviderBuilder = (function (_super) {
//     __extends(InCPUMemoryShuffledInputProviderBuilder, _super);
//     function InCPUMemoryShuffledInputProviderBuilder() {
//       return _super !== null && _super.apply(this, arguments) || this;
//     }
//     InCPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
//       const shuffledInputProvider = this;
//       return {
//         getNextCopy: function (math) {
//           return ndarray_1.NDArray.like(shuffledInputProvider.getNextInput(inputId));
//         },
//         disposeCopy: function (math, copy) {
//           copy.dispose();
//         }
//       };
//     };
//     return InCPUMemoryShuffledInputProviderBuilder;
//   }(InMemoryShuffledInputProviderBuilder));
//   exports.InCPUMemoryShuffledInputProviderBuilder = InCPUMemoryShuffledInputProviderBuilder;
//   const InGPUMemoryShuffledInputProviderBuilder = (function (_super) {
//     __extends(InGPUMemoryShuffledInputProviderBuilder, _super);
//     function InGPUMemoryShuffledInputProviderBuilder() {
//       return _super !== null && _super.apply(this, arguments) || this;
//     }
//     InGPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
//       const shuffledInputProvider = this;
//       return {
//         getNextCopy: function (math) {
//           return math.clone(shuffledInputProvider.getNextInput(inputId));
//         },
//         disposeCopy: function (math, copy) {
//           copy.dispose();
//         }
//       };
//     };
//     return InGPUMemoryShuffledInputProviderBuilder;
//   }(InMemoryShuffledInputProviderBuilder));
//   exports.InGPUMemoryShuffledInputProviderBuilder = InGPUMemoryShuffledInputProviderBuilder;
//
// }, {"../math/ndarray": 55, "../util": 88}], 5: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../math/ndarray`);
//   const util = require(`../util`);
//   const dataset_1 = require(`./dataset`);
//   const PARSING_IMAGE_CANVAS_HEIGHT_PX = 1000;
//   function getXhrDatasetConfig(jsonConfigPath) {
//     return new Promise(function (resolve, reject) {
//       const xhr = new XMLHttpRequest();
//       xhr.open(`GET`, jsonConfigPath);
//       xhr.onload = function () {
//         resolve(JSON.parse(xhr.responseText));
//       };
//       xhr.onerror = function (error) {
//         reject(error);
//       };
//       xhr.send();
//     });
//   }
//   exports.getXhrDatasetConfig = getXhrDatasetConfig;
//   const XhrDataset = (function (_super) {
//     __extends(XhrDataset, _super);
//     function XhrDataset(xhrDatasetConfig) {
//       const _this = _super.call(this, xhrDatasetConfig.data.map(function (x) { return x.shape; })) || this;
//       _this.xhrDatasetConfig = xhrDatasetConfig;
//       return _this;
//     }
//     XhrDataset.prototype.getNDArray = function (info) {
//       const dataPromise = info.dataType === `png` ?
//             parseTypedArrayFromPng(info, info.shape) :
//             parseTypedArrayFromBinary(info);
//       return dataPromise.then(function (data) {
//         const inputSize = util.sizeFromShape(info.shape);
//         const ndarrays = [];
//         for (let i = 0;i < data.length / inputSize;i ++) {
//           const values = data.subarray(i * inputSize, (i + 1) * inputSize);
//           const ndarray = ndarray_1.NDArray.make(info.shape, {values: new Float32Array(values)});
//           ndarrays.push(ndarray);
//         }
//         return ndarrays;
//       });
//     };
//     XhrDataset.prototype.fetchData = function () {
//       const _this = this;
//       return new Promise(function (resolve, reject) {
//         const promises = _this.xhrDatasetConfig.data.map(function (x) { return _this.getNDArray(x); });
//         Promise.all(promises).then(function (data) {
//           _this.dataset = data;
//           resolve();
//         });
//       });
//     };
//     return XhrDataset;
//   }(dataset_1.InMemoryDataset));
//   exports.XhrDataset = XhrDataset;
//   function parseTypedArrayFromBinary(info) {
//     return new Promise(function (resolve, reject) {
//       const xhr = new XMLHttpRequest();
//       xhr.open(`GET`, info.path);
//       xhr.responseType = `arraybuffer`;
//       xhr.onload = function (event) {
//         const data = (info.dataType === `float32`) ?
//                 new Float32Array(xhr.response) :
//                 new Uint8Array(xhr.response);
//         resolve(data);
//       };
//       xhr.onerror = function (err) { return reject(err); };
//       xhr.send();
//     });
//   }
//   function parseGrayscaleImageData(data, result, resultOffset) {
//     let idx = resultOffset;
//     for (let i = 0;i < data.length;i += 4) {
//       result[idx ++] = data[i];
//     }
//   }
//   function parseRGBImageData(data, result, resultOffset) {
//     let idx = resultOffset;
//     for (let i = 0;i < data.length;i += 4) {
//       result[idx] = data[i];
//       result[idx + 1] = data[i + 1];
//       result[idx + 2] = data[i + 2];
//       idx += 3;
//     }
//   }
//   function parseImage(img, shape) {
//     const canvas = document.createElement(`canvas`);
//     const ctx = canvas.getContext(`2d`);
//     const N = img.height;
//     const inputSize = util.sizeFromShape(shape);
//     const result = new Uint8Array(N * inputSize);
//     if (img.width !== shape[0] * shape[1]) {
//       throw new Error(`Image width (${  img.width  }) must be multiple of ` +
//             `rows*columns (${  shape[0]  }*${  shape[1]  }) of the ndarray`);
//     }
//     canvas.width = img.width;
//     canvas.height = PARSING_IMAGE_CANVAS_HEIGHT_PX;
//     const sx = 0;
//     const sWidth = canvas.width;
//     let sHeight = canvas.height;
//     const dx = 0;
//     const dy = 0;
//     const dWidth = sWidth;
//     let dHeight = sHeight;
//     const depth = shape[2];
//     let offset = 0;
//     const numPasses = Math.ceil(N / canvas.height);
//     for (let pass = 0;pass < numPasses;++ pass) {
//       const sy = pass * canvas.height;
//       if ((pass === numPasses - 1) && (N % canvas.height > 0)) {
//         canvas.height = N % canvas.height;
//         sHeight = canvas.height;
//         dHeight = sHeight;
//       }
//       ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
//       const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
//       (depth === 1) ? parseGrayscaleImageData(data, result, offset) :
//             parseRGBImageData(data, result, offset);
//       offset += canvas.height * inputSize;
//     }
//     return result;
//   }
//   function parseTypedArrayFromPng(info, shape) {
//     return new Promise(function (resolve, reject) {
//       let img = new Image();
//       img.setAttribute(`crossOrigin`, ``);
//       img.onload = function () {
//         const result = parseImage(img, shape);
//         img.src = ``;
//         img = null;
//         resolve(result);
//       };
//       img.src = info.path;
//     });
//   }
//
// }, {"../math/ndarray": 55, "../util": 88, "./dataset": 3}], 6: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   function isMobile() {
//     const a = navigator.userAgent || navigator.vendor || window.opera;
//     return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
//         .test(a) ||
//         /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
//             .test(a.substr(0, 4));
//   }
//   exports.isMobile = isMobile;
//
// }, {}], 7: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const device_util = require(`./device_util`);
//   const util = require(`./util`);
//   let Type;
//   (function (Type) {
//     Type[Type[`NUMBER`] = 0] = `NUMBER`;
//     Type[Type[`BOOLEAN`] = 1] = `BOOLEAN`;
//   })(Type = exports.Type || (exports.Type = {}));
//   exports.URL_PROPERTIES = [
//     {name: `WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED`, type: Type.BOOLEAN},
//     {name: `WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE`, type: Type.BOOLEAN},
//     {name: `WEBGL_VERSION`, type: Type.NUMBER},
//     {name: `WEBGL_FLOAT_TEXTURE_ENABLED`, type: Type.BOOLEAN}, {
//       name: `WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED`,
//       type: Type.BOOLEAN
//     }
//   ];
//   function getWebGLRenderingContext(webGLVersion) {
//     if (webGLVersion === 0) {
//       throw new Error(`Cannot get WebGL rendering context, WebGL is disabled.`);
//     }
//     const tempCanvas = document.createElement(`canvas`);
//     if (webGLVersion === 1) {
//       return (tempCanvas.getContext(`webgl`) ||
//             tempCanvas.getContext(`experimental-webgl`));
//     }
//     return tempCanvas.getContext(`webgl2`);
//   }
//   function loseContext(gl) {
//     if (gl != null) {
//       const loseContextExtension = gl.getExtension(`WEBGL_lose_context`);
//       if (loseContextExtension == null) {
//         throw new Error(`Extension WEBGL_lose_context not supported on this browser.`);
//       }
//       loseContextExtension.loseContext();
//     }
//   }
//   function isWebGLVersionEnabled(webGLVersion) {
//     const gl = getWebGLRenderingContext(webGLVersion);
//     if (gl != null) {
//       loseContext(gl);
//       return true;
//     }
//     return false;
//   }
//   function isWebGLDisjointQueryTimerEnabled(webGLVersion) {
//     const gl = getWebGLRenderingContext(webGLVersion);
//     const extensionName = webGLVersion === 1 ? `EXT_disjoint_timer_query` :
//         `EXT_disjoint_timer_query_webgl2`;
//     const ext = gl.getExtension(extensionName);
//     const isExtEnabled = ext != null;
//     if (gl != null) {
//       loseContext(gl);
//     }
//     return isExtEnabled;
//   }
//   function isFloatTextureReadPixelsEnabled(webGLVersion) {
//     if (webGLVersion === 0) {
//       return false;
//     }
//     const gl = getWebGLRenderingContext(webGLVersion);
//     if (webGLVersion === 1) {
//       if (gl.getExtension(`OES_texture_float`) == null) {
//         return false;
//       }
//     }
//     else {
//       if (gl.getExtension(`EXT_color_buffer_float`) == null) {
//         return false;
//       }
//     }
//     const frameBuffer = gl.createFramebuffer();
//     const texture = gl.createTexture();
//     gl.bindTexture(gl.TEXTURE_2D, texture);
//     const internalFormat = webGLVersion === 2 ? gl.RGBA32F : gl.RGBA;
//     gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
//     gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
//     gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
//     const frameBufferComplete = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE);
//     gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, new Float32Array(4));
//     const readPixelsNoError = gl.getError() === gl.NO_ERROR;
//     loseContext(gl);
//     return frameBufferComplete && readPixelsNoError;
//   }
//   function isWebGLGetBufferSubDataAsyncExtensionEnabled(webGLVersion) {
//     if (webGLVersion !== 2) {
//       return false;
//     }
//     const gl = getWebGLRenderingContext(webGLVersion);
//     const ext = gl.getExtension(`WEBGL_get_buffer_sub_data_async`);
//     const isEnabled = ext != null;
//     loseContext(gl);
//     return isEnabled;
//   }
//   const Environment = (function () {
//     function Environment(features) {
//       this.features = {};
//       if (features != null) {
//         this.features = features;
//       }
//     }
//     Environment.prototype.get = function (feature) {
//       if (feature in this.features) {
//         return this.features[feature];
//       }
//       this.features[feature] = this.evaluateFeature(feature);
//       return this.features[feature];
//     };
//     Environment.prototype.evaluateFeature = function (feature) {
//       if (feature === `WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED`) {
//         const webGLVersion = this.get(`WEBGL_VERSION`);
//         if (webGLVersion === 0) {
//           return false;
//         }
//         return isWebGLDisjointQueryTimerEnabled(webGLVersion);
//       }
//       else if (feature === `WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE`) {
//         return this.get(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED`) &&
//                 !device_util.isMobile();
//       }
//       else if (feature === `WEBGL_VERSION`) {
//         if (isWebGLVersionEnabled(2)) {
//           return 2;
//         }
//         else if (isWebGLVersionEnabled(1)) {
//           return 1;
//         }
//         return 0;
//       }
//       else if (feature === `WEBGL_FLOAT_TEXTURE_ENABLED`) {
//         return isFloatTextureReadPixelsEnabled(this.get(`WEBGL_VERSION`));
//       }
//       else if (feature === `WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED`) {
//         return isWebGLGetBufferSubDataAsyncExtensionEnabled(this.get(`WEBGL_VERSION`));
//       }
//       throw new Error(`Unknown feature ${  feature  }.`);
//     };
//     return Environment;
//   }());
//   exports.Environment = Environment;
//   const DEEPLEARNJS_FLAGS_PREFIX = `dljsflags`;
//   function getFeaturesFromURL() {
//     const features = {};
//     if (typeof window === `undefined`) {
//       return features;
//     }
//     const urlParams = util.getQueryParams(window.location.search);
//     if (DEEPLEARNJS_FLAGS_PREFIX in urlParams) {
//       const urlFlags_1 = {};
//       const keyValues = urlParams[DEEPLEARNJS_FLAGS_PREFIX].split(`,`);
//       keyValues.forEach(function (keyValue) {
//         let _a = keyValue.split(`:`), key = _a[0], value = _a[1];
//         urlFlags_1[key] = value;
//       });
//       exports.URL_PROPERTIES.forEach(function (urlProperty) {
//         if (urlProperty.name in urlFlags_1) {
//           console.log(`Setting feature override from URL ${  urlProperty.name  }: ` +
//                     `${  urlFlags_1[urlProperty.name]}`);
//           if (urlProperty.type === Type.NUMBER) {
//             features[urlProperty.name] = + urlFlags_1[urlProperty.name];
//           }
//           else if (urlProperty.type === Type.BOOLEAN) {
//             features[urlProperty.name] = urlFlags_1[urlProperty.name] === `true`;
//           }
//           else {
//             console.warn(`Unknown URL param: ${  urlProperty.name  }.`);
//           }
//         }
//       });
//     }
//     return features;
//   }
//   exports.ENV = new Environment(getFeaturesFromURL());
//   function setEnvironment(environment) {
//     exports.ENV = environment;
//   }
//   exports.setEnvironment = setEnvironment;
//
// }, {"./device_util": 6, "./util": 88}], 8: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const initializers_1 = require(`../initializers`);
//   const concat_util = require(`../math/concat_util`);
//   const conv_util = require(`../math/conv_util`);
//   const ndarray_1 = require(`../math/ndarray`);
//   const util = require(`../util`);
//   const GraphLayers = (function () {
//     function GraphLayers(g) {
//       this.g = g;
//     }
//     GraphLayers.prototype.dense = function (name, x, units, activation, useBias, kernelInitializer, biasInitializer) {
//       if (activation === void 0) { activation = null; }
//       if (useBias === void 0) { useBias = true; }
//       if (kernelInitializer === void 0) { kernelInitializer = new initializers_1.VarianceScalingInitializer(); }
//       if (biasInitializer === void 0) { biasInitializer = new initializers_1.ZerosInitializer(); }
//       const weights = this.g.variable(`${name  }-weights`, kernelInitializer.initialize([x.shape[0], units], x.shape[0], units));
//       let out = this.g.matmul(x, weights);
//       if (useBias) {
//         const bias = this.g.variable(`${name  }-bias`, biasInitializer.initialize([units], x.shape[0], units));
//         out = this.g.add(out, bias);
//       }
//       if (activation != null) {
//         out = activation(out);
//       }
//       return out;
//     };
//     return GraphLayers;
//   }());
//   exports.GraphLayers = GraphLayers;
//   const Graph = (function () {
//     function Graph() {
//       this.nodes = [];
//       this.layers = new GraphLayers(this);
//     }
//     Graph.prototype.variable = function (name, data) {
//       return this.addNodeAndReturnOutput(new VariableNode(this, name, data));
//     };
//     Graph.prototype.placeholder = function (name, shape) {
//       return this.addNodeAndReturnOutput(new PlaceholderNode(this, name, shape));
//     };
//     Graph.prototype.constant = function (value) {
//       let finalValue;
//       if (typeof value === `number`) {
//         finalValue = ndarray_1.Scalar.new(value);
//       }
//       else if (value instanceof ndarray_1.NDArray) {
//         finalValue = value;
//       }
//       else if (value instanceof Array) {
//         const flatValues = util.flatten(value);
//         const vals = new Float32Array(flatValues);
//         finalValue = ndarray_1.NDArray.make(util.inferShape(value), {values: vals});
//       }
//       else {
//         throw new Error(`unimplemented constant type.`);
//       }
//       return this.addNodeAndReturnOutput(new ConstantNode(this, finalValue));
//     };
//     Graph.prototype.reshape = function (x, shape) {
//       return this.addNodeAndReturnOutput(new ReshapeNode(this, `Reshape`, x, shape));
//     };
//     Graph.prototype.fusedLinearCombination = function (x1, x2, c1, c2) {
//       return this.addNodeAndReturnOutput(new FusedLinearCombinationNode(this, x1, x2, c1, c2));
//     };
//     Graph.prototype.add = function (x1, x2) {
//       return this.addNodeAndReturnOutput(new AddNode(this, x1, x2));
//     };
//     Graph.prototype.subtract = function (x1, x2) {
//       return this.addNodeAndReturnOutput(new SubtractNode(this, x1, x2));
//     };
//     Graph.prototype.multiply = function (x1, x2) {
//       return this.addNodeAndReturnOutput(new MultiplyNode(this, x1, x2));
//     };
//     Graph.prototype.divide = function (x1, x2) {
//       return this.addNodeAndReturnOutput(new DivideNode(this, x1, x2));
//     };
//     Graph.prototype.reduceSum = function (x) {
//       return this.addNodeAndReturnOutput(new ReduceSumNode(this, x));
//     };
//     Graph.prototype.concat3d = function (x1, x2, axis) {
//       return this.addNodeAndReturnOutput(new Concat3DNode(this, x1, x2, axis));
//     };
//     Graph.prototype.matmul = function (x1, x2) {
//       return this.addNodeAndReturnOutput(new MatMulNode(this, x1, x2));
//     };
//     Graph.prototype.conv2d = function (x, w, b, fieldSize, outputDepth, stride, zeroPad) {
//       if (stride === void 0) { stride = 1; }
//       return this.addNodeAndReturnOutput(new Convolution2DNode(this, x, w, b, fieldSize, outputDepth, stride, zeroPad));
//     };
//     Graph.prototype.maxPool = function (x, fieldSize, stride, zeroPad) {
//       if (stride === void 0) { stride = 1; }
//       return this.addNodeAndReturnOutput(new MaxPoolNode(this, x, fieldSize, stride, zeroPad));
//     };
//     Graph.prototype.exp = function (x) {
//       return this.addNodeAndReturnOutput(new ExpNode(this, x));
//     };
//     Graph.prototype.log = function (x) {
//       return this.addNodeAndReturnOutput(new LogNode(this, x));
//     };
//     Graph.prototype.relu = function (x) {
//       return this.addNodeAndReturnOutput(new ReLUNode(this, x));
//     };
//     Graph.prototype.leakyRelu = function (x, alpha) {
//       return this.addNodeAndReturnOutput(new LeakyReLUNode(this, x, alpha));
//     };
//     Graph.prototype.tanh = function (x) {
//       return this.addNodeAndReturnOutput(new TanHNode(this, x));
//     };
//     Graph.prototype.sigmoid = function (x) {
//       return this.addNodeAndReturnOutput(new SigmoidNode(this, x));
//     };
//     Graph.prototype.square = function (x) {
//       return this.addNodeAndReturnOutput(new SquareNode(this, x));
//     };
//     Graph.prototype.softmax = function (x) {
//       return this.addNodeAndReturnOutput(new SoftmaxNode(this, x));
//     };
//     Graph.prototype.softmaxCrossEntropyCost = function (x, target) {
//       return this.addNodeAndReturnOutput(new SoftmaxCrossEntropyCostNode(this, x, target));
//     };
//     Graph.prototype.meanSquaredCost = function (label, prediction) {
//       return this.addNodeAndReturnOutput(new MeanSquaredCostNode(this, label, prediction));
//     };
//     Graph.prototype.argmax = function (x) {
//       return this.addNodeAndReturnOutput(new ArgMaxNode(this, x));
//     };
//     Graph.prototype.argmaxEquals = function (x1, x2) {
//       return this.addNodeAndReturnOutput(new ArgMaxEqualsNode(this, x1, x2));
//     };
//     Graph.prototype.addNodeAndReturnOutput = function (node) {
//       this.nodes.push(node);
//       node.validate();
//       return node.output;
//     };
//     Graph.prototype.getNodes = function () {
//       return this.nodes;
//     };
//     return Graph;
//   }());
//   exports.Graph = Graph;
//   const Tensor = (function () {
//     function Tensor(shape) {
//       this.shape = shape;
//       this.id = Tensor.nextID++;
//     }
//     Tensor.nextID = 0;
//     return Tensor;
//   }());
//   exports.Tensor = Tensor;
//   const Node = (function () {
//     function Node(graph, name, inputs, output) {
//       this.graph = graph;
//       this.name = name;
//       this.inputs = inputs;
//       this.output = output;
//       this.id = Node.nextID++;
//       output.node = this;
//     }
//     Node.nextID = 0;
//     return Node;
//   }());
//   exports.Node = Node;
//   var VariableNode = (function (_super) {
//     __extends(VariableNode, _super);
//     function VariableNode(graph, name, data) {
//       const _this = _super.call(this, graph, name, {}, new Tensor(data.shape)) || this;
//       _this.data = data;
//       return _this;
//     }
//     VariableNode.prototype.validate = function () {
//       util.assert(this.data != null, `Error adding variable op: Data for variable '${  this.name
//             }' is null or undefined`);
//     };
//     return VariableNode;
//   }(Node));
//   exports.VariableNode = VariableNode;
//   var PlaceholderNode = (function (_super) {
//     __extends(PlaceholderNode, _super);
//     function PlaceholderNode(graph, name, shape) {
//       return _super.call(this, graph, name, {}, new Tensor(shape)) || this;
//     }
//     PlaceholderNode.prototype.validate = function () { };
//     return PlaceholderNode;
//   }(Node));
//   exports.PlaceholderNode = PlaceholderNode;
//   var ConstantNode = (function (_super) {
//     __extends(ConstantNode, _super);
//     function ConstantNode(graph, data) {
//       const _this = _super.call(this, graph, `Constant`, {}, new Tensor(data.shape)) || this;
//       _this.data = data;
//       return _this;
//     }
//     ConstantNode.prototype.validate = function () {
//       util.assert(this.data != null, `Error adding constant: data for placeholder '${  this.name
//             }' is null or undefined`);
//     };
//     return ConstantNode;
//   }(Node));
//   exports.ConstantNode = ConstantNode;
//   var ReshapeNode = (function (_super) {
//     __extends(ReshapeNode, _super);
//     function ReshapeNode(graph, name, x, shape) {
//       const _this = _super.call(this, graph, name, {x: x}, new Tensor(shape)) || this;
//       _this.name = name;
//       _this.x = x;
//       _this.shape = shape;
//       return _this;
//     }
//     ReshapeNode.prototype.validate = function () {
//       const xSize = util.sizeFromShape(this.x.shape);
//       const shapeSize = util.sizeFromShape(this.shape);
//       util.assert(xSize === shapeSize, `Error making reshape operation: input to reshape '${  this.name  }'` +
//             ` of shape (${  this.x.shape  }) does not match size of ` +
//             `requested shape ${  this.shape  }.`);
//     };
//     ReshapeNode.X = `x`;
//     return ReshapeNode;
//   }(Node));
//   exports.ReshapeNode = ReshapeNode;
//   var FusedLinearCombinationNode = (function (_super) {
//     __extends(FusedLinearCombinationNode, _super);
//     function FusedLinearCombinationNode(graph, t1, t2, c1, c2) {
//       const _this = _super.call(this, graph, `Linear Combination`, {t1: t1, t2: t2, c1: c1, c2: c2}, new Tensor(t1.shape)) || this;
//       _this.t1 = t1;
//       _this.t2 = t2;
//       _this.c1 = c1;
//       _this.c2 = c2;
//       return _this;
//     }
//     FusedLinearCombinationNode.prototype.validate = function () {
//       util.assertShapesMatch(this.t1.shape, this.t2.shape);
//       if (!util.isScalarShape(this.c1.shape)) {
//         throw new Error(`Error adding fusedLinearCombination: c1 is not a scalar, got ` +
//                 `shape: ${  this.c1.shape}`);
//       }
//       if (!util.isScalarShape(this.c2.shape)) {
//         throw new Error(`Error adding fusedLinearCombination: c2 is not a scalar, got ` +
//                 `shape: ${  this.c2.shape}`);
//       }
//     };
//     FusedLinearCombinationNode.T1 = `t1`;
//     FusedLinearCombinationNode.T2 = `t2`;
//     FusedLinearCombinationNode.C1 = `c1`;
//     FusedLinearCombinationNode.C2 = `c2`;
//     return FusedLinearCombinationNode;
//   }(Node));
//   exports.FusedLinearCombinationNode = FusedLinearCombinationNode;
//   var AddNode = (function (_super) {
//     __extends(AddNode, _super);
//     function AddNode(graph, t1, t2) {
//       const _this = _super.call(this, graph, `Add`, {t1: t1, t2: t2}, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
//       _this.t1 = t1;
//       _this.t2 = t2;
//       return _this;
//     }
//     AddNode.prototype.validate = function () {
//       util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
//             util.sizeFromShape(this.t2.shape) === 1 ||
//             util.arraysEqual(this.t1.shape, this.t2.shape), `Error adding add operation op: one of inputs must be scalar or the ` +
//             `shapes ${  this.t1.shape  } and ${  this.t2.shape  } must match.`);
//     };
//     AddNode.T1 = `t1`;
//     AddNode.T2 = `t2`;
//     return AddNode;
//   }(Node));
//   exports.AddNode = AddNode;
//   var SubtractNode = (function (_super) {
//     __extends(SubtractNode, _super);
//     function SubtractNode(graph, t1, t2) {
//       const _this = _super.call(this, graph, `Subtract`, {t1: t1, t2: t2}, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
//       _this.t1 = t1;
//       _this.t2 = t2;
//       return _this;
//     }
//     SubtractNode.prototype.validate = function () {
//       util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
//             util.sizeFromShape(this.t2.shape) === 1 ||
//             util.arraysEqual(this.t1.shape, this.t2.shape), `Error adding subtract op: one of inputs must be scalar or the ` +
//             `shapes ${  this.t1.shape  } and ${  this.t2.shape  } must match.`);
//     };
//     SubtractNode.T1 = `t1`;
//     SubtractNode.T2 = `t2`;
//     return SubtractNode;
//   }(Node));
//   exports.SubtractNode = SubtractNode;
//   var MultiplyNode = (function (_super) {
//     __extends(MultiplyNode, _super);
//     function MultiplyNode(graph, t1, t2) {
//       const _this = _super.call(this, graph, `Multiply`, {t1: t1, t2: t2}, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
//       _this.t1 = t1;
//       _this.t2 = t2;
//       return _this;
//     }
//     MultiplyNode.prototype.validate = function () {
//       util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
//             util.sizeFromShape(this.t2.shape) === 1 ||
//             util.arraysEqual(this.t1.shape, this.t2.shape), `Error adding multiply op: one of inputs must be scalar or the ` +
//             `shapes ${  this.t1.shape  } and ${  this.t2.shape  } must match.`);
//     };
//     MultiplyNode.T1 = `t1`;
//     MultiplyNode.T2 = `t2`;
//     return MultiplyNode;
//   }(Node));
//   exports.MultiplyNode = MultiplyNode;
//   var DivideNode = (function (_super) {
//     __extends(DivideNode, _super);
//     function DivideNode(graph, t1, t2) {
//       const _this = _super.call(this, graph, `Divide`, {t1: t1, t2: t2}, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
//       _this.t1 = t1;
//       _this.t2 = t2;
//       return _this;
//     }
//     DivideNode.prototype.validate = function () {
//       util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
//             util.sizeFromShape(this.t2.shape) === 1 ||
//             util.arraysEqual(this.t1.shape, this.t2.shape), `Error adding divide op: one of inputs must be scalar or the ` +
//             `shapes ${  this.t1.shape  } and ${  this.t2.shape  } must match.`);
//     };
//     DivideNode.T1 = `t1`;
//     DivideNode.T2 = `t2`;
//     return DivideNode;
//   }(Node));
//   exports.DivideNode = DivideNode;
//   var ReduceSumNode = (function (_super) {
//     __extends(ReduceSumNode, _super);
//     function ReduceSumNode(graph, x) {
//       return _super.call(this, graph, `ReduceSum`, {x: x}, new Tensor([])) || this;
//     }
//     ReduceSumNode.prototype.validate = function () { };
//     ReduceSumNode.X = `x`;
//     return ReduceSumNode;
//   }(Node));
//   exports.ReduceSumNode = ReduceSumNode;
//   var Concat3DNode = (function (_super) {
//     __extends(Concat3DNode, _super);
//     function Concat3DNode(graph, x1, x2, axis) {
//       const _this = _super.call(this, graph, `Concat3D`, {x1: x1, x2: x2}, new Tensor(concat_util.computeOutShape(x1.shape, x2.shape, axis))) || this;
//       _this.x1 = x1;
//       _this.x2 = x2;
//       _this.axis = axis;
//       return _this;
//     }
//     Concat3DNode.prototype.validate = function () {
//       concat_util.assertParams(this.x1.shape, this.x2.shape, this.axis);
//     };
//     Concat3DNode.X1 = `x1`;
//     Concat3DNode.X2 = `x2`;
//     Concat3DNode.AXIS = `axis`;
//     return Concat3DNode;
//   }(Node));
//   exports.Concat3DNode = Concat3DNode;
//   function getMatMulOutputShape(x1Shape, x2Shape) {
//     if (x1Shape.length === 1 && x2Shape.length === 1) {
//       return [1];
//     }
//     else if (x1Shape.length === 1 && x2Shape.length === 2) {
//       return [x2Shape[1]];
//     }
//     else if (x1Shape.length === 2 && x2Shape.length === 1) {
//       return [x1Shape[0]];
//     }
//     return [x1Shape[0], x2Shape[1]];
//   }
//   var MatMulNode = (function (_super) {
//     __extends(MatMulNode, _super);
//     function MatMulNode(graph, x1, x2) {
//       const _this = _super.call(this, graph, `MatMul`, {x1: x1, x2: x2}, new Tensor(getMatMulOutputShape(x1.shape, x2.shape))) || this;
//       _this.x1 = x1;
//       _this.x2 = x2;
//       return _this;
//     }
//     MatMulNode.prototype.validate = function () {
//       if (this.x1.shape.length === 2 && this.x2.shape.length === 2) {
//         util.assert(this.x1.shape[1] === this.x2.shape[0], `Error adding matmul op: inner shapes of matrices with shapes ${
//                 this.x1.shape  } and ${  this.x2.shape  } must match.`);
//       }
//       else if (this.x1.shape.length === 2 && this.x2.shape.length === 1) {
//         util.assert(this.x1.shape[1] === this.x2.shape[0], `Error adding matmul op: second dimension of matrix with shape ${
//                 this.x1.shape.toString()
//                 } must match size of vector with shape ${  this.x2.shape  }.`);
//       }
//       else if (this.x1.shape.length === 1 && this.x2.shape.length === 2) {
//         util.assert(this.x1.shape[0] === this.x2.shape[0], `Error adding matmul op: size of vector with shape ${  this.x1.shape
//                 } must match first dimension of matrix with ` +
//                 `shape ${  this.x2.shape  }.`);
//       }
//       else {
//         throw new Error(`Error adding matmul op: inputs must be vectors or matrices.`);
//       }
//     };
//     MatMulNode.X1 = `x1`;
//     MatMulNode.X2 = `x2`;
//     return MatMulNode;
//   }(Node));
//   exports.MatMulNode = MatMulNode;
//   var Convolution2DNode = (function (_super) {
//     __extends(Convolution2DNode, _super);
//     function Convolution2DNode(graph, x, w, b, fieldSize, outputDepth, stride, zeroPad) {
//       if (stride === void 0) { stride = 1; }
//       const _this = _super.call(this, graph, `Convolution 2D`, {x: x, w: w, b: b}, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, outputDepth, stride, zeroPad))) || this;
//       _this.x = x;
//       _this.w = w;
//       _this.b = b;
//       _this.fieldSize = fieldSize;
//       _this.outputDepth = outputDepth;
//       _this.stride = stride;
//       _this.zeroPad = zeroPad;
//       return _this;
//     }
//     Convolution2DNode.prototype.validate = function () {
//       util.assert(this.x.shape.length === 3, `Error adding conv2d op: input must be of rank 3, but got shape: ${
//             this.x.shape  }.`);
//       util.assert(this.w.shape.length === 4, `Error adding conv2d op: weights must be of rank 4, but got shape: ${
//             this.w.shape  }.`);
//       util.assert(this.b.shape.length === 1, `Error adding conv2d op: biases must be of rank 1, but got shape: ${
//             this.b.shape  }.`);
//       util.assert(this.x.shape[2] === this.w.shape[2], `Error adding conv2d op: depth of input (${  this.x.shape[2]  }) ` +
//             `must match input depth for weights (${  this.w.shape[2]  }).`);
//     };
//     Convolution2DNode.X = `x`;
//     Convolution2DNode.W = `w`;
//     Convolution2DNode.B = `b`;
//     return Convolution2DNode;
//   }(Node));
//   exports.Convolution2DNode = Convolution2DNode;
//   var MaxPoolNode = (function (_super) {
//     __extends(MaxPoolNode, _super);
//     function MaxPoolNode(graph, x, fieldSize, stride, zeroPad) {
//       if (stride === void 0) { stride = 1; }
//       const _this = _super.call(this, graph, `Max pool`, {x: x}, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, x.shape[2], stride, zeroPad))) || this;
//       _this.x = x;
//       _this.fieldSize = fieldSize;
//       _this.stride = stride;
//       _this.zeroPad = zeroPad;
//       return _this;
//     }
//     MaxPoolNode.prototype.validate = function () {
//       util.assert(this.x.shape.length === 3, `Error adding maxPool op: input must be of rank 3, but got shape: ${
//             this.x.shape  }.`);
//     };
//     MaxPoolNode.X = `x`;
//     return MaxPoolNode;
//   }(Node));
//   exports.MaxPoolNode = MaxPoolNode;
//   var ReLUNode = (function (_super) {
//     __extends(ReLUNode, _super);
//     function ReLUNode(graph, x) {
//       return _super.call(this, graph, `ReLU`, {x: x}, new Tensor(x.shape)) || this;
//     }
//     ReLUNode.prototype.validate = function () { };
//     ReLUNode.X = `x`;
//     return ReLUNode;
//   }(Node));
//   exports.ReLUNode = ReLUNode;
//   var LeakyReLUNode = (function (_super) {
//     __extends(LeakyReLUNode, _super);
//     function LeakyReLUNode(graph, x, alpha) {
//       const _this = _super.call(this, graph, `LeakyReLU`, {x: x}, new Tensor(x.shape)) || this;
//       _this.alpha = alpha;
//       return _this;
//     }
//     LeakyReLUNode.prototype.validate = function () { };
//     LeakyReLUNode.X = `x`;
//     return LeakyReLUNode;
//   }(Node));
//   exports.LeakyReLUNode = LeakyReLUNode;
//   var ExpNode = (function (_super) {
//     __extends(ExpNode, _super);
//     function ExpNode(graph, x) {
//       return _super.call(this, graph, `Exp`, {x: x}, new Tensor(x.shape)) || this;
//     }
//     ExpNode.prototype.validate = function () { };
//     ExpNode.X = `x`;
//     return ExpNode;
//   }(Node));
//   exports.ExpNode = ExpNode;
//   var LogNode = (function (_super) {
//     __extends(LogNode, _super);
//     function LogNode(graph, x) {
//       return _super.call(this, graph, `Log`, {x: x}, new Tensor(x.shape)) || this;
//     }
//     LogNode.prototype.validate = function () { };
//     LogNode.X = `x`;
//     return LogNode;
//   }(Node));
//   exports.LogNode = LogNode;
//   var TanHNode = (function (_super) {
//     __extends(TanHNode, _super);
//     function TanHNode(graph, x) {
//       return _super.call(this, graph, `TanH`, {x: x}, new Tensor(x.shape)) || this;
//     }
//     TanHNode.prototype.validate = function () { };
//     TanHNode.X = `x`;
//     return TanHNode;
//   }(Node));
//   exports.TanHNode = TanHNode;
//   var SigmoidNode = (function (_super) {
//     __extends(SigmoidNode, _super);
//     function SigmoidNode(graph, x) {
//       return _super.call(this, graph, `Sigmoid`, {x: x}, new Tensor(x.shape)) || this;
//     }
//     SigmoidNode.prototype.validate = function () { };
//     SigmoidNode.X = `x`;
//     return SigmoidNode;
//   }(Node));
//   exports.SigmoidNode = SigmoidNode;
//   var SquareNode = (function (_super) {
//     __extends(SquareNode, _super);
//     function SquareNode(graph, x) {
//       return _super.call(this, graph, `Square`, {x: x}, new Tensor(x.shape)) || this;
//     }
//     SquareNode.prototype.validate = function () { };
//     SquareNode.X = `x`;
//     return SquareNode;
//   }(Node));
//   exports.SquareNode = SquareNode;
//   var SoftmaxCrossEntropyCostNode = (function (_super) {
//     __extends(SoftmaxCrossEntropyCostNode, _super);
//     function SoftmaxCrossEntropyCostNode(graph, x, target) {
//       const _this = _super.call(this, graph, `SoftmaxCrossEntropyCost`, {x: x, target: target}, new Tensor([])) || this;
//       _this.x = x;
//       _this.target = target;
//       return _this;
//     }
//     SoftmaxCrossEntropyCostNode.prototype.validate = function () {
//       util.assert(util.arraysEqual(this.x.shape, this.target.shape), `Error adding softmaxCrossEntropyCost op: x shape (${  this.x.shape  }) ` +
//             `must match target shape (${  this.target.shape  }).`);
//     };
//     SoftmaxCrossEntropyCostNode.X = `x`;
//     SoftmaxCrossEntropyCostNode.TARGET = `target`;
//     return SoftmaxCrossEntropyCostNode;
//   }(Node));
//   exports.SoftmaxCrossEntropyCostNode = SoftmaxCrossEntropyCostNode;
//   var SoftmaxNode = (function (_super) {
//     __extends(SoftmaxNode, _super);
//     function SoftmaxNode(graph, x) {
//       const _this = _super.call(this, graph, `Softmax`, {x: x}, new Tensor(x.shape)) || this;
//       _this.x = x;
//       return _this;
//     }
//     SoftmaxNode.prototype.validate = function () {
//       util.assert(this.x.shape.length === 1, `The input to a softmax must be a 1-D tensor`);
//       util.assert(this.x.shape[0] >= 2, `The input to a softmax must have at least 2 values`);
//     };
//     SoftmaxNode.X = `x`;
//     return SoftmaxNode;
//   }(Node));
//   exports.SoftmaxNode = SoftmaxNode;
//   var MeanSquaredCostNode = (function (_super) {
//     __extends(MeanSquaredCostNode, _super);
//     function MeanSquaredCostNode(graph, label, prediction) {
//       const _this = _super.call(this, graph, `Mean Squared Cost`, {label: label, prediction: prediction}, new Tensor([])) || this;
//       _this.label = label;
//       _this.prediction = prediction;
//       return _this;
//     }
//     MeanSquaredCostNode.prototype.validate = function () {
//       util.assert(util.arraysEqual(this.label.shape, this.prediction.shape), `Error adding meanSquaredCost op: label shape (${  this.label.shape  }) ` +
//             `must match prediction shape (${  this.prediction.shape  }).`);
//     };
//     MeanSquaredCostNode.LABEL = `label`;
//     MeanSquaredCostNode.PREDICTION = `prediction`;
//     return MeanSquaredCostNode;
//   }(Node));
//   exports.MeanSquaredCostNode = MeanSquaredCostNode;
//   var ArgMaxNode = (function (_super) {
//     __extends(ArgMaxNode, _super);
//     function ArgMaxNode(graph, x) {
//       const _this = _super.call(this, graph, `ArgMax`, {x: x}, new Tensor([1])) || this;
//       _this.x = x;
//       return _this;
//     }
//     ArgMaxNode.prototype.validate = function () {
//       util.assert(util.sizeFromShape(this.x.shape) > 0, `Error adding argmax op: input tensor must have at least one entry.`);
//     };
//     ArgMaxNode.X = `x`;
//     return ArgMaxNode;
//   }(Node));
//   exports.ArgMaxNode = ArgMaxNode;
//   var ArgMaxEqualsNode = (function (_super) {
//     __extends(ArgMaxEqualsNode, _super);
//     function ArgMaxEqualsNode(graph, x1, x2) {
//       const _this = _super.call(this, graph, `ArgMaxEquals`, {x1: x1, x2: x2}, new Tensor([1])) || this;
//       _this.x1 = x1;
//       _this.x2 = x2;
//       return _this;
//     }
//     ArgMaxEqualsNode.prototype.validate = function () {
//       util.assert(util.arraysEqual(this.x1.shape, this.x2.shape), `Error adding ArgMaxEquals op: x1 shape (${  this.x1.shape  }) ` +
//             `must match x2 shape (${  this.x2.shape  }).`);
//     };
//     ArgMaxEqualsNode.X1 = `x1`;
//     ArgMaxEqualsNode.X2 = `x2`;
//     return ArgMaxEqualsNode;
//   }(Node));
//   exports.ArgMaxEqualsNode = ArgMaxEqualsNode;
//
// }, {"../initializers": 44, "../math/concat_util": 48, "../math/conv_util": 49, "../math/ndarray": 55, "../util": 88}], 9: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const graph_1 = require(`./graph`);
//   const priority_queue = require(`./priority_queue`);
//   const priority_queue_1 = require(`./priority_queue`);
//   function getUnorderedEvaluationSet(nodes, terminatingNodes) {
//     const terminatingNodeMap = {};
//     const seen = {};
//     const set = [];
//     const visit = nodes.slice();
//     terminatingNodes.forEach(function (node) { return terminatingNodeMap[node.id] = node; });
//     const _loop_1 = function () {
//       const cur = visit.pop();
//       if (seen[cur.id] == null) {
//         if (terminatingNodeMap[cur.id] == null) {
//           Object.keys(cur.inputs)
//                     .map(function (inputName) { return cur.inputs[inputName]; })
//                     .forEach(function (input) { return visit.push(input.node); });
//         }
//         set.push(cur);
//         seen[cur.id] = cur;
//       }
//     };
//     while (visit.length !== 0) {
//       _loop_1();
//     }
//     return set;
//   }
//   exports.getUnorderedEvaluationSet = getUnorderedEvaluationSet;
//   function getOrderedEvaluationSet(unorderedEvaluationSet) {
//     const set = [];
//     const nodeIndices = {};
//     const pendingDependencies = {};
//     const nodeQueue = new priority_queue_1.PriorityQueue(function (a, b) { return priority_queue.defaultCompare(pendingDependencies[a.id], pendingDependencies[b.id]); }, function (node, newIndex) { return nodeIndices[node.id] = newIndex; });
//     unorderedEvaluationSet.forEach(function (node) { return pendingDependencies[node.id] = 0; });
//     unorderedEvaluationSet.forEach(function (node) { return Object.keys(node.inputs)
//         .map(function (key) { return node.inputs[key]; })
//         .forEach(function (input) {
//           if (unorderedEvaluationSet.indexOf(input.node) !== - 1) {
//             pendingDependencies [input.node.id]++;
//           }
//         }); });
//     unorderedEvaluationSet.forEach(function (node) { return nodeQueue.enqueue(node); });
//     while (!nodeQueue.empty()) {
//       set.unshift(nodeQueue.dequeue());
//       Object.keys(set[0].inputs).map(function (key) { return set[0].inputs[key]; }).forEach(function (input) {
//         if (unorderedEvaluationSet.indexOf(input.node) === - 1) {
//           return;
//         }
//         pendingDependencies [input.node.id]--;
//         nodeQueue.update(input.node, nodeIndices[input.node.id]);
//       });
//     }
//     return set;
//   }
//   exports.getOrderedEvaluationSet = getOrderedEvaluationSet;
//   function isInputNode(node) {
//     return Object.keys(node.inputs).length === 0;
//   }
//   exports.isInputNode = isInputNode;
//   function shouldBackProp(t) {
//     return !(t.node instanceof graph_1.ConstantNode);
//   }
//   exports.shouldBackProp = shouldBackProp;
//   function isPassthroughNode(node, map) {
//     const keys = Object.keys(node.inputs);
//     for (let i = 0;i < keys.length;i ++) {
//       const input = node.inputs[keys[i]];
//       if (map.get(input, true) === map.get(node.output, true)) {
//         return true;
//       }
//     }
//     return false;
//   }
//   exports.isPassthroughNode = isPassthroughNode;
//
// }, {"./graph": 8, "./priority_queue": 38}], 10: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const graph_1 = require(`./graph`);
//   const graph_util = require(`./graph_util`);
//   const add_1 = require(`./ops/add`);
//   const argmax_1 = require(`./ops/argmax`);
//   const argmaxequals_1 = require(`./ops/argmaxequals`);
//   const concat3d_1 = require(`./ops/concat3d`);
//   const convolution_1 = require(`./ops/convolution`);
//   const divide_1 = require(`./ops/divide`);
//   const element_wise_activation_1 = require(`./ops/element_wise_activation`);
//   const element_wise_cost_1 = require(`./ops/element_wise_cost`);
//   const exp_1 = require(`./ops/exp`);
//   const linear_combination_1 = require(`./ops/linear_combination`);
//   const log_1 = require(`./ops/log`);
//   const matmul_1 = require(`./ops/matmul`);
//   const max_pool_1 = require(`./ops/max_pool`);
//   const multiply_1 = require(`./ops/multiply`);
//   const reduce_sum_1 = require(`./ops/reduce_sum`);
//   const reshape_1 = require(`./ops/reshape`);
//   const softmax_1 = require(`./ops/softmax`);
//   const subtract_1 = require(`./ops/subtract`);
//   function emitFromGraphNodes(nodes) {
//     const ops = [];
//     nodes.forEach(function (node) { return Array.prototype.push.apply(ops, emitOpFromNode(node)); });
//     return ops;
//   }
//   exports.emitFromGraphNodes = emitFromGraphNodes;
//   function emitOpFromNode(node) {
//     if (node instanceof graph_1.ReshapeNode) {
//       return [new reshape_1.Reshape(node.inputs[graph_1.ReshapeNode.X], node.output)];
//     }
//     else if (node instanceof graph_1.MatMulNode) {
//       const x1 = node.inputs[graph_1.MatMulNode.X1];
//       const x2 = node.inputs[graph_1.MatMulNode.X2];
//       return [new matmul_1.MatMul(x1, x2, node.output)];
//     }
//     else if (node instanceof graph_1.Convolution2DNode) {
//       const w = node.inputs[graph_1.Convolution2DNode.W];
//       var x = node.inputs[graph_1.Convolution2DNode.X];
//       const b = node.inputs[graph_1.Convolution2DNode.B];
//       return [new convolution_1.Convolution2D(w, x, b, node.output, node.fieldSize, node.outputDepth, node.stride, node.zeroPad)];
//     }
//     else if (node instanceof graph_1.MaxPoolNode) {
//       var x = node.inputs[graph_1.MaxPoolNode.X];
//       return [new max_pool_1.MaxPool(x, node.output, node.fieldSize, node.stride, node.zeroPad)];
//     }
//     else if (node instanceof graph_1.ExpNode) {
//       return [new exp_1.Exp(node.inputs[graph_1.ExpNode.X], node.output)];
//     }
//     else if (node instanceof graph_1.LogNode) {
//       return [new log_1.Log(node.inputs[graph_1.LogNode.X], node.output)];
//     }
//     else if (node instanceof graph_1.ReLUNode) {
//       return [new element_wise_activation_1.ReLU(node.inputs[graph_1.ReLUNode.X], node.output)];
//     }
//     else if (node instanceof graph_1.LeakyReLUNode) {
//       return [new element_wise_activation_1.LeakyReLU(node.inputs[graph_1.LeakyReLUNode.X], node.output, node.alpha)];
//     }
//     else if (node instanceof graph_1.TanHNode) {
//       return [new element_wise_activation_1.TanH(node.inputs[graph_1.TanHNode.X], node.output)];
//     }
//     else if (node instanceof graph_1.SigmoidNode) {
//       return [new element_wise_activation_1.Sigmoid(node.inputs[graph_1.SigmoidNode.X], node.output)];
//     }
//     else if (node instanceof graph_1.SoftmaxCrossEntropyCostNode) {
//       var x = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.X];
//       const target = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.TARGET];
//       return [new softmax_1.SoftmaxCrossEntropyCost(x, target, node.output)];
//     }
//     else if (node instanceof graph_1.SoftmaxNode) {
//       return [new softmax_1.Softmax(node.inputs[graph_1.SoftmaxNode.X], node.output)];
//     }
//     else if (node instanceof graph_1.MeanSquaredCostNode) {
//       const label = node.inputs[graph_1.MeanSquaredCostNode.LABEL];
//       const prediction = node.inputs[graph_1.MeanSquaredCostNode.PREDICTION];
//       return [new element_wise_cost_1.MeanSquaredCost(label, prediction, node.output)];
//     }
//     else if (node instanceof graph_1.ArgMaxEqualsNode) {
//       return [new argmaxequals_1.ArgMaxEquals(node.inputs[graph_1.ArgMaxEqualsNode.X1], node.inputs[graph_1.ArgMaxEqualsNode.X2], node.output)];
//     }
//     else if (node instanceof graph_1.ArgMaxNode) {
//       return [new argmax_1.ArgMax(node.x, node.output)];
//     }
//     else if (node instanceof graph_1.FusedLinearCombinationNode) {
//       return [new linear_combination_1.LinearCombination(node.inputs[graph_1.FusedLinearCombinationNode.T1], node.inputs[graph_1.FusedLinearCombinationNode.T2], node.inputs[graph_1.FusedLinearCombinationNode.C1], node.inputs[graph_1.FusedLinearCombinationNode.C2], node.output)];
//     }
//     else if (node instanceof graph_1.Concat3DNode) {
//       return [new concat3d_1.Concat3D(node.inputs[graph_1.Concat3DNode.X1], node.inputs[graph_1.Concat3DNode.X2], node.axis, node.output)];
//     }
//     else if (node instanceof graph_1.SquareNode) {
//       return [new element_wise_activation_1.Square(node.inputs[graph_1.SquareNode.X], node.output)];
//     }
//     else if (node instanceof graph_1.AddNode) {
//       return [new add_1.Add(node.inputs[graph_1.AddNode.T1], node.inputs[graph_1.AddNode.T2], node.output)];
//     }
//     else if (node instanceof graph_1.SubtractNode) {
//       return [new subtract_1.Subtract(node.inputs[graph_1.SubtractNode.T1], node.inputs[graph_1.SubtractNode.T2], node.output)];
//     }
//     else if (node instanceof graph_1.MultiplyNode) {
//       return [new multiply_1.Multiply(node.inputs[graph_1.MultiplyNode.T1], node.inputs[graph_1.MultiplyNode.T2], node.output)];
//     }
//     else if (node instanceof graph_1.DivideNode) {
//       return [new divide_1.Divide(node.inputs[graph_1.DivideNode.T1], node.inputs[graph_1.DivideNode.T2], node.output)];
//     }
//     else if (node instanceof graph_1.ReduceSumNode) {
//       return [new reduce_sum_1.ReduceSum(node.inputs[graph_1.ReduceSumNode.X], node.output)];
//     }
//     else if (graph_util.isInputNode(node)) {
//       return [];
//     }
//     else {
//       throw Error(`Unsupported node type: ${  node.constructor.name}`);
//     }
//   }
//
// }, {"./graph": 8, "./graph_util": 9, "./ops/add": 11, "./ops/argmax": 12, "./ops/argmaxequals": 13, "./ops/concat3d": 14, "./ops/convolution": 15, "./ops/divide": 16, "./ops/element_wise_activation": 17, "./ops/element_wise_cost": 18, "./ops/exp": 19, "./ops/linear_combination": 20, "./ops/log": 21, "./ops/matmul": 22, "./ops/max_pool": 23, "./ops/multiply": 24, "./ops/reduce_sum": 26, "./ops/reshape": 27, "./ops/softmax": 28, "./ops/subtract": 29}], 11: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../../math/ndarray`);
//   const util = require(`../../util`);
//   const graph_util = require(`../graph_util`);
//   const op_1 = require(`./op`);
//   const Add = (function (_super) {
//     __extends(Add, _super);
//     function Add(x1Tensor, x2Tensor, yTensor) {
//       const _this = _super.call(this) || this;
//       _this.x1Tensor = x1Tensor;
//       _this.x2Tensor = x2Tensor;
//       _this.yTensor = yTensor;
//       util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
//             util.sizeFromShape(x2Tensor.shape) === 1 ||
//             util.arraysEqual(x1Tensor.shape, x2Tensor.shape), `One of t1 or t2 must be a scalar, or t1 and t2 must have ` +
//             `the same shape`);
//       return _this;
//     }
//     Add.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const x1 = inferenceArrays.get(this.x1Tensor);
//       const x2 = inferenceArrays.get(this.x2Tensor);
//       math.scope(function (keep) {
//         let result;
//         if (util.isScalarShape(x1.shape)) {
//           result = math.scalarPlusArray(x1, x2);
//         }
//         else if (util.isScalarShape(x2.shape)) {
//           result = math.scalarPlusArray(x2, x1);
//         }
//         else {
//           result = math.add(x1, x2);
//         }
//         inferenceArrays.set(_this.yTensor, keep(result));
//       });
//     };
//     Add.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       const dy = gradientArrays.get(this.yTensor);
//       math.scope(function () {
//         if (graph_util.shouldBackProp(_this.x1Tensor)) {
//           if (util.isScalarShape(_this.x1Tensor.shape)) {
//             var sum = math.sum(dy);
//             if (_this.dySizeScalar == null) {
//               _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
//             }
//             gradientArrays.add(_this.x1Tensor, math.divide(sum, _this.dySizeScalar));
//           }
//           else {
//             gradientArrays.add(_this.x1Tensor, math.clone(dy));
//           }
//         }
//         if (graph_util.shouldBackProp(_this.x2Tensor)) {
//           if (util.isScalarShape(_this.x2Tensor.shape)) {
//             var sum = math.sum(dy);
//             if (_this.dySizeScalar == null) {
//               _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
//             }
//             gradientArrays.add(_this.x2Tensor, math.divide(sum, _this.dySizeScalar));
//           }
//           else {
//             gradientArrays.add(_this.x2Tensor, math.clone(dy));
//           }
//         }
//       });
//     };
//     Add.prototype.dispose = function () {
//       if (this.dySizeScalar != null) {
//         this.dySizeScalar.dispose();
//       }
//     };
//     return Add;
//   }(op_1.Operation));
//   exports.Add = Add;
//
// }, {"../../math/ndarray": 55, "../../util": 88, "../graph_util": 9, "./op": 25}], 12: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const op_1 = require(`./op`);
//   const ArgMax = (function (_super) {
//     __extends(ArgMax, _super);
//     function ArgMax(xTensor, yTensor) {
//       const _this = _super.call(this) || this;
//       _this.xTensor = xTensor;
//       _this.yTensor = yTensor;
//       return _this;
//     }
//     ArgMax.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const x = inferenceArrays.get(this.xTensor);
//       math.scope(function (keep) {
//         inferenceArrays.set(_this.yTensor, keep(math.argMax(x)));
//       });
//     };
//     ArgMax.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       throw new Error(`ArgMax backprop unimplemented`);
//     };
//     return ArgMax;
//   }(op_1.Operation));
//   exports.ArgMax = ArgMax;
//
// }, {"./op": 25}], 13: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const op_1 = require(`./op`);
//   const ArgMaxEquals = (function (_super) {
//     __extends(ArgMaxEquals, _super);
//     function ArgMaxEquals(x1Tensor, x2Tensor, yTensor) {
//       const _this = _super.call(this) || this;
//       _this.x1Tensor = x1Tensor;
//       _this.x2Tensor = x2Tensor;
//       _this.yTensor = yTensor;
//       return _this;
//     }
//     ArgMaxEquals.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const x1 = inferenceArrays.get(this.x1Tensor);
//       const x2 = inferenceArrays.get(this.x2Tensor);
//       math.scope(function (keep) {
//         inferenceArrays.set(_this.yTensor, keep(math.argMaxEquals(x1, x2)));
//       });
//     };
//     ArgMaxEquals.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       throw new Error(`ArgMaxEquals backprop unimplemented`);
//     };
//     return ArgMaxEquals;
//   }(op_1.Operation));
//   exports.ArgMaxEquals = ArgMaxEquals;
//
// }, {"./op": 25}], 14: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const concat_util = require(`../../math/concat_util`);
//   const op_1 = require(`./op`);
//   const Concat3D = (function (_super) {
//     __extends(Concat3D, _super);
//     function Concat3D(x1Tensor, x2Tensor, axis, yTensor) {
//       const _this = _super.call(this) || this;
//       _this.x1Tensor = x1Tensor;
//       _this.x2Tensor = x2Tensor;
//       _this.axis = axis;
//       _this.yTensor = yTensor;
//       concat_util.assertParams(x1Tensor.shape, x2Tensor.shape, axis);
//       return _this;
//     }
//     Concat3D.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const x1 = inferenceArrays.get(this.x1Tensor);
//       const x2 = inferenceArrays.get(this.x2Tensor);
//       math.scope(function (keep) {
//         const concatResult = math.concat3D(x1, x2, _this.axis);
//         inferenceArrays.set(_this.yTensor, keep(concatResult));
//       });
//     };
//     Concat3D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       throw new Error(`Concat3D backprop not implemented.`);
//     };
//     return Concat3D;
//   }(op_1.Operation));
//   exports.Concat3D = Concat3D;
//
// }, {"../../math/concat_util": 48, "./op": 25}], 15: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const conv_util = require(`../../math/conv_util`);
//   const util = require(`../../util`);
//   const op_1 = require(`./op`);
//   const Convolution2D = (function (_super) {
//     __extends(Convolution2D, _super);
//     function Convolution2D(wTensor, xTensor, bTensor, yTensor, fieldSize, outputDepth, stride, zeroPad) {
//       if (stride === void 0) { stride = 1; }
//       const _this = _super.call(this) || this;
//       _this.wTensor = wTensor;
//       _this.xTensor = xTensor;
//       _this.bTensor = bTensor;
//       _this.yTensor = yTensor;
//       _this.fieldSize = fieldSize;
//       _this.outputDepth = outputDepth;
//       _this.stride = stride;
//       _this.assertWeightsShape(wTensor.shape);
//       _this.zeroPad = zeroPad != null ?
//             zeroPad :
//             conv_util.computeDefaultPad(_this.xTensor.shape, _this.fieldSize, _this.stride);
//       util.assert(util.isInt(_this.zeroPad), `The zero padding (${  _this.zeroPad  }) must be an integer. Change the ` +
//             `stride and/or zero pad parameters`);
//       return _this;
//     }
//     Convolution2D.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const weights = inferenceArrays.get(this.wTensor);
//       const biases = inferenceArrays.get(this.bTensor);
//       const x = inferenceArrays.get(this.xTensor);
//       math.scope(function (keep) {
//         inferenceArrays.set(_this.yTensor, keep(math.conv2d(x, weights, biases, _this.stride, _this.zeroPad)));
//       });
//     };
//     Convolution2D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       const weights = inferenceArrays.get(this.wTensor);
//       const x = inferenceArrays.get(this.xTensor);
//       const dy = gradientArrays.get(this.yTensor);
//       math.scope(function () {
//         let _a = math.conv2dBackProp(x, dy, weights, _this.stride, _this.zeroPad), dw = _a.dw, db = _a.db, dx = _a.dx;
//         gradientArrays.add(_this.wTensor, dw);
//         gradientArrays.add(_this.bTensor, db);
//         gradientArrays.add(_this.xTensor, dx);
//       });
//     };
//     Convolution2D.prototype.assertWeightsShape = function (weightsShape) {
//       util.assert(weightsShape[0] === this.fieldSize &&
//             weightsShape[1] === this.fieldSize &&
//             weightsShape[2] === this.xTensor.shape[2] &&
//             weightsShape[3] === this.outputDepth, `weights must be of shape [${  this.fieldSize  },${  this.fieldSize  },${
//             this.xTensor.shape[2]  },${  this.outputDepth  }] but they are ofshape [${  weightsShape  }]`);
//     };
//     return Convolution2D;
//   }(op_1.Operation));
//   exports.Convolution2D = Convolution2D;
//
// }, {"../../math/conv_util": 49, "../../util": 88, "./op": 25}], 16: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const util = require(`../../util`);
//   const graph_util = require(`../graph_util`);
//   const op_1 = require(`./op`);
//   const Divide = (function (_super) {
//     __extends(Divide, _super);
//     function Divide(x1Tensor, x2Tensor, yTensor) {
//       const _this = _super.call(this) || this;
//       _this.x1Tensor = x1Tensor;
//       _this.x2Tensor = x2Tensor;
//       _this.yTensor = yTensor;
//       util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
//             util.sizeFromShape(x2Tensor.shape) === 1 ||
//             util.arraysEqual(x1Tensor.shape, x2Tensor.shape), `One of t1 or t2 must be a scalar, or t1 and t2 must have ` +
//             `the same shape`);
//       return _this;
//     }
//     Divide.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const t1 = inferenceArrays.get(this.x1Tensor);
//       const t2 = inferenceArrays.get(this.x2Tensor);
//       math.scope(function (keep) {
//         let result;
//         if (util.isScalarShape(t1.shape)) {
//           result = math.scalarDividedByArray(t1, t2);
//         }
//         else if (util.isScalarShape(t2.shape)) {
//           result = math.arrayDividedByScalar(t1, t2);
//         }
//         else {
//           result = math.divide(t1, t2);
//         }
//         inferenceArrays.set(_this.yTensor, keep(result));
//       });
//     };
//     Divide.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       const x1 = inferenceArrays.get(this.x1Tensor);
//       const x2 = inferenceArrays.get(this.x2Tensor);
//       const dy = gradientArrays.get(this.yTensor);
//       const x1IsScalar = util.isScalarShape(x1.shape);
//       const x2IsScalar = util.isScalarShape(x2.shape);
//       math.scope(function () {
//         if (graph_util.shouldBackProp(_this.x1Tensor)) {
//           if (x1IsScalar) {
//             const div = math.divide(dy, x2);
//             gradientArrays.add(_this.x1Tensor, math.sum(div));
//             div.dispose();
//           }
//           else if (x2IsScalar) {
//             gradientArrays.add(_this.x1Tensor, math.arrayDividedByScalar(dy, x2));
//           }
//           else {
//             gradientArrays.add(_this.x1Tensor, math.divide(dy, x2));
//           }
//         }
//         if (graph_util.shouldBackProp(_this.x2Tensor)) {
//           const x2Squared = math.elementWiseMul(x2, x2);
//           let x1OverX2Squared = void 0;
//           if (x2IsScalar) {
//             x1OverX2Squared = math.arrayDividedByScalar(x1, x2Squared);
//           }
//           else if (x1IsScalar) {
//             x1OverX2Squared = math.scalarDividedByArray(x1, x2Squared);
//           }
//           else {
//             x1OverX2Squared = math.divide(x1, x2Squared);
//           }
//           const dx2 = math.neg(x1OverX2Squared);
//           const dyTimesDerivative = math.elementWiseMul(dy, dx2);
//           if (x2IsScalar) {
//             gradientArrays.add(_this.x2Tensor, math.sum(dyTimesDerivative));
//           }
//           else {
//             gradientArrays.add(_this.x2Tensor, dyTimesDerivative);
//           }
//         }
//       });
//     };
//     return Divide;
//   }(op_1.Operation));
//   exports.Divide = Divide;
//
// }, {"../../util": 88, "../graph_util": 9, "./op": 25}], 17: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const activation_functions_1 = require(`../../math/activation_functions`);
//   const op_1 = require(`./op`);
//   const ElementWiseActivation = (function (_super) {
//     __extends(ElementWiseActivation, _super);
//     function ElementWiseActivation(xTensor, yTensor, func) {
//       const _this = _super.call(this) || this;
//       _this.xTensor = xTensor;
//       _this.yTensor = yTensor;
//       _this.func = func;
//       return _this;
//     }
//     ElementWiseActivation.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const x = inferenceArrays.get(this.xTensor);
//       math.scope(function (keep) {
//         inferenceArrays.set(_this.yTensor, keep(_this.func.output(math, x)));
//       });
//     };
//     ElementWiseActivation.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       const x = inferenceArrays.get(this.xTensor);
//       const y = inferenceArrays.get(this.yTensor);
//       const dy = gradientArrays.get(this.yTensor);
//       math.scope(function () {
//         const dydx = _this.func.der(math, x, y);
//         gradientArrays.add(_this.xTensor, math.elementWiseMul(dy, dydx));
//         dydx.dispose();
//       });
//     };
//     ElementWiseActivation.prototype.dispose = function () {
//       this.func.dispose();
//     };
//     return ElementWiseActivation;
//   }(op_1.Operation));
//   exports.ElementWiseActivation = ElementWiseActivation;
//   const ReLU = (function (_super) {
//     __extends(ReLU, _super);
//     function ReLU(xTensor, yTensor) {
//       return _super.call(this, xTensor, yTensor, new activation_functions_1.ReLUFunc()) || this;
//     }
//     return ReLU;
//   }(ElementWiseActivation));
//   exports.ReLU = ReLU;
//   const LeakyReLU = (function (_super) {
//     __extends(LeakyReLU, _super);
//     function LeakyReLU(xTensor, yTensor, alpha) {
//       return _super.call(this, xTensor, yTensor, new activation_functions_1.LeakyReluFunc(alpha)) || this;
//     }
//     return LeakyReLU;
//   }(ElementWiseActivation));
//   exports.LeakyReLU = LeakyReLU;
//   const TanH = (function (_super) {
//     __extends(TanH, _super);
//     function TanH(xTensor, yTensor) {
//       return _super.call(this, xTensor, yTensor, new activation_functions_1.TanHFunc()) || this;
//     }
//     return TanH;
//   }(ElementWiseActivation));
//   exports.TanH = TanH;
//   const Sigmoid = (function (_super) {
//     __extends(Sigmoid, _super);
//     function Sigmoid(xTensor, yTensor) {
//       return _super.call(this, xTensor, yTensor, new activation_functions_1.SigmoidFunc()) || this;
//     }
//     return Sigmoid;
//   }(ElementWiseActivation));
//   exports.Sigmoid = Sigmoid;
//   const Square = (function (_super) {
//     __extends(Square, _super);
//     function Square(xTensor, yTensor) {
//       return _super.call(this, xTensor, yTensor, new activation_functions_1.SquareFunc()) || this;
//     }
//     return Square;
//   }(ElementWiseActivation));
//   exports.Square = Square;
//
// }, {"../../math/activation_functions": 45, "./op": 25}], 18: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const cost_functions_1 = require(`../../math/cost_functions`);
//   const ndarray_1 = require(`../../math/ndarray`);
//   const util = require(`../../util`);
//   const graph_util = require(`../graph_util`);
//   const op_1 = require(`./op`);
//   const ElementWiseCost = (function (_super) {
//     __extends(ElementWiseCost, _super);
//     function ElementWiseCost(x1Tensor, x2Tensor, yTensor, func) {
//       const _this = _super.call(this) || this;
//       _this.x1Tensor = x1Tensor;
//       _this.x2Tensor = x2Tensor;
//       _this.yTensor = yTensor;
//       _this.func = func;
//       _this.oneOverNScalar = ndarray_1.Scalar.new(1 / util.sizeFromShape(x1Tensor.shape));
//       return _this;
//     }
//     ElementWiseCost.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const x1 = inferenceArrays.get(this.x1Tensor);
//       const x2 = inferenceArrays.get(this.x2Tensor);
//       math.scope(function (keep) {
//         const elementWiseCost = _this.func.cost(math, x1, x2);
//         const sum = math.sum(elementWiseCost);
//         const result = math.scalarTimesArray(_this.oneOverNScalar, sum);
//         inferenceArrays.set(_this.yTensor, keep(result));
//       });
//     };
//     ElementWiseCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       const x1 = inferenceArrays.get(this.x1Tensor);
//       const x2 = inferenceArrays.get(this.x2Tensor);
//       math.scope(function () {
//         if (graph_util.shouldBackProp(_this.x1Tensor)) {
//           gradientArrays.add(_this.x1Tensor, _this.func.der(math, x1, x2));
//         }
//         if (graph_util.shouldBackProp(_this.x2Tensor)) {
//           gradientArrays.add(_this.x2Tensor, _this.func.der(math, x2, x1));
//         }
//       });
//     };
//     ElementWiseCost.prototype.dispose = function () {
//       this.func.dispose();
//       this.oneOverNScalar.dispose();
//     };
//     return ElementWiseCost;
//   }(op_1.Operation));
//   exports.ElementWiseCost = ElementWiseCost;
//   const MeanSquaredCost = (function (_super) {
//     __extends(MeanSquaredCost, _super);
//     function MeanSquaredCost(x1Tensor, x2Tensor, yTensor) {
//       return _super.call(this, x1Tensor, x2Tensor, yTensor, new cost_functions_1.SquareCostFunc()) || this;
//     }
//     return MeanSquaredCost;
//   }(ElementWiseCost));
//   exports.MeanSquaredCost = MeanSquaredCost;
//
// }, {"../../math/cost_functions": 51, "../../math/ndarray": 55, "../../util": 88, "../graph_util": 9, "./op": 25}], 19: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const graph_util = require(`../graph_util`);
//   const op_1 = require(`./op`);
//   const Exp = (function (_super) {
//     __extends(Exp, _super);
//     function Exp(xTensor, yTensor) {
//       const _this = _super.call(this) || this;
//       _this.xTensor = xTensor;
//       _this.yTensor = yTensor;
//       return _this;
//     }
//     Exp.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const x = inferenceArrays.get(this.xTensor);
//       math.scope(function (keep) {
//         inferenceArrays.set(_this.yTensor, keep(math.exp(x)));
//       });
//     };
//     Exp.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       const y = inferenceArrays.get(this.yTensor);
//       const dy = gradientArrays.get(this.yTensor);
//       math.scope(function () {
//         if (graph_util.shouldBackProp(_this.xTensor)) {
//           gradientArrays.add(_this.xTensor, math.elementWiseMul(y, dy));
//         }
//       });
//     };
//     return Exp;
//   }(op_1.Operation));
//   exports.Exp = Exp;
//
// }, {"../graph_util": 9, "./op": 25}], 20: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const graph_util = require(`../graph_util`);
//   const op_1 = require(`./op`);
//   const LinearCombination = (function (_super) {
//     __extends(LinearCombination, _super);
//     function LinearCombination(x1Tensor, x2Tensor, c1Tensor, c2Tensor, outTensor) {
//       const _this = _super.call(this) || this;
//       _this.x1Tensor = x1Tensor;
//       _this.x2Tensor = x2Tensor;
//       _this.c1Tensor = c1Tensor;
//       _this.c2Tensor = c2Tensor;
//       _this.outTensor = outTensor;
//       return _this;
//     }
//     LinearCombination.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const x1 = inferenceArrays.get(this.x1Tensor);
//       const x2 = inferenceArrays.get(this.x2Tensor);
//       const c1 = inferenceArrays.get(this.c1Tensor).asScalar();
//       const c2 = inferenceArrays.get(this.c2Tensor).asScalar();
//       math.scope(function (keep) {
//         inferenceArrays.set(_this.outTensor, keep(math.scaledArrayAdd(c1, x1, c2, x2)));
//       });
//     };
//     LinearCombination.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       const x1 = inferenceArrays.get(this.x1Tensor);
//       const x2 = inferenceArrays.get(this.x2Tensor);
//       const c1 = inferenceArrays.get(this.c1Tensor);
//       const c2 = inferenceArrays.get(this.c2Tensor);
//       const dy = gradientArrays.get(this.outTensor);
//       math.scope(function () {
//         if (graph_util.shouldBackProp(_this.x1Tensor)) {
//           gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(c1, dy));
//         }
//         if (graph_util.shouldBackProp(_this.x2Tensor)) {
//           gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(c2, dy));
//         }
//         if (graph_util.shouldBackProp(_this.c1Tensor)) {
//           const dotProduct1 = math.elementWiseMul(x1, dy);
//           gradientArrays.add(_this.c1Tensor, math.sum(dotProduct1));
//         }
//         if (graph_util.shouldBackProp(_this.c2Tensor)) {
//           const dotProduct2 = math.elementWiseMul(x2, dy);
//           gradientArrays.add(_this.c2Tensor, math.sum(dotProduct2));
//         }
//       });
//     };
//     return LinearCombination;
//   }(op_1.Operation));
//   exports.LinearCombination = LinearCombination;
//
// }, {"../graph_util": 9, "./op": 25}], 21: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const graph_util = require(`../graph_util`);
//   const op_1 = require(`./op`);
//   const Log = (function (_super) {
//     __extends(Log, _super);
//     function Log(xTensor, yTensor) {
//       const _this = _super.call(this) || this;
//       _this.xTensor = xTensor;
//       _this.yTensor = yTensor;
//       return _this;
//     }
//     Log.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const x = inferenceArrays.get(this.xTensor);
//       math.scope(function (keep) {
//         inferenceArrays.set(_this.yTensor, keep(math.log(x)));
//       });
//     };
//     Log.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       const x = inferenceArrays.get(this.xTensor);
//       const dy = gradientArrays.get(this.yTensor);
//       math.scope(function () {
//         if (graph_util.shouldBackProp(_this.xTensor)) {
//           gradientArrays.add(_this.xTensor, math.divide(dy, x));
//         }
//       });
//     };
//     return Log;
//   }(op_1.Operation));
//   exports.Log = Log;
//
// }, {"../graph_util": 9, "./op": 25}], 22: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const math_1 = require(`../../math/math`);
//   const graph_util = require(`../graph_util`);
//   const op_1 = require(`./op`);
//   const MatMul = (function (_super) {
//     __extends(MatMul, _super);
//     function MatMul(x1Tensor, x2Tensor, yTensor) {
//       const _this = _super.call(this) || this;
//       _this.x1Tensor = x1Tensor;
//       _this.x2Tensor = x2Tensor;
//       _this.yTensor = yTensor;
//       return _this;
//     }
//     MatMul.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const x1 = inferenceArrays.get(this.x1Tensor);
//       const x2 = inferenceArrays.get(this.x2Tensor);
//       math.scope(function (keep) {
//         if (x1.shape.length === 2 && x2.shape.length === 2) {
//           inferenceArrays.set(_this.yTensor, keep(math.matMul(x1, x2)));
//         }
//         else if (x1.shape.length === 2 && x2.shape.length === 1) {
//           inferenceArrays.set(_this.yTensor, keep(math.matrixTimesVector(x1, x2)));
//         }
//         else if (x1.shape.length === 1 && x2.shape.length === 2) {
//           inferenceArrays.set(_this.yTensor, keep(math.vectorTimesMatrix(x1, x2)));
//         }
//       });
//     };
//     MatMul.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       let x1 = inferenceArrays.get(this.x1Tensor);
//       let x2 = inferenceArrays.get(this.x2Tensor);
//       let dy = gradientArrays.get(this.yTensor);
//       if (x1.shape.length === 1) {
//         x1 = x1.reshape([1, x1.size]);
//         dy = dy.reshape([1, dy.size]);
//       }
//       if (x2.shape.length === 1) {
//         x2 = x2.reshape([x2.size, 1]);
//         dy = dy.reshape([dy.size, 1]);
//       }
//       math.scope(function () {
//         if (graph_util.shouldBackProp(_this.x1Tensor)) {
//           const dx1 = math.matMul(dy, x2, math_1.MatrixOrientation.REGULAR, math_1.MatrixOrientation.TRANSPOSED);
//           gradientArrays.add(_this.x1Tensor, _this.x1Tensor.shape.length === 1 ? dx1.as1D() : dx1);
//         }
//         if (graph_util.shouldBackProp(_this.x2Tensor)) {
//           const dx2 = math.matMul(x1, dy, math_1.MatrixOrientation.TRANSPOSED, math_1.MatrixOrientation.REGULAR);
//           gradientArrays.add(_this.x2Tensor, _this.x2Tensor.shape.length === 1 ? dx2.as1D() : dx2);
//         }
//       });
//     };
//     return MatMul;
//   }(op_1.Operation));
//   exports.MatMul = MatMul;
//
// }, {"../../math/math": 52, "../graph_util": 9, "./op": 25}], 23: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const conv_util = require(`../../math/conv_util`);
//   const util = require(`../../util`);
//   const op_1 = require(`./op`);
//   const MaxPool = (function (_super) {
//     __extends(MaxPool, _super);
//     function MaxPool(xTensor, yTensor, fieldSize, stride, pad) {
//       if (stride === void 0) { stride = 1; }
//       const _this = _super.call(this) || this;
//       _this.xTensor = xTensor;
//       _this.yTensor = yTensor;
//       _this.fieldSize = fieldSize;
//       _this.stride = stride;
//       if (pad != null) {
//         _this.pad = pad;
//       }
//       else {
//         _this.pad = conv_util.computeDefaultPad(xTensor.shape, _this.fieldSize, _this.stride);
//       }
//       util.assert(util.isInt(_this.pad), `The zero padding (${  _this.pad  }) must be an integer. Change the ` +
//             `stride and/or zero pad parameters`);
//       return _this;
//     }
//     MaxPool.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const x = inferenceArrays.get(this.xTensor);
//       math.scope(function (keep) {
//         inferenceArrays.set(_this.yTensor, keep(math.maxPool(x, _this.fieldSize, _this.stride, _this.pad)));
//       });
//     };
//     MaxPool.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       const x = inferenceArrays.get(this.xTensor);
//       const dy = gradientArrays.get(this.yTensor);
//       math.scope(function () {
//         gradientArrays.add(_this.xTensor, math.maxPoolBackprop(dy, x, _this.fieldSize, _this.stride, _this.pad));
//       });
//     };
//     return MaxPool;
//   }(op_1.Operation));
//   exports.MaxPool = MaxPool;
//
// }, {"../../math/conv_util": 49, "../../util": 88, "./op": 25}], 24: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const util = require(`../../util`);
//   const graph_util = require(`../graph_util`);
//   const op_1 = require(`./op`);
//   const Multiply = (function (_super) {
//     __extends(Multiply, _super);
//     function Multiply(x1Tensor, x2Tensor, yTensor) {
//       const _this = _super.call(this) || this;
//       _this.x1Tensor = x1Tensor;
//       _this.x2Tensor = x2Tensor;
//       _this.yTensor = yTensor;
//       util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
//             util.sizeFromShape(x2Tensor.shape) === 1 ||
//             util.arraysEqual(x1Tensor.shape, x2Tensor.shape), `One of t1 or t2 must be a scalar, or t1 and t2 must have ` +
//             `the same shape`);
//       return _this;
//     }
//     Multiply.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const t1 = inferenceArrays.get(this.x1Tensor);
//       const t2 = inferenceArrays.get(this.x2Tensor);
//       math.scope(function (keep) {
//         let result;
//         if (util.isScalarShape(t1.shape)) {
//           result = math.scalarTimesArray(t1, t2);
//         }
//         else if (util.isScalarShape(t2.shape)) {
//           result = math.scalarTimesArray(t2, t1);
//         }
//         else {
//           result = math.elementWiseMul(t1, t2);
//         }
//         inferenceArrays.set(_this.yTensor, keep(result));
//       });
//     };
//     Multiply.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       const x1 = inferenceArrays.get(this.x1Tensor);
//       const x2 = inferenceArrays.get(this.x2Tensor);
//       const dy = gradientArrays.get(this.yTensor);
//       math.scope(function () {
//         if (graph_util.shouldBackProp(_this.x1Tensor)) {
//           if (util.isScalarShape(_this.x1Tensor.shape)) {
//             var mul = math.elementWiseMul(dy, x2);
//             gradientArrays.add(_this.x1Tensor, math.sum(mul));
//           }
//           else if (util.isScalarShape(x2.shape)) {
//             gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(x2, dy));
//           }
//           else {
//             gradientArrays.add(_this.x1Tensor, math.elementWiseMul(x2, dy));
//           }
//         }
//         if (graph_util.shouldBackProp(_this.x2Tensor)) {
//           if (util.isScalarShape(_this.x2Tensor.shape)) {
//             var mul = math.elementWiseMul(dy, x1);
//             gradientArrays.add(_this.x2Tensor, math.sum(mul));
//           }
//           else if (util.isScalarShape(x1.shape)) {
//             gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(x1, dy));
//           }
//           else {
//             gradientArrays.add(_this.x2Tensor, math.elementWiseMul(x1, dy));
//           }
//         }
//       });
//     };
//     return Multiply;
//   }(op_1.Operation));
//   exports.Multiply = Multiply;
//
// }, {"../../util": 88, "../graph_util": 9, "./op": 25}], 25: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const Operation = (function () {
//     function Operation() {
//     }
//     Operation.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) { };
//     Operation.prototype.dispose = function () { };
//     return Operation;
//   }());
//   exports.Operation = Operation;
//
// }, {}], 26: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../../math/ndarray`);
//   const util = require(`../../util`);
//   const graph_util = require(`../graph_util`);
//   const op_1 = require(`./op`);
//   const ReduceSum = (function (_super) {
//     __extends(ReduceSum, _super);
//     function ReduceSum(x, outTensor) {
//       const _this = _super.call(this) || this;
//       _this.x = x;
//       _this.outTensor = outTensor;
//       util.assertShapesMatch(outTensor.shape, []);
//       return _this;
//     }
//     ReduceSum.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const x = inferenceArrays.get(this.x);
//       math.scope(function (keep) {
//         inferenceArrays.set(_this.outTensor, keep(math.sum(x)));
//       });
//     };
//     ReduceSum.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       if (!graph_util.shouldBackProp(this.x)) {
//         return;
//       }
//       math.scope(function () {
//         const dy = gradientArrays.get(_this.outTensor);
//         if (_this.ones == null) {
//           const xArray = inferenceArrays.get(_this.x);
//           _this.ones = ndarray_1.NDArray.zerosLike(xArray);
//           _this.ones.fill(1);
//         }
//         gradientArrays.add(_this.x, math.scalarTimesArray(dy, _this.ones));
//       });
//     };
//     return ReduceSum;
//   }(op_1.Operation));
//   exports.ReduceSum = ReduceSum;
//
// }, {"../../math/ndarray": 55, "../../util": 88, "../graph_util": 9, "./op": 25}], 27: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const util = require(`../../util`);
//   const op_1 = require(`./op`);
//   const Reshape = (function (_super) {
//     __extends(Reshape, _super);
//     function Reshape(xTensor, yTensor) {
//       const _this = _super.call(this) || this;
//       _this.xTensor = xTensor;
//       _this.yTensor = yTensor;
//       const xSize = util.sizeFromShape(xTensor.shape);
//       const ySize = util.sizeFromShape(yTensor.shape);
//       util.assert(xSize === ySize, `The input size (${  xSize  }) and output size (${  ySize  }) must match`);
//       return _this;
//     }
//     Reshape.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const x = inferenceArrays.get(this.xTensor);
//       const clone = math.clone(x);
//       math.scope(function (keep) {
//         inferenceArrays.set(_this.yTensor, keep(clone.reshape(_this.yTensor.shape)));
//       });
//     };
//     Reshape.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       const dy = gradientArrays.get(this.yTensor);
//       const clone = math.clone(dy);
//       math.scope(function () {
//         gradientArrays.add(_this.xTensor, clone.reshape(_this.xTensor.shape));
//       });
//     };
//     return Reshape;
//   }(op_1.Operation));
//   exports.Reshape = Reshape;
//
// }, {"../../util": 88, "./op": 25}], 28: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../../math/ndarray`);
//   const util = require(`../../util`);
//   const graph_1 = require(`../graph`);
//   const op_1 = require(`./op`);
//   const Softmax = (function (_super) {
//     __extends(Softmax, _super);
//     function Softmax(logitsTensor, output) {
//       const _this = _super.call(this) || this;
//       _this.logitsTensor = logitsTensor;
//       _this.output = output;
//       return _this;
//     }
//     Softmax.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const logits = inferenceArrays.get(this.logitsTensor);
//       return math.scope(function (keep) {
//         inferenceArrays.set(_this.output, keep(math.softmax(logits)));
//       });
//     };
//     Softmax.prototype.backProp = function () {
//       throw Error(`Softmax backprop is not yet implemented`);
//     };
//     return Softmax;
//   }(op_1.Operation));
//   exports.Softmax = Softmax;
//   const SoftmaxCrossEntropyCost = (function (_super) {
//     __extends(SoftmaxCrossEntropyCost, _super);
//     function SoftmaxCrossEntropyCost(logitsTensor, labelTensor, yTensor) {
//       const _this = _super.call(this) || this;
//       _this.logitsTensor = logitsTensor;
//       _this.labelTensor = labelTensor;
//       _this.yTensor = yTensor;
//       _this.epsilon = ndarray_1.Scalar.new(1e-5);
//       _this.softmaxTensor = new graph_1.Tensor(logitsTensor.shape);
//       return _this;
//     }
//     SoftmaxCrossEntropyCost.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const logits = inferenceArrays.get(this.logitsTensor);
//       const label = inferenceArrays.get(this.labelTensor);
//       math.scope(function (keep) {
//         const softmaxResult = math.softmax(logits);
//         inferenceArrays.set(_this.softmaxTensor, keep(softmaxResult));
//         inferenceArrays.set(_this.yTensor, keep(crossEntropyCost(math, softmaxResult, label, _this.epsilon)));
//       });
//     };
//     SoftmaxCrossEntropyCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       const softmax = inferenceArrays.get(this.softmaxTensor);
//       const label = inferenceArrays.get(this.labelTensor);
//       math.scope(function () {
//         gradientArrays.add(_this.logitsTensor, math.subtract(softmax, label));
//       });
//     };
//     SoftmaxCrossEntropyCost.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) {
//       inferenceArrays.disposeArray(this.softmaxTensor);
//     };
//     SoftmaxCrossEntropyCost.prototype.dispose = function () {
//       this.epsilon.dispose();
//     };
//     return SoftmaxCrossEntropyCost;
//   }(op_1.Operation));
//   exports.SoftmaxCrossEntropyCost = SoftmaxCrossEntropyCost;
//   function crossEntropyCost(math, y, target, epsilon) {
//     util.assert(y.size === target.size, `The output and target must be the same size`);
//     return math.scope(function () {
//       const yPlusEps = math.scalarPlusArray(epsilon, y);
//       const logOutput = math.log(yPlusEps);
//       const tarLogOutput = math.elementWiseMul(target, logOutput);
//       const costVector = math.neg(tarLogOutput);
//       return math.sum(costVector);
//     });
//   }
//   exports.crossEntropyCost = crossEntropyCost;
//
// }, {"../../math/ndarray": 55, "../../util": 88, "../graph": 8, "./op": 25}], 29: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../../math/ndarray`);
//   const util = require(`../../util`);
//   const graph_util = require(`../graph_util`);
//   const op_1 = require(`./op`);
//   const Subtract = (function (_super) {
//     __extends(Subtract, _super);
//     function Subtract(t1, t2, outTensor) {
//       const _this = _super.call(this) || this;
//       _this.t1 = t1;
//       _this.t2 = t2;
//       _this.outTensor = outTensor;
//       util.assert(util.sizeFromShape(t1.shape) === 1 ||
//             util.sizeFromShape(t2.shape) === 1 ||
//             util.arraysEqual(t1.shape, t2.shape), `One of t1 or t2 must be a scalar, or t1 and t2 must have ` +
//             `the same shape`);
//       return _this;
//     }
//     Subtract.prototype.feedForward = function (math, inferenceArrays) {
//       const _this = this;
//       const t1 = inferenceArrays.get(this.t1);
//       const t2 = inferenceArrays.get(this.t2);
//       math.scope(function (keep) {
//         let result;
//         if (util.isScalarShape(t1.shape)) {
//           result = math.scalarMinusArray(t1, t2);
//         }
//         else if (util.isScalarShape(t2.shape)) {
//           result = math.arrayMinusScalar(t1, t2);
//         }
//         else {
//           result = math.subtract(t1, t2);
//         }
//         inferenceArrays.set(_this.outTensor, keep(result));
//       });
//     };
//     Subtract.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
//       const _this = this;
//       const dy = gradientArrays.get(this.outTensor);
//       math.scope(function () {
//         if (graph_util.shouldBackProp(_this.t1)) {
//           if (util.isScalarShape(_this.t1.shape)) {
//             var sum = math.sum(dy);
//             if (_this.dySizeScalar == null) {
//               _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
//             }
//             gradientArrays.add(_this.t1, math.divide(sum, _this.dySizeScalar));
//           }
//           else {
//             gradientArrays.add(_this.t1, math.clone(dy));
//           }
//         }
//         if (graph_util.shouldBackProp(_this.t2)) {
//           if (util.isScalarShape(_this.t2.shape)) {
//             var sum = math.sum(dy);
//             const negSum = math.neg(sum);
//             if (_this.dySizeScalar == null) {
//               _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
//             }
//             gradientArrays.add(_this.t2, math.divide(negSum, _this.dySizeScalar));
//           }
//           else {
//             gradientArrays.add(_this.t2, math.neg(dy));
//           }
//         }
//       });
//     };
//     Subtract.prototype.dispose = function () {
//       if (this.dySizeScalar != null) {
//         this.dySizeScalar.dispose();
//       }
//     };
//     return Subtract;
//   }(op_1.Operation));
//   exports.Subtract = Subtract;
//
// }, {"../../math/ndarray": 55, "../../util": 88, "../graph_util": 9, "./op": 25}], 30: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../../math/ndarray`);
//   const tensor_array_map_1 = require(`../tensor_array_map`);
//   const optimizer_1 = require(`./optimizer`);
//   const AdadeltaOptimizer = (function (_super) {
//     __extends(AdadeltaOptimizer, _super);
//     function AdadeltaOptimizer(learningRate, gamma, specifiedVariableList) {
//       const _this = _super.call(this, learningRate, specifiedVariableList) || this;
//       _this.learningRate = learningRate;
//       _this.gamma = gamma;
//       _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
//       _this.accumulatedUpdates = new tensor_array_map_1.TensorArrayMap();
//       _this.eps = ndarray_1.Scalar.new(1e-6);
//       _this.g = ndarray_1.Scalar.new(_this.gamma);
//       return _this;
//     }
//     AdadeltaOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
//       if (this.accumulatedSquaredGradients.size() === 0) {
//         this.variableNodes.forEach(function (node) {
//           _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
//           _this.accumulatedUpdates.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
//         });
//       }
//     };
//     AdadeltaOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       math.scope(function (keep) {
//         _this.variableNodes.forEach(function (node) {
//           const oldVariable = activationArrayMap.get(node.output);
//           const gradient = _this.variableGradients.get(node.output);
//           const oldCache = _this.accumulatedSquaredGradients.get(node.output);
//           const oldUpdates = _this.accumulatedUpdates.get(node.output);
//           const gradientSquare = math.multiply(gradient, gradient);
//           const cache = math.scaledArrayAdd(_this.g, oldCache, math.subtract(_this.one, _this.g), gradientSquare);
//           const updates = math.multiply(math.divide(math.sqrt(math.add(oldUpdates, _this.eps)), math.sqrt(math.add(oldCache, _this.eps))), gradient);
//           const variable = math.scaledArrayAdd(_this.c, updates, _this.one, oldVariable);
//           const updateSquare = math.multiply(updates, updates);
//           const newUpdates = math.scaledArrayAdd(_this.g, oldUpdates, math.subtract(_this.one, _this.g), updateSquare);
//           _this.accumulatedSquaredGradients.set(node.output, keep(cache));
//           _this.accumulatedUpdates.set(node.output, keep(newUpdates));
//           activationArrayMap.set(node.output, keep(variable));
//           node.data = variable;
//           oldVariable.dispose();
//           oldCache.dispose();
//           oldUpdates.dispose();
//         });
//       });
//       this.variableGradients.dispose();
//       this.variableGradients = new tensor_array_map_1.TensorArrayMap();
//     };
//     AdadeltaOptimizer.prototype.dispose = function () {
//       _super.prototype.dispose.call(this);
//       this.eps.dispose();
//       this.g.dispose();
//       this.accumulatedSquaredGradients.dispose();
//       this.accumulatedUpdates.dispose();
//     };
//     return AdadeltaOptimizer;
//   }(optimizer_1.Optimizer));
//   exports.AdadeltaOptimizer = AdadeltaOptimizer;
//
// }, {"../../math/ndarray": 55, "../tensor_array_map": 41, "./optimizer": 35}], 31: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../../math/ndarray`);
//   const tensor_array_map_1 = require(`../tensor_array_map`);
//   const optimizer_1 = require(`./optimizer`);
//   const AdagradOptimizer = (function (_super) {
//     __extends(AdagradOptimizer, _super);
//     function AdagradOptimizer(learningRate, specifiedVariableList) {
//       const _this = _super.call(this, learningRate, specifiedVariableList) || this;
//       _this.learningRate = learningRate;
//       _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
//       _this.eps = ndarray_1.Scalar.new(1e-6);
//       return _this;
//     }
//     AdagradOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
//       if (this.accumulatedSquaredGradients.size() === 0) {
//         this.variableNodes.forEach(function (node) {
//           _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
//         });
//       }
//     };
//     AdagradOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       math.scope(function (keep) {
//         _this.variableNodes.forEach(function (node) {
//           const oldVariable = activationArrayMap.get(node.output);
//           const gradient = _this.variableGradients.get(node.output);
//           const oldCache = _this.accumulatedSquaredGradients.get(node.output);
//           const gradientSquare = math.multiply(gradient, gradient);
//           const cache = math.add(oldCache, gradientSquare);
//           const variable = math.scaledArrayAdd(_this.c, math.divide(gradient, math.add(math.sqrt(cache), _this.eps)), _this.one, oldVariable);
//           _this.accumulatedSquaredGradients.set(node.output, keep(cache));
//           activationArrayMap.set(node.output, keep(variable));
//           node.data = variable;
//           oldVariable.dispose();
//           oldCache.dispose();
//         });
//       });
//       this.variableGradients.dispose();
//       this.variableGradients = new tensor_array_map_1.TensorArrayMap();
//     };
//     AdagradOptimizer.prototype.dispose = function () {
//       _super.prototype.dispose.call(this);
//       this.eps.dispose();
//       this.accumulatedSquaredGradients.dispose();
//     };
//     return AdagradOptimizer;
//   }(optimizer_1.Optimizer));
//   exports.AdagradOptimizer = AdagradOptimizer;
//
// }, {"../../math/ndarray": 55, "../tensor_array_map": 41, "./optimizer": 35}], 32: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../../math/ndarray`);
//   const tensor_array_map_1 = require(`../tensor_array_map`);
//   const optimizer_1 = require(`./optimizer`);
//   const AdamOptimizer = (function (_super) {
//     __extends(AdamOptimizer, _super);
//     function AdamOptimizer(learningRate, beta1, beta2, specifiedVariableList) {
//       const _this = _super.call(this, learningRate, specifiedVariableList) || this;
//       _this.learningRate = learningRate;
//       _this.beta1 = beta1;
//       _this.beta2 = beta2;
//       _this.firstMoment = new tensor_array_map_1.TensorArrayMap();
//       _this.secondMoment = new tensor_array_map_1.TensorArrayMap();
//       _this.eps = ndarray_1.Scalar.new(1e-8);
//       _this.b1 = ndarray_1.Scalar.new(_this.beta1);
//       _this.b2 = ndarray_1.Scalar.new(_this.beta2);
//       _this.accB1 = ndarray_1.Scalar.new(_this.beta1);
//       _this.accB2 = ndarray_1.Scalar.new(_this.beta2);
//       return _this;
//     }
//     AdamOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
//       if (this.firstMoment.size() === 0) {
//         this.variableNodes.forEach(function (node) {
//           _this.firstMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
//         });
//       }
//       if (this.secondMoment.size() === 0) {
//         this.variableNodes.forEach(function (node) {
//           _this.secondMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
//         });
//       }
//     };
//     AdamOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       math.scope(function (keep) {
//         _this.variableNodes.forEach(function (node) {
//           const oldVariable = activationArrayMap.get(node.output);
//           const gradient = _this.variableGradients.get(node.output);
//           const oldFirstMoment = _this.firstMoment.get(node.output);
//           const oldSecondMoment = _this.secondMoment.get(node.output);
//           const newFirstMoment = math.scaledArrayAdd(_this.b1, oldFirstMoment, math.subtract(_this.one, _this.b1), gradient);
//           const gradientSquare = math.multiply(gradient, gradient);
//           const newSecondMoment = math.scaledArrayAdd(_this.b2, oldSecondMoment, math.subtract(_this.one, _this.b2), gradientSquare);
//           const biasCorrectedFirstMoment = math.divide(newFirstMoment, math.subtract(_this.one, _this.accB1));
//           const biasCorrectedSecondMoment = math.divide(newSecondMoment, math.subtract(_this.one, _this.accB2));
//           const variable = math.scaledArrayAdd(_this.c, math.divide(biasCorrectedFirstMoment, math.add(math.sqrt(biasCorrectedSecondMoment), _this.eps)), _this.one, oldVariable);
//           activationArrayMap.set(node.output, keep(variable));
//           node.data = variable;
//           _this.firstMoment.set(node.output, keep(newFirstMoment));
//           _this.secondMoment.set(node.output, keep(newSecondMoment));
//           oldVariable.dispose();
//           gradient.dispose();
//           oldFirstMoment.dispose();
//           oldSecondMoment.dispose();
//         });
//         const oldAccB1 = _this.accB1;
//         const oldAccB2 = _this.accB2;
//         _this.accB1 = keep(math.multiply(_this.accB1, _this.b1));
//         _this.accB2 = keep(math.multiply(_this.accB2, _this.b2));
//         oldAccB1.dispose();
//         oldAccB2.dispose();
//       });
//       this.variableGradients.dispose();
//       this.variableGradients = new tensor_array_map_1.TensorArrayMap();
//     };
//     AdamOptimizer.prototype.dispose = function () {
//       _super.prototype.dispose.call(this);
//       this.firstMoment.dispose();
//       this.secondMoment.dispose();
//       this.eps.dispose();
//       this.b1.dispose();
//       this.b2.dispose();
//       this.accB1.dispose();
//       this.accB2.dispose();
//     };
//     return AdamOptimizer;
//   }(optimizer_1.Optimizer));
//   exports.AdamOptimizer = AdamOptimizer;
//
// }, {"../../math/ndarray": 55, "../tensor_array_map": 41, "./optimizer": 35}], 33: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../../math/ndarray`);
//   const tensor_array_map_1 = require(`../tensor_array_map`);
//   const optimizer_1 = require(`./optimizer`);
//   const AdamaxOptimizer = (function (_super) {
//     __extends(AdamaxOptimizer, _super);
//     function AdamaxOptimizer(learningRate, beta1, beta2, specifiedVariableList) {
//       const _this = _super.call(this, learningRate, specifiedVariableList) || this;
//       _this.learningRate = learningRate;
//       _this.beta1 = beta1;
//       _this.beta2 = beta2;
//       _this.firstMoment = new tensor_array_map_1.TensorArrayMap();
//       _this.weightedInfNorm = new tensor_array_map_1.TensorArrayMap();
//       _this.eps = ndarray_1.Scalar.new(1e-8);
//       _this.b1 = ndarray_1.Scalar.new(_this.beta1);
//       _this.b2 = ndarray_1.Scalar.new(_this.beta2);
//       _this.accB1 = ndarray_1.Scalar.new(_this.beta1);
//       return _this;
//     }
//     AdamaxOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
//       if (this.firstMoment.size() === 0) {
//         this.variableNodes.forEach(function (node) {
//           _this.firstMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
//         });
//       }
//       if (this.weightedInfNorm.size() === 0) {
//         this.variableNodes.forEach(function (node) {
//           _this.weightedInfNorm.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
//         });
//       }
//     };
//     AdamaxOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       math.scope(function (keep) {
//         _this.variableNodes.forEach(function (node) {
//           const oldVariable = activationArrayMap.get(node.output);
//           const gradient = _this.variableGradients.get(node.output);
//           const oldFirstMoment = _this.firstMoment.get(node.output);
//           const oldWeightedInfNorm = _this.weightedInfNorm.get(node.output);
//           const newFirstMoment = math.scaledArrayAdd(_this.b1, oldFirstMoment, math.subtract(_this.one, _this.b1), gradient);
//           const ut0 = math.multiply(_this.b2, oldWeightedInfNorm);
//           const ut1 = math.abs(gradient);
//           const newWeightedInfNorm = math.add(math.relu(math.subtract(ut0, ut1)), ut1);
//           const variable = math.scaledArrayAdd(_this.one, oldVariable, math.divide(_this.c, math.subtract(_this.one, _this.accB1)), math.divide(newFirstMoment, math.add(_this.eps, newWeightedInfNorm)));
//           activationArrayMap.set(node.output, keep(variable));
//           node.data = variable;
//           _this.firstMoment.set(node.output, keep(newFirstMoment));
//           _this.weightedInfNorm.set(node.output, keep(newWeightedInfNorm));
//           oldVariable.dispose();
//           gradient.dispose();
//           oldFirstMoment.dispose();
//           oldWeightedInfNorm.dispose();
//         });
//         const oldAccB1 = _this.accB1;
//         _this.accB1 = keep(math.multiply(_this.accB1, _this.b1));
//         oldAccB1.dispose();
//       });
//       this.variableGradients.dispose();
//       this.variableGradients = new tensor_array_map_1.TensorArrayMap();
//     };
//     AdamaxOptimizer.prototype.dispose = function () {
//       _super.prototype.dispose.call(this);
//       this.firstMoment.dispose();
//       this.weightedInfNorm.dispose();
//       this.eps.dispose();
//       this.accB1.dispose();
//       this.b1.dispose();
//       this.b2.dispose();
//     };
//     return AdamaxOptimizer;
//   }(optimizer_1.Optimizer));
//   exports.AdamaxOptimizer = AdamaxOptimizer;
//
// }, {"../../math/ndarray": 55, "../tensor_array_map": 41, "./optimizer": 35}], 34: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../../math/ndarray`);
//   const tensor_array_map_1 = require(`../tensor_array_map`);
//   const sgd_optimizer_1 = require(`./sgd_optimizer`);
//   const MomentumOptimizer = (function (_super) {
//     __extends(MomentumOptimizer, _super);
//     function MomentumOptimizer(learningRate, momentum, specifiedVariableList) {
//       const _this = _super.call(this, learningRate, specifiedVariableList) || this;
//       _this.learningRate = learningRate;
//       _this.momentum = momentum;
//       _this.variableVelocities = new tensor_array_map_1.TensorArrayMap();
//       _this.m = ndarray_1.Scalar.new(_this.momentum);
//       return _this;
//     }
//     MomentumOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
//       if (this.variableVelocities.size() === 0) {
//         this.variableNodes.forEach(function (node) {
//           _this.variableVelocities.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
//         });
//       }
//     };
//     MomentumOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       math.scope(function (keep) {
//         _this.variableNodes.forEach(function (node) {
//           const oldVariable = activationArrayMap.get(node.output);
//           const gradient = _this.variableGradients.get(node.output);
//           const oldVelocity = _this.variableVelocities.get(node.output);
//           const velocity = math.scaledArrayAdd(_this.m, oldVelocity, _this.one, gradient);
//           const variable = math.scaledArrayAdd(_this.c, velocity, _this.one, oldVariable);
//           _this.variableVelocities.set(node.output, keep(velocity));
//           activationArrayMap.set(node.output, keep(variable));
//           node.data = variable;
//           oldVariable.dispose();
//           oldVelocity.dispose();
//         });
//       });
//       this.variableGradients.dispose();
//       this.variableGradients = new tensor_array_map_1.TensorArrayMap();
//     };
//     MomentumOptimizer.prototype.dispose = function () {
//       _super.prototype.dispose.call(this);
//       this.m.dispose();
//       this.variableVelocities.dispose();
//     };
//     MomentumOptimizer.prototype.setMomentum = function (momentum) {
//       this.momentum = momentum;
//     };
//     return MomentumOptimizer;
//   }(sgd_optimizer_1.SGDOptimizer));
//   exports.MomentumOptimizer = MomentumOptimizer;
//
// }, {"../../math/ndarray": 55, "../tensor_array_map": 41, "./sgd_optimizer": 37}], 35: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../../math/ndarray`);
//   const session_util = require(`../session_util`);
//   const tensor_array_map_1 = require(`../tensor_array_map`);
//   const Optimizer = (function () {
//     function Optimizer(learningRate, specifiedVariableList) {
//       this.learningRate = learningRate;
//       this.variableGradients = new tensor_array_map_1.TensorArrayMap();
//       this.one = ndarray_1.Scalar.new(1);
//       if (specifiedVariableList != null) {
//         this.specifiedVariableNodes = specifiedVariableList;
//       }
//     }
//     Optimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       this.variableNodes = this.specifiedVariableNodes == null ?
//             session_util.getVariableNodesFromEvaluationSet(runtime.nodes) :
//             this.specifiedVariableNodes;
//       if (batchSize !== this.prevBatchSize) {
//         if (this.c != null) {
//           this.c.dispose();
//         }
//         this.prevBatchSize = batchSize;
//         this.c = ndarray_1.Scalar.new(- this.learningRate / batchSize);
//       }
//       this.variableNodes.forEach(function (node) { return _this.variableGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape)); });
//     };
//     Optimizer.prototype.afterExample = function (math, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       math.scope(function (keep) {
//         _this.variableNodes.forEach(function (node) {
//           const gradient = gradientArrayMap.get(node.output);
//           const accumulatedGradient = _this.variableGradients.get(node.output);
//           _this.variableGradients.set(node.output, keep(math.add(gradient, accumulatedGradient)));
//           accumulatedGradient.dispose();
//         });
//       });
//     };
//     Optimizer.prototype.dispose = function () {
//       if (this.c != null) {
//         this.c.dispose();
//       }
//       this.one.dispose();
//     };
//     return Optimizer;
//   }());
//   exports.Optimizer = Optimizer;
//
// }, {"../../math/ndarray": 55, "../session_util": 40, "../tensor_array_map": 41}], 36: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../../math/ndarray`);
//   const tensor_array_map_1 = require(`../tensor_array_map`);
//   const optimizer_1 = require(`./optimizer`);
//   const RMSPropOptimizer = (function (_super) {
//     __extends(RMSPropOptimizer, _super);
//     function RMSPropOptimizer(learningRate, gamma, specifiedVariableList) {
//       const _this = _super.call(this, learningRate, specifiedVariableList) || this;
//       _this.learningRate = learningRate;
//       _this.gamma = gamma;
//       _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
//       _this.eps = ndarray_1.Scalar.new(1e-6);
//       _this.g = ndarray_1.Scalar.new(_this.gamma);
//       return _this;
//     }
//     RMSPropOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
//       if (this.accumulatedSquaredGradients.size() === 0) {
//         this.variableNodes.forEach(function (node) {
//           _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
//         });
//       }
//     };
//     RMSPropOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       math.scope(function (keep) {
//         _this.variableNodes.forEach(function (node) {
//           const oldVariable = activationArrayMap.get(node.output);
//           const gradient = _this.variableGradients.get(node.output);
//           const oldCache = _this.accumulatedSquaredGradients.get(node.output);
//           const gradientSquare = math.multiply(gradient, gradient);
//           const cache = math.scaledArrayAdd(_this.g, oldCache, math.subtract(_this.one, _this.g), gradientSquare);
//           const variable = math.scaledArrayAdd(_this.c, math.divide(gradient, math.add(math.sqrt(cache), _this.eps)), _this.one, oldVariable);
//           _this.accumulatedSquaredGradients.set(node.output, keep(cache));
//           activationArrayMap.set(node.output, keep(variable));
//           node.data = variable;
//           oldVariable.dispose();
//           oldCache.dispose();
//         });
//       });
//       this.variableGradients.dispose();
//       this.variableGradients = new tensor_array_map_1.TensorArrayMap();
//     };
//     RMSPropOptimizer.prototype.dispose = function () {
//       _super.prototype.dispose.call(this);
//       this.eps.dispose();
//       this.g.dispose();
//       this.accumulatedSquaredGradients.dispose();
//     };
//     return RMSPropOptimizer;
//   }(optimizer_1.Optimizer));
//   exports.RMSPropOptimizer = RMSPropOptimizer;
//
// }, {"../../math/ndarray": 55, "../tensor_array_map": 41, "./optimizer": 35}], 37: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const tensor_array_map_1 = require(`../tensor_array_map`);
//   const optimizer_1 = require(`./optimizer`);
//   const SGDOptimizer = (function (_super) {
//     __extends(SGDOptimizer, _super);
//     function SGDOptimizer(learningRate, specifiedVariableList) {
//       const _this = _super.call(this, learningRate, specifiedVariableList) || this;
//       _this.learningRate = learningRate;
//       return _this;
//     }
//     SGDOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
//       const _this = this;
//       math.scope(function (keep) {
//         _this.variableNodes.forEach(function (node) {
//           const oldVariable = activationArrayMap.get(node.output);
//           const gradient = _this.variableGradients.get(node.output);
//           const variable = math.scaledArrayAdd(_this.c, gradient, _this.one, oldVariable);
//           activationArrayMap.set(node.output, keep(variable));
//           node.data = variable;
//           oldVariable.dispose();
//         });
//       });
//       this.variableGradients.dispose();
//       this.variableGradients = new tensor_array_map_1.TensorArrayMap();
//     };
//     SGDOptimizer.prototype.dispose = function () {
//       _super.prototype.dispose.call(this);
//     };
//     SGDOptimizer.prototype.setLearningRate = function (learningRate) {
//       this.learningRate = learningRate;
//     };
//     return SGDOptimizer;
//   }(optimizer_1.Optimizer));
//   exports.SGDOptimizer = SGDOptimizer;
//
// }, {"../tensor_array_map": 41, "./optimizer": 35}], 38: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   function defaultCompare(a, b) {
//     if (a === b) {
//       return 0;
//     }
//     else if (a < b) {
//       return - 1;
//     }
//     else {
//       return 1;
//     }
//   }
//   exports.defaultCompare = defaultCompare;
//   const PriorityQueue = (function () {
//     function PriorityQueue(comparator, indexObserver) {
//       this.comparator = comparator;
//       this.indexObserver = indexObserver;
//       this.heap = [];
//     }
//     PriorityQueue.prototype.enqueue = function (t) {
//       this.heap.push(t);
//       this.onIndexChanged(t, this.heap.length - 1);
//       this.siftUp(this.heap.length - 1);
//     };
//     PriorityQueue.prototype.dequeue = function () {
//       if (this.empty()) {
//         throw new Error(`dequeue called on empty priority queue.`);
//       }
//       const t = this.heap[0];
//       this.swap(0, this.heap.length - 1);
//       this.heap.pop();
//       this.siftDown(0);
//       return t;
//     };
//     PriorityQueue.prototype.update = function (newT, index) {
//       const last = (index === this.heap.length - 1);
//       if (!last) {
//         this.swap(index, this.heap.length - 1);
//       }
//       this.heap.pop();
//       if (!last) {
//         if (this.siftUpIndex(index) !== - 1) {
//           this.siftUp(index);
//         }
//         else if (this.siftDownIndex(index) !== - 1) {
//           this.siftDown(index);
//         }
//       }
//       this.enqueue(newT);
//     };
//     PriorityQueue.prototype.empty = function () {
//       return this.heap.length === 0;
//     };
//     PriorityQueue.prototype.onIndexChanged = function (t, newIndex) {
//       if (this.indexObserver) {
//         this.indexObserver(t, newIndex);
//       }
//     };
//     PriorityQueue.prototype.getParentIndex = function (index) {
//       if (index === 0) {
//         return - 1;
//       }
//       return Math.floor((index - 1) / 2);
//     };
//     PriorityQueue.prototype.getLeftChildIndex = function (index) {
//       const candidate = index * 2 + 1;
//       return candidate < this.heap.length ? candidate : - 1;
//     };
//     PriorityQueue.prototype.getRightChildIndex = function (index) {
//       const candidate = index * 2 + 2;
//       return candidate < this.heap.length ? candidate : - 1;
//     };
//     PriorityQueue.prototype.siftUpIndex = function (index) {
//       const parentIndex = this.getParentIndex(index);
//       if (parentIndex === - 1) {
//         return - 1;
//       }
//       if (this.compare(parentIndex, index) > 0) {
//         return parentIndex;
//       }
//       return - 1;
//     };
//     PriorityQueue.prototype.siftUp = function (index) {
//       let siftIndex = this.siftUpIndex(index);
//       while (siftIndex !== - 1) {
//         this.swap(index, siftIndex);
//         index = siftIndex;
//         siftIndex = this.siftUpIndex(index);
//       }
//     };
//     PriorityQueue.prototype.siftDownIndex = function (index) {
//       if (index >= this.heap.length) {
//         return - 1;
//       }
//       let largestChildIndex = index;
//       const leftChildIndex = this.getLeftChildIndex(index);
//       if ((leftChildIndex !== - 1) &&
//             (this.compare(leftChildIndex, largestChildIndex) < 0)) {
//         largestChildIndex = leftChildIndex;
//       }
//       const rightChildIndex = this.getRightChildIndex(index);
//       if ((rightChildIndex !== - 1) &&
//             (this.compare(rightChildIndex, largestChildIndex) < 0)) {
//         largestChildIndex = rightChildIndex;
//       }
//       return (largestChildIndex === index) ? - 1 : largestChildIndex;
//     };
//     PriorityQueue.prototype.siftDown = function (index) {
//       let siftIndex = this.siftDownIndex(index);
//       while (siftIndex !== - 1) {
//         this.swap(index, siftIndex);
//         index = siftIndex;
//         siftIndex = this.siftDownIndex(index);
//       }
//     };
//     PriorityQueue.prototype.compare = function (aIndex, bIndex) {
//       return this.comparator(this.heap[aIndex], this.heap[bIndex]);
//     };
//     PriorityQueue.prototype.swap = function (a, b) {
//       const temp = this.heap[a];
//       this.heap[a] = this.heap[b];
//       this.heap[b] = temp;
//       this.onIndexChanged(this.heap[a], a);
//       this.onIndexChanged(this.heap[b], b);
//     };
//     return PriorityQueue;
//   }());
//   exports.PriorityQueue = PriorityQueue;
//
// }, {}], 39: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../math/ndarray`);
//   const util = require(`../util`);
//   const operation_emitter = require(`./operation_emitter`);
//   const session_util = require(`./session_util`);
//   const tensor_array_map_1 = require(`./tensor_array_map`);
//   const FeedDictionary = (function () {
//     function FeedDictionary(feedEntries) {
//       const _this = this;
//       this.dict = {};
//       if (feedEntries) {
//         feedEntries.forEach(function (entry) { return _this.dict[entry.tensor.id] = entry; });
//       }
//     }
//     return FeedDictionary;
//   }());
//   exports.FeedDictionary = FeedDictionary;
//   let CostReduction;
//   (function (CostReduction) {
//     CostReduction[CostReduction[`NONE`] = 0] = `NONE`;
//     CostReduction[CostReduction[`SUM`] = 1] = `SUM`;
//     CostReduction[CostReduction[`MEAN`] = 2] = `MEAN`;
//   })(CostReduction = exports.CostReduction || (exports.CostReduction = {}));
//   const Session = (function () {
//     function Session(graph, math) {
//       this.math = math;
//       this.activationArrayMap = new tensor_array_map_1.TensorArrayMap();
//       this.runtimeCache = {};
//       this.oneScalar = ndarray_1.Scalar.new(1);
//       this.gradientArrayMap = new tensor_array_map_1.SummedTensorArrayMap(this.math);
//     }
//     Session.prototype.dispose = function () {
//       const _this = this;
//       this.activationArrayMap.dispose();
//       Object.keys(this.runtimeCache).forEach(function (key) {
//         const runtime = _this.runtimeCache[key];
//         if (runtime.operations) {
//           runtime.operations.forEach(function (op) { return op.dispose(); });
//         }
//       });
//       this.runtimeCache = {};
//       if (this.batchSizeScalar != null) {
//         this.batchSizeScalar.dispose();
//       }
//       this.oneScalar.dispose();
//     };
//     Session.prototype.evalAll = function (tensors, feedEntries) {
//       const _this = this;
//       return this.math.scope(function () {
//         const feed = new FeedDictionary(feedEntries);
//         const runtime = _this.getOrCreateRuntime(tensors, feed);
//         const activations = _this.activationArrayMap;
//         session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
//         session_util.disposeTransientOperationArrays(runtime.operations, _this.activationArrayMap, _this.gradientArrayMap);
//         session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
//         session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
//         runtime.operations.forEach(function (op) { return op.feedForward(_this.math, activations); });
//         const results = tensors.map(function (x) { return activations.get(x); });
//         tensors.forEach(function (x) { return activations.delete(x); });
//         session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
//         return results;
//       });
//     };
//     Session.prototype.eval = function (tensor, feedEntries) {
//       return this.evalAll([tensor], feedEntries)[0];
//     };
//     Session.prototype.train = function (costTensor, feedEntries, batchSize, optimizer, costReduction) {
//       const _this = this;
//       if (costReduction === void 0) { costReduction = CostReduction.NONE; }
//       util.assert(util.isScalarShape(costTensor.shape), `Cost tensor for training must be a scalar value.`);
//       if (this.prevBatchSize !== batchSize) {
//         this.prevBatchSize = batchSize;
//         this.batchSizeScalar = ndarray_1.Scalar.new(batchSize);
//       }
//       const feed = new FeedDictionary(feedEntries);
//       session_util.throwIfFeedDictionaryContainsNDArrays(feed);
//       const runtime = this.getOrCreateRuntime([costTensor], feed);
//       const inferenceOperations = runtime.operations;
//       const backPropOperations = runtime.operations.slice().reverse();
//       const activations = this.activationArrayMap;
//       const gradients = this.gradientArrayMap;
//       gradients.nullify(costTensor);
//       gradients.add(costTensor, this.oneScalar);
//       session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
//       optimizer.beforeBatch(this.math, batchSize, runtime, activations, gradients);
//       return this.math.scope(function (keep, track) {
//         let cost = track(ndarray_1.Scalar.new(0));
//         for (let i = 0;i < batchSize;++ i) {
//           session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
//           session_util.disposeAndInitializeOperationInputGradients(runtime.nodes, gradients);
//           session_util.disposeTransientOperationArrays(runtime.operations, activations, gradients);
//           session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
//           inferenceOperations.forEach(function (op) { return op.feedForward(_this.math, activations); });
//           backPropOperations.forEach(function (op) { return op.backProp(_this.math, activations, gradients); });
//           optimizer.afterExample(_this.math, runtime, activations, gradients);
//           session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
//           cost = _this.updateCostForExample(cost, activations.get(costTensor), costReduction);
//         }
//         optimizer.afterBatch(_this.math, batchSize, runtime, activations, gradients);
//         return _this.updateCostForBatch(cost, costReduction);
//       });
//     };
//     Session.prototype.updateCostForExample = function (totalCost, currCost, costReduction) {
//       if (costReduction === CostReduction.MEAN ||
//             costReduction === CostReduction.SUM) {
//         return this.math.add(totalCost, currCost);
//       }
//       return totalCost;
//     };
//     Session.prototype.updateCostForBatch = function (totalCost, costReduction) {
//       if (costReduction === CostReduction.MEAN) {
//         return this.math.divide(totalCost, this.batchSizeScalar);
//       }
//       return totalCost;
//     };
//     Session.prototype.getOrCreateRuntime = function (tensors, feed) {
//       const key = this.makeRuntimeCacheKey(tensors, feed);
//       let runtime = this.runtimeCache[key];
//       if (runtime === undefined) {
//         const nodes = session_util.getOrderedEvaluationSetFromEvalTensor(tensors, feed);
//         session_util.removeFeedDictionaryNodesFromEvaluationSet(feed, nodes);
//         session_util.throwErrorIfEvaluationSetContainsPlaceholderNodes(nodes);
//         const operations = operation_emitter.emitFromGraphNodes(nodes);
//         runtime = {nodes: nodes, operations: operations};
//         this.runtimeCache[key] = runtime;
//       }
//       return runtime;
//     };
//     Session.prototype.makeRuntimeCacheKey = function (tensors, feed) {
//       return `${tensors.map(function (x) { return x.id; }).sort().join(`_`)  }__${
//             Object.keys(feed.dict).sort().join(`_`)}`;
//     };
//     return Session;
//   }());
//   exports.Session = Session;
//
// }, {"../math/ndarray": 55, "../util": 88, "./operation_emitter": 10, "./session_util": 40, "./tensor_array_map": 41}], 40: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`../math/ndarray`);
//   const util = require(`../util`);
//   const graph_1 = require(`./graph`);
//   const graph_util = require(`./graph_util`);
//   function getTerminatingNodesFromFeedDictionary(feedDictionary) {
//     return Object.keys(feedDictionary.dict)
//         .map(function (tensorID) { return feedDictionary.dict[+ tensorID].tensor.node; });
//   }
//   exports.getTerminatingNodesFromFeedDictionary = getTerminatingNodesFromFeedDictionary;
//   function getOrderedEvaluationSetFromEvalTensor(evalTensors, feedDictionary) {
//     const terminatingNodes = getTerminatingNodesFromFeedDictionary(feedDictionary);
//     const evalNodes = evalTensors.map(function (x) { return x.node; });
//     const unorderedEvaluationSet = graph_util.getUnorderedEvaluationSet(evalNodes, terminatingNodes);
//     const orderedEvaluationSet = graph_util.getOrderedEvaluationSet(unorderedEvaluationSet);
//     return orderedEvaluationSet;
//   }
//   exports.getOrderedEvaluationSetFromEvalTensor = getOrderedEvaluationSetFromEvalTensor;
//   function addPersistentArraysToTensorArrayMap(evaluationSet, tensorArrayMap) {
//     evaluationSet.forEach(function (node) {
//       if (node instanceof graph_1.VariableNode || node instanceof graph_1.ConstantNode) {
//         tensorArrayMap.set(node.output, node.data);
//       }
//     });
//   }
//   exports.addPersistentArraysToTensorArrayMap = addPersistentArraysToTensorArrayMap;
//   function getVariableNodesFromEvaluationSet(evaluationSet) {
//     const nodes = [];
//     evaluationSet.forEach(function (node) {
//       if (node instanceof graph_1.VariableNode) {
//         nodes.push(node);
//       }
//     });
//     return nodes;
//   }
//   exports.getVariableNodesFromEvaluationSet = getVariableNodesFromEvaluationSet;
//   function throwIfFeedDictionaryContainsNDArrays(feedDictionary) {
//     Object.keys(feedDictionary.dict).forEach(function (tensorID) {
//       if (feedDictionary.dict[+ tensorID].data instanceof ndarray_1.NDArray) {
//         throw new Error(`training requires FeedDictionary entries to be InputProviders` +
//                 `and not NDArrays.`);
//       }
//     });
//   }
//   exports.throwIfFeedDictionaryContainsNDArrays = throwIfFeedDictionaryContainsNDArrays;
//   function loadInputsFromFeedDictionaryToTensorArrayMap(batchFeed, activations, math) {
//     Object.keys(batchFeed.dict).forEach(function (tensorID) {
//       const feedEntry = batchFeed.dict[+ tensorID];
//       let data;
//       if (feedEntry.data instanceof ndarray_1.NDArray) {
//         data = feedEntry.data;
//       }
//       else {
//         const provider = feedEntry.data;
//         data = provider.getNextCopy(math);
//       }
//       util.assert(util.arraysEqual(feedEntry.tensor.shape, data.shape), `Error loading FeedEntry: feeding NDArray of shape ${  data.shape  } ` +
//             `does not match Tensor (id: ${  feedEntry.tensor.id  }) shape: ${
//             feedEntry.tensor.shape  }.`);
//       activations.set(feedEntry.tensor, data);
//     });
//   }
//   exports.loadInputsFromFeedDictionaryToTensorArrayMap = loadInputsFromFeedDictionaryToTensorArrayMap;
//   function releaseFeedDictionaryInputsFromTensorArrayMap(batchFeed, activations, math) {
//     Object.keys(batchFeed.dict).forEach(function (tensorID) {
//       const feedEntry = batchFeed.dict[+ tensorID];
//       if (!(feedEntry.data instanceof ndarray_1.NDArray)) {
//         const provider = feedEntry.data;
//         const feedEntryArray = activations.get(feedEntry.tensor);
//         provider.disposeCopy(math, feedEntryArray);
//       }
//       activations.delete(feedEntry.tensor);
//     });
//   }
//   exports.releaseFeedDictionaryInputsFromTensorArrayMap = releaseFeedDictionaryInputsFromTensorArrayMap;
//   function removeFeedDictionaryNodesFromEvaluationSet(feedDictionary, evaluationSet) {
//     let i = 0;
//     while (i < evaluationSet.length) {
//       const node = evaluationSet[i];
//       if (feedDictionary.dict[node.output.id] != null) {
//         evaluationSet.splice(i, 1);
//       }
//       else {
//         ++ i;
//       }
//     }
//   }
//   exports.removeFeedDictionaryNodesFromEvaluationSet = removeFeedDictionaryNodesFromEvaluationSet;
//   function disposeAndInitializeOperationOutputs(evaluationSet, tensorArrayMap) {
//     evaluationSet.forEach(function (node) {
//       if (!graph_util.isInputNode(node)) {
//         if (!graph_util.isPassthroughNode(node, tensorArrayMap)) {
//           tensorArrayMap.disposeArray(node.output);
//         }
//         tensorArrayMap.set(node.output, null);
//       }
//     });
//   }
//   exports.disposeAndInitializeOperationOutputs = disposeAndInitializeOperationOutputs;
//   function disposeAndInitializeOperationInputGradients(evaluationSet, gradients) {
//     evaluationSet.forEach(function (node) {
//       Object.keys(node.inputs).forEach(function (inputName) {
//         const input = node.inputs[inputName];
//         if (gradients.get(input, true) !== gradients.get(node.output, true)) {
//           gradients.disposeArray(input);
//         }
//         gradients.nullify(input);
//       });
//     });
//   }
//   exports.disposeAndInitializeOperationInputGradients = disposeAndInitializeOperationInputGradients;
//   function disposeTransientOperationArrays(operations, activations, gradients) {
//     operations.forEach(function (op) { return op.disposeTransientArrays(activations, gradients); });
//   }
//   exports.disposeTransientOperationArrays = disposeTransientOperationArrays;
//   function throwErrorIfEvaluationSetContainsPlaceholderNodes(evaluationSet) {
//     evaluationSet.forEach(function (node) {
//       if (node instanceof graph_1.PlaceholderNode) {
//         const shape = `[${  node.output.shape.join(`, `)  }]`;
//         throw new Error(`Placeholder node "${  node.name  }" ${  shape
//                 } not present in feed dictionary.`);
//       }
//     });
//   }
//   exports.throwErrorIfEvaluationSetContainsPlaceholderNodes = throwErrorIfEvaluationSetContainsPlaceholderNodes;
//
// }, {"../math/ndarray": 55, "../util": 88, "./graph": 8, "./graph_util": 9}], 41: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const TensorArrayMapBase = (function () {
//     function TensorArrayMapBase() {
//       this.dict = {};
//     }
//     TensorArrayMapBase.prototype.get = function (tensor, skipChecks) {
//       if (skipChecks === void 0) { skipChecks = false; }
//       if (!skipChecks && this.dict[tensor.id] === undefined) {
//         throw new Error(`tensor ${  tensor.id  } not in array map.`);
//       }
//       const nda = this.dict[tensor.id];
//       if (!skipChecks && nda === null) {
//         throw new Error(`tensor ${  tensor.id  } has null array.`);
//       }
//       return nda;
//     };
//     TensorArrayMapBase.prototype.delete = function (tensor) {
//       delete this.dict[tensor.id];
//     };
//     TensorArrayMapBase.prototype.nullify = function (tensor) {
//       this.dict[tensor.id] = null;
//     };
//     TensorArrayMapBase.prototype.disposeArray = function (tensor) {
//       if (this.dict[tensor.id] === undefined) {
//         return;
//       }
//       const nda = this.dict[tensor.id];
//       if (nda === null) {
//         return;
//       }
//       nda.dispose();
//       this.dict[tensor.id] = null;
//     };
//     TensorArrayMapBase.prototype.size = function () {
//       return Object.keys(this.dict).length;
//     };
//     TensorArrayMapBase.prototype.dispose = function () {
//       const _this = this;
//       Object.keys(this.dict).forEach(function (tensorID) {
//         const nda = _this.dict[+ tensorID];
//         if (nda) {
//           nda.dispose();
//         }
//       });
//       this.dict = {};
//     };
//     TensorArrayMapBase.prototype.hasNullArray = function (tensor) {
//       if (this.dict[tensor.id] === undefined) {
//         throw new Error(`tensor ${  tensor.id  } not in array map.`);
//       }
//       return this.dict[tensor.id] === null;
//     };
//     return TensorArrayMapBase;
//   }());
//   exports.TensorArrayMapBase = TensorArrayMapBase;
//   const TensorArrayMap = (function (_super) {
//     __extends(TensorArrayMap, _super);
//     function TensorArrayMap() {
//       return _super !== null && _super.apply(this, arguments) || this;
//     }
//     TensorArrayMap.prototype.set = function (tensor, array) {
//       this.dict[tensor.id] = array;
//     };
//     return TensorArrayMap;
//   }(TensorArrayMapBase));
//   exports.TensorArrayMap = TensorArrayMap;
//   const SummedTensorArrayMap = (function (_super) {
//     __extends(SummedTensorArrayMap, _super);
//     function SummedTensorArrayMap(math) {
//       const _this = _super.call(this) || this;
//       _this.math = math;
//       return _this;
//     }
//     SummedTensorArrayMap.prototype.add = function (tensor, array) {
//       if (this.dict[tensor.id] == null) {
//         this.dict[tensor.id] = this.math.keep(array);
//       }
//       else {
//         const oldValue = this.get(tensor);
//         const newValue = this.math.keep(this.math.addStrict(oldValue, array));
//         this.dict[tensor.id] = newValue;
//         oldValue.dispose();
//       }
//     };
//     return SummedTensorArrayMap;
//   }(TensorArrayMapBase));
//   exports.SummedTensorArrayMap = SummedTensorArrayMap;
//
// }, {}], 42: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const session_1 = require(`./graph/session`);
//   const ndarray_1 = require(`./math/ndarray`);
//   const DEFAULT_EVAL_INTERVAL_MS = 1500;
//   const DEFAULT_COST_INTERVAL_MS = 500;
//   const DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS = 3000;
//   let MetricReduction;
//   (function (MetricReduction) {
//     MetricReduction[MetricReduction[`SUM`] = 0] = `SUM`;
//     MetricReduction[MetricReduction[`MEAN`] = 1] = `MEAN`;
//   })(MetricReduction = exports.MetricReduction || (exports.MetricReduction = {}));
//   const GraphRunner = (function () {
//     function GraphRunner(math, session, eventObserver) {
//       this.math = math;
//       this.session = session;
//       this.eventObserver = eventObserver;
//       this.lastCostTimestamp = 0;
//       this.lastEvalTimestamp = 0;
//       this.totalIdleTimeMs = 0;
//       this.resetStatistics();
//       this.zeroScalar = ndarray_1.Scalar.new(0);
//     }
//     GraphRunner.prototype.resetStatistics = function () {
//       this.totalBatchesTrained = 0;
//       this.totalIdleTimeMs = 0;
//       this.lastStopTimestamp = null;
//     };
//     GraphRunner.prototype.train = function (costTensor, trainFeedEntries, batchSize, optimizer, numBatches, metricTensor, metricFeedEntries, metricBatchSize, metricReduction, evalIntervalMs, costIntervalMs) {
//       if (metricReduction === void 0) { metricReduction = MetricReduction.MEAN; }
//       if (evalIntervalMs === void 0) { evalIntervalMs = DEFAULT_EVAL_INTERVAL_MS; }
//       if (costIntervalMs === void 0) { costIntervalMs = DEFAULT_COST_INTERVAL_MS; }
//       this.costTensor = costTensor;
//       this.trainFeedEntries = trainFeedEntries;
//       this.metricTensor = metricTensor;
//       this.metricFeedEntries = metricFeedEntries;
//       if (metricBatchSize != null && this.metricBatchSize !== metricBatchSize) {
//         if (this.metricBatchSizeScalar != null) {
//           this.metricBatchSizeScalar.dispose();
//         }
//         this.metricBatchSizeScalar = ndarray_1.Scalar.new(metricBatchSize);
//       }
//       this.metricBatchSize = metricBatchSize;
//       this.metricReduction = metricReduction;
//       this.batchSize = batchSize;
//       this.optimizer = optimizer;
//       this.metricIntervalMs = evalIntervalMs;
//       this.costIntervalMs = costIntervalMs;
//       this.currentTrainLoopNumBatches = numBatches;
//       this.batchesTrainedThisRun = 0;
//       this.isTraining = true;
//       this.trainStartTimestamp = performance.now();
//       this.trainNetwork();
//     };
//     GraphRunner.prototype.stopTraining = function () {
//       this.isTraining = false;
//       this.lastStopTimestamp = performance.now();
//     };
//     GraphRunner.prototype.resumeTraining = function () {
//       this.isTraining = true;
//       if (this.lastStopTimestamp != null) {
//         this.totalIdleTimeMs += performance.now() - this.lastStopTimestamp;
//       }
//       this.trainNetwork();
//     };
//     GraphRunner.prototype.trainNetwork = function () {
//       const _this = this;
//       if (this.batchesTrainedThisRun === this.currentTrainLoopNumBatches) {
//         this.stopTraining();
//       }
//       if (!this.isTraining) {
//         if (this.eventObserver.doneTrainingCallback != null) {
//           this.eventObserver.doneTrainingCallback();
//         }
//         return;
//       }
//       const start = performance.now();
//       const shouldComputeCost = this.eventObserver.avgCostCallback != null &&
//             (start - this.lastCostTimestamp > this.costIntervalMs);
//       if (shouldComputeCost) {
//         this.lastCostTimestamp = start;
//       }
//       const costReduction = shouldComputeCost ? session_1.CostReduction.MEAN : session_1.CostReduction.NONE;
//       this.math.scope(function (keep) {
//         const avgCost = _this.session.train(_this.costTensor, _this.trainFeedEntries, _this.batchSize, _this.optimizer, costReduction);
//         if (shouldComputeCost) {
//           const trainTime = performance.now() - start;
//           _this.eventObserver.avgCostCallback(avgCost);
//           if (_this.eventObserver.trainExamplesPerSecCallback != null) {
//             const examplesPerSec = (_this.batchSize * 1000 / trainTime);
//             _this.eventObserver.trainExamplesPerSecCallback(examplesPerSec);
//           }
//         }
//         if (_this.eventObserver.metricCallback != null &&
//                 _this.metricFeedEntries != null &&
//                 start - _this.lastEvalTimestamp > _this.metricIntervalMs) {
//           _this.lastEvalTimestamp = start;
//           if (_this.lastComputedMetric != null) {
//             _this.lastComputedMetric.dispose();
//           }
//           _this.lastComputedMetric = _this.computeMetric();
//           _this.eventObserver.metricCallback(_this.lastComputedMetric);
//         }
//         if (_this.eventObserver.totalTimeCallback != null) {
//           _this.eventObserver.totalTimeCallback((start - _this.trainStartTimestamp) / 1000);
//         }
//         _this.batchesTrainedThisRun++;
//         _this.totalBatchesTrained++;
//         if (_this.eventObserver.batchesTrainedCallback != null) {
//           _this.eventObserver.batchesTrainedCallback(_this.totalBatchesTrained);
//         }
//       });
//       requestAnimationFrame(function () { return _this.trainNetwork(); });
//     };
//     GraphRunner.prototype.infer = function (inferenceTensor, inferenceFeedEntries, inferenceExampleIntervalMs, inferenceExampleCount, numPasses) {
//       const _this = this;
//       if (inferenceExampleIntervalMs === void 0) { inferenceExampleIntervalMs = DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS; }
//       if (inferenceExampleCount === void 0) { inferenceExampleCount = 5; }
//       if (this.eventObserver.inferenceExamplesCallback == null &&
//             this.eventObserver.inferenceExamplesPerSecCallback == null) {
//         throw new Error(`Cannot start inference loop, no inference example or ` +
//                 `examples/sec observer provided.`);
//       }
//       for (let i = 0;i < inferenceFeedEntries.length;i ++) {
//         const feedEntry = inferenceFeedEntries[i];
//         if (feedEntry.data instanceof ndarray_1.NDArray) {
//           throw new Error(`Cannot start inference on the model runner with feed entries of ` +
//                     `type NDArray. Please use InputProviders.`);
//         }
//       }
//       this.inferenceExampleIntervalMs = inferenceExampleIntervalMs;
//       this.inferenceTensor = inferenceTensor;
//       this.inferenceFeedEntries = inferenceFeedEntries;
//       this.inferenceExampleCount = inferenceExampleCount;
//       this.currentInferenceLoopNumPasses = numPasses;
//       if (!this.isInferring) {
//         this.inferencePassesThisRun = 0;
//         requestAnimationFrame(function () { return _this.inferNetwork(); });
//       }
//       this.isInferring = true;
//     };
//     GraphRunner.prototype.inferNetwork = function () {
//       const _this = this;
//       if (!this.isInferring ||
//             this.inferencePassesThisRun === this.currentInferenceLoopNumPasses) {
//         return;
//       }
//       this.math.scope(function (keep, track) {
//         const feeds = [];
//         const inferenceValues = [];
//         const start = performance.now();
//         for (let i = 0;i < _this.inferenceExampleCount;i ++) {
//           const ndarrayFeedEntries = [];
//           for (let j = 0;j < _this.inferenceFeedEntries.length;j ++) {
//             const feedEntry = _this.inferenceFeedEntries[j];
//             const nextCopy = feedEntry.data.getNextCopy(_this.math);
//             ndarrayFeedEntries.push({tensor: feedEntry.tensor, data: track(nextCopy)});
//           }
//           feeds.push(ndarrayFeedEntries);
//           inferenceValues.push(_this.session.eval(_this.inferenceTensor, ndarrayFeedEntries));
//         }
//         if (_this.eventObserver.inferenceExamplesPerSecCallback != null) {
//           inferenceValues[inferenceValues.length - 1].getValues();
//           const inferenceExamplesPerSecTime = performance.now() - start;
//           const examplesPerSec = (_this.inferenceExampleCount * 1000 / inferenceExamplesPerSecTime);
//           _this.eventObserver.inferenceExamplesPerSecCallback(examplesPerSec);
//         }
//         if (_this.eventObserver.inferenceExamplesCallback != null) {
//           _this.eventObserver.inferenceExamplesCallback(feeds, inferenceValues);
//         }
//         _this.inferencePassesThisRun++;
//       });
//       this.lastInferTimeoutID = window.setTimeout(function () { return _this.inferNetwork(); }, this.inferenceExampleIntervalMs);
//     };
//     GraphRunner.prototype.stopInferring = function () {
//       this.isInferring = false;
//       window.clearTimeout(this.lastInferTimeoutID);
//     };
//     GraphRunner.prototype.isInferenceRunning = function () {
//       return this.isInferring;
//     };
//     GraphRunner.prototype.computeMetric = function () {
//       const _this = this;
//       if (this.metricFeedEntries == null) {
//         throw new Error(`Cannot compute metric, no metric FeedEntries provided.`);
//       }
//       let metric = this.zeroScalar;
//       return this.math.scope(function (keep) {
//         for (let i = 0;i < _this.metricBatchSize;i ++) {
//           const metricValue = _this.session.eval(_this.metricTensor, _this.metricFeedEntries);
//           metric = _this.math.add(metric, metricValue);
//         }
//         if (_this.metricReduction === MetricReduction.MEAN) {
//           metric = _this.math.divide(metric, _this.metricBatchSizeScalar);
//         }
//         return metric;
//       });
//     };
//     GraphRunner.prototype.getTotalBatchesTrained = function () {
//       return this.totalBatchesTrained;
//     };
//     GraphRunner.prototype.getLastComputedMetric = function () {
//       return this.lastComputedMetric;
//     };
//     GraphRunner.prototype.setMath = function (math) {
//       this.math = math;
//     };
//     GraphRunner.prototype.setSession = function (session) {
//       this.session = session;
//     };
//     GraphRunner.prototype.setInferenceTensor = function (inferenceTensor) {
//       this.inferenceTensor = inferenceTensor;
//     };
//     GraphRunner.prototype.setInferenceExampleCount = function (inferenceExampleCount) {
//       this.inferenceExampleCount = inferenceExampleCount;
//     };
//     return GraphRunner;
//   }());
//   exports.GraphRunner = GraphRunner;
//
// }, {"./graph/session": 39, "./math/ndarray": 55}], 43: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const xhr_dataset = require(`./data/xhr-dataset`);
//   exports.xhr_dataset = xhr_dataset;
//   const environment = require(`./environment`);
//   exports.environment = environment;
//   const conv_util = require(`./math/conv_util`);
//   exports.conv_util = conv_util;
//   const gpgpu_util = require(`./math/webgl/gpgpu_util`);
//   exports.gpgpu_util = gpgpu_util;
//   const render_ndarray_gpu_util = require(`./math/webgl/render_ndarray_gpu_util`);
//   exports.render_ndarray_gpu_util = render_ndarray_gpu_util;
//   const webgl_util = require(`./math/webgl/webgl_util`);
//   exports.webgl_util = webgl_util;
//   const test_util = require(`./test_util`);
//   exports.test_util = test_util;
//   const util = require(`./util`);
//   exports.util = util;
//   const version_1 = require(`./version`);
//   exports.version = version_1.version;
//   const checkpoint_loader_1 = require(`./data/checkpoint_loader`);
//   exports.CheckpointLoader = checkpoint_loader_1.CheckpointLoader;
//   const dataset_1 = require(`./data/dataset`);
//   exports.InMemoryDataset = dataset_1.InMemoryDataset;
//   const input_provider_1 = require(`./data/input_provider`);
//   exports.InCPUMemoryShuffledInputProviderBuilder = input_provider_1.InCPUMemoryShuffledInputProviderBuilder;
//   exports.InGPUMemoryShuffledInputProviderBuilder = input_provider_1.InGPUMemoryShuffledInputProviderBuilder;
//   const xhr_dataset_1 = require(`./data/xhr-dataset`);
//   exports.XhrDataset = xhr_dataset_1.XhrDataset;
//   const environment_1 = require(`./environment`);
//   exports.ENV = environment_1.ENV;
//   exports.Environment = environment_1.Environment;
//   const graph_1 = require(`./graph/graph`);
//   exports.Graph = graph_1.Graph;
//   exports.Tensor = graph_1.Tensor;
//   const adadelta_optimizer_1 = require(`./graph/optimizers/adadelta_optimizer`);
//   exports.AdadeltaOptimizer = adadelta_optimizer_1.AdadeltaOptimizer;
//   const adagrad_optimizer_1 = require(`./graph/optimizers/adagrad_optimizer`);
//   exports.AdagradOptimizer = adagrad_optimizer_1.AdagradOptimizer;
//   const adam_optimizer_1 = require(`./graph/optimizers/adam_optimizer`);
//   exports.AdamOptimizer = adam_optimizer_1.AdamOptimizer;
//   const adamax_optimizer_1 = require(`./graph/optimizers/adamax_optimizer`);
//   exports.AdamaxOptimizer = adamax_optimizer_1.AdamaxOptimizer;
//   const momentum_optimizer_1 = require(`./graph/optimizers/momentum_optimizer`);
//   exports.MomentumOptimizer = momentum_optimizer_1.MomentumOptimizer;
//   const optimizer_1 = require(`./graph/optimizers/optimizer`);
//   exports.Optimizer = optimizer_1.Optimizer;
//   const rmsprop_optimizer_1 = require(`./graph/optimizers/rmsprop_optimizer`);
//   exports.RMSPropOptimizer = rmsprop_optimizer_1.RMSPropOptimizer;
//   const sgd_optimizer_1 = require(`./graph/optimizers/sgd_optimizer`);
//   exports.SGDOptimizer = sgd_optimizer_1.SGDOptimizer;
//   const session_1 = require(`./graph/session`);
//   exports.CostReduction = session_1.CostReduction;
//   exports.Session = session_1.Session;
//   const graph_runner_1 = require(`./graph_runner`);
//   exports.GraphRunner = graph_runner_1.GraphRunner;
//   exports.MetricReduction = graph_runner_1.MetricReduction;
//   const initializers_1 = require(`./initializers`);
//   exports.ConstantInitializer = initializers_1.ConstantInitializer;
//   exports.NDArrayInitializer = initializers_1.NDArrayInitializer;
//   exports.OnesInitializer = initializers_1.OnesInitializer;
//   exports.RandomNormalInitializer = initializers_1.RandomNormalInitializer;
//   exports.RandomTruncatedNormalInitializer = initializers_1.RandomTruncatedNormalInitializer;
//   exports.RandomUniformInitializer = initializers_1.RandomUniformInitializer;
//   exports.VarianceScalingInitializer = initializers_1.VarianceScalingInitializer;
//   exports.ZerosInitializer = initializers_1.ZerosInitializer;
//   const math_1 = require(`./math/math`);
//   exports.MatrixOrientation = math_1.MatrixOrientation;
//   exports.NDArrayMath = math_1.NDArrayMath;
//   const math_cpu_1 = require(`./math/math_cpu`);
//   exports.NDArrayMathCPU = math_cpu_1.NDArrayMathCPU;
//   const math_gpu_1 = require(`./math/math_gpu`);
//   exports.NDArrayMathGPU = math_gpu_1.NDArrayMathGPU;
//   const ndarray_1 = require(`./math/ndarray`);
//   exports.initializeGPU = ndarray_1.initializeGPU;
//   const ndarray_2 = require(`./math/ndarray`);
//   exports.Array1D = ndarray_2.Array1D;
//   exports.Array2D = ndarray_2.Array2D;
//   exports.Array3D = ndarray_2.Array3D;
//   exports.Array4D = ndarray_2.Array4D;
//   exports.NDArray = ndarray_2.NDArray;
//   exports.Scalar = ndarray_2.Scalar;
//   const gpgpu_context_1 = require(`./math/webgl/gpgpu_context`);
//   exports.GPGPUContext = gpgpu_context_1.GPGPUContext;
//
// }, {"./data/checkpoint_loader": 2, "./data/dataset": 3, "./data/input_provider": 4, "./data/xhr-dataset": 5, "./environment": 7, "./graph/graph": 8, "./graph/optimizers/adadelta_optimizer": 30, "./graph/optimizers/adagrad_optimizer": 31, "./graph/optimizers/adam_optimizer": 32, "./graph/optimizers/adamax_optimizer": 33, "./graph/optimizers/momentum_optimizer": 34, "./graph/optimizers/optimizer": 35, "./graph/optimizers/rmsprop_optimizer": 36, "./graph/optimizers/sgd_optimizer": 37, "./graph/session": 39, "./graph_runner": 42, "./initializers": 44, "./math/conv_util": 49, "./math/math": 52, "./math/math_cpu": 53, "./math/math_gpu": 54, "./math/ndarray": 55, "./math/webgl/gpgpu_context": 68, "./math/webgl/gpgpu_util": 70, "./math/webgl/render_ndarray_gpu_util": 77, "./math/webgl/webgl_util": 86, "./test_util": 87, "./util": 88, "./version": 89}], 44: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`./math/ndarray`);
//   const VarianceScalingInitializer = (function () {
//     function VarianceScalingInitializer(scale, mode, distribution) {
//       if (scale === void 0) { scale = 1.0; }
//       if (mode === void 0) { mode = `fan_in`; }
//       if (distribution === void 0) { distribution = `normal`; }
//       this.scale = scale;
//       this.mode = mode;
//       this.distribution = distribution;
//     }
//     VarianceScalingInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
//       let n = 0;
//       if (this.mode === `fan_in`) {
//         n = inputUnits;
//       }
//       else if (this.mode === `fan_out`) {
//         n = outputUnits;
//       }
//       else if (this.mode === `fan_avg`) {
//         n = (inputUnits + outputUnits) / 2;
//       }
//       else {
//         throw new Error(`Unexpected mode for variance scaling initializer: ${  this.mode}`);
//       }
//       if (this.distribution === `normal`) {
//         return ndarray_1.NDArray.randTruncatedNormal(weightsShape, 0.0, Math.sqrt(this.scale / n));
//       }
//       else if (this.distribution === `uniform`) {
//         return ndarray_1.NDArray.randUniform(weightsShape, 0.0, Math.sqrt(3 * this.scale / n));
//       }
//       else {
//         throw new Error(`Unexpected distribution for variance scaling initializer: ` +
//                 `${  this.distribution}`);
//       }
//     };
//     return VarianceScalingInitializer;
//   }());
//   exports.VarianceScalingInitializer = VarianceScalingInitializer;
//   const ZerosInitializer = (function () {
//     function ZerosInitializer() {
//     }
//     ZerosInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
//       return ndarray_1.NDArray.zeros(weightsShape);
//     };
//     return ZerosInitializer;
//   }());
//   exports.ZerosInitializer = ZerosInitializer;
//   const OnesInitializer = (function () {
//     function OnesInitializer() {
//     }
//     OnesInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
//       const values = ndarray_1.NDArray.zeros(weightsShape);
//       values.fill(1);
//       return values;
//     };
//     return OnesInitializer;
//   }());
//   exports.OnesInitializer = OnesInitializer;
//   const ConstantInitializer = (function () {
//     function ConstantInitializer(value) {
//       if (value === void 0) { value = 0; }
//       this.value = value;
//     }
//     ConstantInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
//       const values = ndarray_1.NDArray.zeros(weightsShape);
//       values.fill(this.value);
//       return values;
//     };
//     return ConstantInitializer;
//   }());
//   exports.ConstantInitializer = ConstantInitializer;
//   const NDArrayInitializer = (function () {
//     function NDArrayInitializer(ndarray) {
//       this.ndarray = ndarray;
//     }
//     NDArrayInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
//       return this.ndarray;
//     };
//     return NDArrayInitializer;
//   }());
//   exports.NDArrayInitializer = NDArrayInitializer;
//   const RandomNormalInitializer = (function () {
//     function RandomNormalInitializer(mean, stdev) {
//       if (mean === void 0) { mean = 0; }
//       if (stdev === void 0) { stdev = .05; }
//       this.mean = mean;
//       this.stdev = stdev;
//     }
//     RandomNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
//       return ndarray_1.NDArray.randNormal(weightsShape, this.mean, this.stdev);
//     };
//     return RandomNormalInitializer;
//   }());
//   exports.RandomNormalInitializer = RandomNormalInitializer;
//   const RandomTruncatedNormalInitializer = (function () {
//     function RandomTruncatedNormalInitializer(mean, stdev) {
//       if (mean === void 0) { mean = 0; }
//       if (stdev === void 0) { stdev = .05; }
//       this.mean = mean;
//       this.stdev = stdev;
//     }
//     RandomTruncatedNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
//       return ndarray_1.NDArray.randTruncatedNormal(weightsShape, this.mean, this.stdev);
//     };
//     return RandomTruncatedNormalInitializer;
//   }());
//   exports.RandomTruncatedNormalInitializer = RandomTruncatedNormalInitializer;
//   const RandomUniformInitializer = (function () {
//     function RandomUniformInitializer(minval, maxval) {
//       if (minval === void 0) { minval = - .05; }
//       if (maxval === void 0) { maxval = .05; }
//       this.minval = minval;
//       this.maxval = maxval;
//     }
//     RandomUniformInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
//       return ndarray_1.NDArray.randUniform(weightsShape, this.minval, this.maxval);
//     };
//     return RandomUniformInitializer;
//   }());
//   exports.RandomUniformInitializer = RandomUniformInitializer;
//
// }, {"./math/ndarray": 55}], 45: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`./ndarray`);
//   const TanHFunc = (function () {
//     function TanHFunc() {
//     }
//     TanHFunc.prototype.output = function (math, x) {
//       return math.scope(function () {
//         return math.tanh(x);
//       });
//     };
//     TanHFunc.prototype.der = function (math, x, y) {
//       return math.scope(function () {
//         const ySquared = math.elementWiseMul(y, y);
//         return math.scalarMinusArray(ndarray_1.Scalar.ONE, ySquared);
//       });
//     };
//     TanHFunc.prototype.dispose = function () { };
//     return TanHFunc;
//   }());
//   exports.TanHFunc = TanHFunc;
//   const ReLUFunc = (function () {
//     function ReLUFunc() {
//     }
//     ReLUFunc.prototype.output = function (math, x) {
//       return math.scope(function () {
//         return math.relu(x);
//       });
//     };
//     ReLUFunc.prototype.der = function (math, x, y) {
//       return math.scope(function () {
//         return math.step(x);
//       });
//     };
//     ReLUFunc.prototype.dispose = function () { };
//     return ReLUFunc;
//   }());
//   exports.ReLUFunc = ReLUFunc;
//   const LeakyReluFunc = (function () {
//     function LeakyReluFunc(alpha) {
//       this.alpha = alpha;
//     }
//     LeakyReluFunc.prototype.output = function (math, x) {
//       return math.leakyRelu(x, this.alpha);
//     };
//     LeakyReluFunc.prototype.der = function (math, x, y) {
//       return math.step(x, this.alpha);
//     };
//     LeakyReluFunc.prototype.dispose = function () { };
//     return LeakyReluFunc;
//   }());
//   exports.LeakyReluFunc = LeakyReluFunc;
//   const SigmoidFunc = (function () {
//     function SigmoidFunc() {
//     }
//     SigmoidFunc.prototype.output = function (math, x) {
//       return math.scope(function () {
//         return math.sigmoid(x);
//       });
//     };
//     SigmoidFunc.prototype.der = function (math, x, y) {
//       return math.scope(function () {
//         const ySquared = math.elementWiseMul(y, y);
//         return math.subStrict(y, ySquared);
//       });
//     };
//     SigmoidFunc.prototype.dispose = function () { };
//     return SigmoidFunc;
//   }());
//   exports.SigmoidFunc = SigmoidFunc;
//   const SquareFunc = (function () {
//     function SquareFunc() {
//     }
//     SquareFunc.prototype.output = function (math, x) {
//       return math.scope(function () {
//         return math.elementWiseMul(x, x);
//       });
//     };
//     SquareFunc.prototype.der = function (math, x, y) {
//       return math.scope(function () {
//         return math.scalarTimesArray(ndarray_1.Scalar.TWO, x);
//       });
//     };
//     SquareFunc.prototype.dispose = function () { };
//     return SquareFunc;
//   }());
//   exports.SquareFunc = SquareFunc;
//
// }, {"./ndarray": 55}], 46: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   function axesAreInnerMostDims(axes, rank) {
//     for (let i = 0;i < axes.length;++ i) {
//       if (axes[axes.length - i - 1] !== rank - 1 - i) {
//         return false;
//       }
//     }
//     return true;
//   }
//   exports.axesAreInnerMostDims = axesAreInnerMostDims;
//   function combineLocations(outputLoc, reduceLoc, axes) {
//     const rank = outputLoc.length + reduceLoc.length;
//     const loc = [];
//     let outIdx = 0;
//     let reduceIdx = 0;
//     for (let dim = 0;dim < rank;dim ++) {
//       if (axes.indexOf(dim) === - 1) {
//         loc.push(outputLoc[outIdx ++]);
//       }
//       else {
//         loc.push(reduceLoc[reduceIdx ++]);
//       }
//     }
//     return loc;
//   }
//   exports.combineLocations = combineLocations;
//   function computeOutAndReduceShapes(aShape, axes) {
//     const outShape = [];
//     const rank = aShape.length;
//     for (let dim = 0;dim < rank;dim ++) {
//       if (axes.indexOf(dim) === - 1) {
//         outShape.push(aShape[dim]);
//       }
//     }
//     const reduceShape = axes.map(function (dim) { return aShape[dim]; });
//     return [outShape, reduceShape];
//   }
//   exports.computeOutAndReduceShapes = computeOutAndReduceShapes;
//   function expandShapeToKeepDim(shape, axes) {
//     const reduceSubShape = axes.map(function (x) { return 1; });
//     return combineLocations(shape, reduceSubShape, axes);
//   }
//   exports.expandShapeToKeepDim = expandShapeToKeepDim;
//   function parseAxisParam(axis, shape) {
//     if (axis == null) {
//       axis = shape.map(function (s, i) { return i; });
//     }
//     else if (typeof (axis) === `number`) {
//       axis = [axis];
//     }
//     return axis;
//   }
//   exports.parseAxisParam = parseAxisParam;
//   function assertAxesAreInnerMostDims(msg, axes, rank) {
//     if (!axesAreInnerMostDims(axes, rank)) {
//       throw new Error(`${msg  } supports only inner-most axes for now. ` +
//             `Got axes ${  axes  } and rank-${  rank  } input.`);
//     }
//   }
//   exports.assertAxesAreInnerMostDims = assertAxesAreInnerMostDims;
//   function getPermutedAxes(axes, rank) {
//     if (axesAreInnerMostDims(axes, rank)) {
//       return null;
//     }
//     const result = [];
//     for (let i = 0;i < rank;++ i) {
//       if (axes.indexOf(i) === - 1) {
//         result.push(i);
//       }
//     }
//     axes.forEach(function (axis) { return result.push(axis); });
//     return result;
//   }
//   exports.getPermutedAxes = getPermutedAxes;
//   function getInnerMostAxes(numAxes, rank) {
//     const res = [];
//     for (let i = rank - numAxes;i < rank;++ i) {
//       res.push(i);
//     }
//     return res;
//   }
//   exports.getInnerMostAxes = getInnerMostAxes;
//
// }, {}], 47: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   function getBroadcastDims(inShape, outShape) {
//     const inRank = inShape.length;
//     const dims = [];
//     for (let i = 0;i < inRank;i ++) {
//       const dim = inRank - 1 - i;
//       const a = inShape[dim] || 1;
//       const b = outShape[outShape.length - 1 - i] || 1;
//       if (b > 1 && a === 1) {
//         dims.unshift(dim);
//       }
//     }
//     return dims;
//   }
//   exports.getBroadcastDims = getBroadcastDims;
//   function broadcastDimsAreOuter(dims) {
//     for (let i = 0;i < dims.length;i ++) {
//       if (dims[i] !== i) {
//         return false;
//       }
//     }
//     return true;
//   }
//   exports.broadcastDimsAreOuter = broadcastDimsAreOuter;
//   function assertAndGetBroadcastShape(shapeA, shapeB) {
//     const result = [];
//     const errMsg = `Operands could not be broadcast together with shapes ${
//         shapeA  } and ${  shapeB  }.`;
//     const l = Math.max(shapeA.length, shapeB.length);
//     for (let i = 0;i < l;i ++) {
//       const a = shapeA[shapeA.length - i - 1] || 1;
//       const b = shapeB[shapeB.length - i - 1] || 1;
//       if (a > 1 && b > 1 && a !== b) {
//         throw Error(errMsg);
//       }
//       result.unshift(Math.max(a, b));
//     }
//     return result;
//   }
//   exports.assertAndGetBroadcastShape = assertAndGetBroadcastShape;
//
// }, {}], 48: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const util = require(`../util`);
//   function assertParams(aShape, bShape, axis) {
//     const aRank = aShape.length;
//     const bRank = bShape.length;
//     util.assert(aShape.length === bShape.length, `Error in concat${  aRank  }D: rank of x1 (${  aRank  }) and x2 (${  bRank  }) ` +
//         `must be the same.`);
//     util.assert(axis >= 0 && axis < aRank, `Error in concat${  aRank  }D: axis must be ` +
//         `between 0 and ${  aRank - 1  }.`);
//     for (let i = 0;i < aRank;i ++) {
//       util.assert((i === axis) || (aShape[i] === bShape[i]), `Error in concat${  aRank  }D: Shape (${  aShape  }) does not match ` +
//             `(${  bShape  }) along the non-concatenated axis ${  i  }.`);
//     }
//   }
//   exports.assertParams = assertParams;
//   function computeOutShape(x1Shape, x2Shape, axis) {
//     util.assert(x1Shape.length === x2Shape.length, `x1 and x2 should have the same rank.`);
//     const outputShape = x1Shape.slice();
//     outputShape[axis] += x2Shape[axis];
//     return outputShape;
//   }
//   exports.computeOutShape = computeOutShape;
//
// }, {"../util": 88}], 49: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const util = require(`../util`);
//   function computeDepthwiseConv2DInfo(inShape, filterShape, strides, pad) {
//     let filterHeight = filterShape[0], filterWidth = filterShape[1], inChannels = filterShape[2], channelMul = filterShape[3];
//     let _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
//     const inHeight = inShape[1];
//     const inWidth = inShape[2];
//     const batchSize = inShape[0];
//     let _b = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth), padInfo = _b.padInfo, outHeight = _b.outHeight, outWidth = _b.outWidth;
//     const outChannels = inChannels * channelMul;
//     const outShape = [batchSize, outHeight, outWidth, outChannels];
//     return {
//       inShape: inShape,
//       outShape: outShape,
//       channelMul: channelMul,
//       strideHeight: strideHeight,
//       strideWidth: strideWidth,
//       filterHeight: filterHeight,
//       filterWidth: filterWidth,
//       padInfo: padInfo
//     };
//   }
//   exports.computeDepthwiseConv2DInfo = computeDepthwiseConv2DInfo;
//   function computeConv2DInfo(inShape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad) {
//     const inHeight = inShape[0];
//     const inWidth = inShape[1];
//     let _a = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth), padInfo = _a.padInfo, outHeight = _a.outHeight, outWidth = _a.outWidth;
//     const outShape = [outHeight, outWidth, outDepth];
//     return {
//       inShape: inShape,
//       outShape: outShape,
//       padInfo: padInfo,
//       strideHeight: strideHeight,
//       strideWidth: strideWidth,
//       filterHeight: filterHeight,
//       filterWidth: filterWidth
//     };
//   }
//   exports.computeConv2DInfo = computeConv2DInfo;
//   function computeOutputShape3D(inShape, fieldSize, outDepth, stride, zeroPad) {
//     if (zeroPad == null) {
//       zeroPad = computeDefaultPad(inShape, fieldSize, stride);
//     }
//     const inputRows = inShape[0];
//     const inputCols = inShape[1];
//     const outputRows = (inputRows - fieldSize + 2 * zeroPad) / stride + 1;
//     util.assert(util.isInt(outputRows), `The output # of rows (${  outputRows  }) must be an integer. Change the ` +
//         `stride and/or zero pad parameters`);
//     const outputCols = (inputCols - fieldSize + 2 * zeroPad) / stride + 1;
//     util.assert(util.isInt(outputCols), `The output # of columns (${  outputCols  }) must be an integer. Change ` +
//         `the stride and/or zero pad parameters`);
//     return [outputRows, outputCols, outDepth];
//   }
//   exports.computeOutputShape3D = computeOutputShape3D;
//   function computeDefaultPad(inputShape, fieldSize, stride) {
//     return Math.floor((inputShape[0] * (stride - 1) - stride + fieldSize) / 2);
//   }
//   exports.computeDefaultPad = computeDefaultPad;
//   function computeWeightsShape4D(inputDepth, outputDepth, filterHeight, filterWidth) {
//     return [filterHeight, filterWidth, inputDepth, outputDepth];
//   }
//   exports.computeWeightsShape4D = computeWeightsShape4D;
//   function computeDilatedRC(rc, origStride) {
//     const rowsDilated = (rc[0] - 1) * origStride + 1;
//     const colsDilated = (rc[1] - 1) * origStride + 1;
//     return [rowsDilated, colsDilated];
//   }
//   exports.computeDilatedRC = computeDilatedRC;
//   function parseTupleParam(param) {
//     return typeof param === `number` ? [param, param] : param;
//   }
//   function getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth) {
//     let padInfo;
//     let outHeight;
//     let outWidth;
//     if (typeof pad === `number`) {
//       padInfo = {top: pad, bottom: pad, left: pad, right: pad};
//       const outShape = computeOutputShape3D([inHeight, inWidth, 1], filterHeight, 1, strideHeight, pad);
//       outHeight = outShape[0];
//       outWidth = outShape[1];
//     }
//     else if (pad === `same`) {
//       outHeight = Math.ceil(inHeight / strideHeight);
//       outWidth = Math.ceil(inWidth / strideWidth);
//       const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
//       const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
//       const top_1 = Math.floor(padAlongHeight / 2);
//       const bottom = padAlongHeight - top_1;
//       const left = Math.floor(padAlongWidth / 2);
//       const right = padAlongWidth - left;
//       padInfo = {top: top_1, bottom: bottom, left: left, right: right};
//     }
//     else if (pad === `valid`) {
//       padInfo = {top: 0, bottom: 0, left: 0, right: 0};
//       outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
//       outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
//     }
//     else {
//       throw Error(`Unknown padding parameter: ${  pad}`);
//     }
//     return {padInfo: padInfo, outHeight: outHeight, outWidth: outWidth};
//   }
//
// }, {"../util": 88}], 50: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   function validateShapes(sourceSize, destSize) {
//     const srcArea = sourceSize[0] * sourceSize[1];
//     const dstArea = destSize[0] * destSize[1];
//     if (srcArea !== dstArea) {
//       const srcStr = `[${  sourceSize[0]  }, ${  sourceSize[1]  }]`;
//       const dstStr = `[${  destSize[0]  }, ${  destSize[1]  }]`;
//       throw new Error(`copy2D shapes have different areas:\n  sourceSize ${  srcStr
//             }, area ${  srcArea  }\n  destSize ${  dstStr  }, area ${  dstArea}`);
//     }
//   }
//   exports.validateShapes = validateShapes;
//
// }, {}], 51: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ndarray_1 = require(`./ndarray`);
//   const SquareCostFunc = (function () {
//     function SquareCostFunc() {
//       this.halfOne = ndarray_1.Scalar.new(0.5);
//     }
//     SquareCostFunc.prototype.cost = function (math, x1, x2) {
//       const diff = math.subStrict(x1, x2);
//       const diffSquared = math.elementWiseMul(diff, diff);
//       const result = math.scalarTimesArray(this.halfOne, diffSquared);
//       diff.dispose();
//       diffSquared.dispose();
//       return result;
//     };
//     SquareCostFunc.prototype.der = function (math, x1, x2) {
//       return math.subStrict(x1, x2);
//     };
//     SquareCostFunc.prototype.dispose = function () {
//       this.halfOne.dispose();
//     };
//     return SquareCostFunc;
//   }());
//   exports.SquareCostFunc = SquareCostFunc;
//
// }, {"./ndarray": 55}], 52: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const util = require(`../util`);
//   const axis_util = require(`./axis_util`);
//   const broadcast_util = require(`./broadcast_util`);
//   const concat_util = require(`./concat_util`);
//   const conv_util = require(`./conv_util`);
//   const copy2d_util = require(`./copy2d_util`);
//   const ndarray_1 = require(`./ndarray`);
//   const slice_util = require(`./slice_util`);
//   let SumTypesMap;
//   (function (SumTypesMap) {
//     SumTypesMap[`float32`] = `float32`;
//     SumTypesMap[`int32`] = `int32`;
//     SumTypesMap[`bool`] = `int32`;
//   })(SumTypesMap = exports.SumTypesMap || (exports.SumTypesMap = {}));
//   const NDArrayMath = (function () {
//     function NDArrayMath(safeMode) {
//       this.safeMode = safeMode;
//       this.ndarrayScopes = [];
//       this.ndarraysToKeep = [];
//       this.activeScopeNDArraysToKeep = [];
//       this.debugMode = false;
//     }
//     NDArrayMath.prototype.scope = function (scopeFn) {
//       const _this = this;
//       this.startScope();
//       const keepFn = function (ndarray) { return _this.keep(ndarray); };
//       const trackFn = function (ndarray) { return _this.track(ndarray); };
//       const result = scopeFn(keepFn, trackFn);
//       if (result instanceof Promise) {
//         result.then(function (r) { return _this.endScope(r); });
//         return result;
//       }
//       else {
//         this.endScope(result);
//         return result;
//       }
//     };
//     NDArrayMath.prototype.enableDebugMode = function () {
//       this.debugMode = true;
//       console.warn(`Debugging mode is ON. The output of every math call will ` +
//             `be downloaded to CPU and checked for NaNs. ` +
//             `This significantly impacts performance.`);
//     };
//     NDArrayMath.prototype.startScope = function () {
//       const newScope = [];
//       this.ndarrayScopes.push(newScope);
//       this.activeScope = newScope;
//       const newNDArraysToKeep = [];
//       this.ndarraysToKeep.push(newNDArraysToKeep);
//       this.activeScopeNDArraysToKeep = newNDArraysToKeep;
//     };
//     NDArrayMath.prototype.extractNDArraysFromScopeResult = function (result) {
//       if (result == null) {
//         return [];
//       }
//       if (result instanceof ndarray_1.NDArray) {
//         return [result];
//       }
//       const list = [];
//       const resultObj = result;
//       for (const k in resultObj) {
//         const val = resultObj[k];
//         if (val instanceof ndarray_1.NDArray) {
//           list.push(val);
//         }
//       }
//       return list;
//     };
//     NDArrayMath.prototype.endScope = function (result) {
//       const _this = this;
//       let arraysToKeep = this.activeScopeNDArraysToKeep;
//       const resultArrays = this.extractNDArraysFromScopeResult(result);
//       arraysToKeep = arraysToKeep.concat(resultArrays);
//       for (let i = 0;i < this.activeScope.length;i ++) {
//         const ndarray = this.activeScope[i];
//         if (this.isNDArrayDataInList(ndarray, arraysToKeep)) {
//           continue;
//         }
//         ndarray.dispose();
//       }
//       this.ndarrayScopes.pop();
//       this.activeScope = this.ndarrayScopes.length === 0 ?
//             null :
//             this.ndarrayScopes[this.ndarrayScopes.length - 1];
//       resultArrays.forEach(function (val) {
//         if (!_this.isNDArrayDataInList(val, _this.activeScopeNDArraysToKeep)) {
//           _this.track(val);
//         }
//       });
//       this.ndarraysToKeep.pop();
//       this.activeScopeNDArraysToKeep = this.ndarraysToKeep.length === 0 ?
//             null :
//             this.ndarraysToKeep[this.ndarraysToKeep.length - 1];
//     };
//     NDArrayMath.prototype.isNDArrayDataInList = function (ndarray, ndarrayList) {
//       for (let i = 0;i < ndarrayList.length;i ++) {
//         if (ndarrayList[i].getData() === ndarray.getData()) {
//           return true;
//         }
//       }
//       return false;
//     };
//     NDArrayMath.prototype.keep = function (result) {
//       if (this.activeScope == null) {
//         if (this.safeMode) {
//           throw new Error(`You are using math in safe mode. Enclose all ` +
//                     `math.method() calls inside a scope: ` +
//                     `math.scope(() => {math.method();...}) to avoid memory ` +
//                     `leaks.`);
//         }
//         return result;
//       }
//       this.activeScopeNDArraysToKeep.push(result);
//       return result;
//     };
//     NDArrayMath.prototype.checkForNaN = function (vals, dtype, name) {
//       for (let i = 0;i < vals.length;i ++) {
//         if (util.isValNaN(vals[i], dtype)) {
//           throw Error(`The result of the last math.${  name  } has NaNs.`);
//         }
//       }
//     };
//     NDArrayMath.prototype.track = function (result) {
//       if (this.activeScope == null) {
//         if (this.safeMode) {
//           throw new Error(`You are using math in safe mode. Enclose all ` +
//                     `math.method() calls inside a scope: ` +
//                     `math.scope(() => {math.method();...}) to avoid memory ` +
//                     `leaks.`);
//         }
//         return result;
//       }
//       this.activeScope.push(result);
//       return result;
//     };
//     NDArrayMath.prototype.dispose = function () { };
//     NDArrayMath.prototype.matMul = function (a, b, aOrientation, bOrientation) {
//       const _this = this;
//       if (aOrientation === void 0) { aOrientation = MatrixOrientation.REGULAR; }
//       if (bOrientation === void 0) { bOrientation = MatrixOrientation.REGULAR; }
//       const innerShapeA = (aOrientation === MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
//       const innerShapeB = (bOrientation === MatrixOrientation.REGULAR) ? b.shape[0] : b.shape[1];
//       util.assert(a.rank === 2 && b.rank === 2, `Error in matMul: inputs must be rank 2, got ranks ${  a.rank
//             } and ${  b.rank  }.`);
//       util.assert(innerShapeA === innerShapeB, `Error in matMul: inner shapes (${  innerShapeA  }) and (${
//             innerShapeB  }) of NDArrays with shapes ${  a.shape  } and ${b.shape  } and orientations ${  MatrixOrientation[aOrientation]
//             } and ${  MatrixOrientation[bOrientation]  } must match.`);
//       return this.executeOp(`matMul`, function () { return _this.matMulInternal(a, b, aOrientation, bOrientation); });
//     };
//     NDArrayMath.prototype.executeOp = function (name, f) {
//       let start;
//       if (this.debugMode) {
//         start = performance.now();
//       }
//       const result = f();
//       if (this.debugMode) {
//         const vals = result.getValues();
//         const time = util.rightPad(`${performance.now() - start  }ms`, 9);
//         const paddedName = util.rightPad(name, 25);
//         const rank = result.rank;
//         const size = result.size;
//         const shape = util.rightPad(result.shape.toString(), 14);
//         console.log(`%c${  paddedName  }\t%c${  time  }\t%c${  rank  }D ${  shape  }\t%c${  size}`, `font-weight:bold`, `color:red`, `color:blue`, `color: orange`);
//         this.checkForNaN(vals, result.dtype, name);
//       }
//       return this.track(result);
//     };
//     NDArrayMath.prototype.vectorTimesMatrix = function (v, matrix) {
//       util.assert(v.rank === 1, `Error in vectorTimesMatrix: first input must be rank 1, but got ` +
//             `rank ${  v.rank  }.`);
//       util.assert(matrix.rank === 2, `Error in vectorTimesMatrix: second input must be rank 2, but got ` +
//             `rank ${  matrix.rank  }.`);
//       util.assert(v.size === matrix.shape[0], `Error in vectorTimesMatrix: size of vector (${  v.size  }) ` +
//             `must match first dimension of matrix (${  matrix.shape[0]  })`);
//       return this.matMul(v.as2D(1, - 1), matrix).as1D();
//     };
//     NDArrayMath.prototype.matrixTimesVector = function (matrix, v) {
//       util.assert(v.rank === 1, `Error in matrixTimesVector: second input must rank 1, but got ` +
//             `rank ${  v.rank  }.`);
//       util.assert(matrix.rank === 2, `Error in matrixTimesVector: first input must be a rank 2, but got ` +
//             `rank ${  matrix.rank  }.`);
//       util.assert(v.size === matrix.shape[1], `Error in matrixTimesVector: size of first rank 1 input ${  v.size  } ` +
//             `must match inner dimension of second rank 2 input, but got ` +
//             `shape ${  matrix.shape  }.`);
//       return this.matMul(matrix, v.as2D(- 1, 1)).as1D();
//     };
//     NDArrayMath.prototype.dotProduct = function (v1, v2) {
//       util.assert(v1.rank === 1 && v2.rank === 1, `Error in dotProduct: inputs must be rank 1, but got ranks ${
//             v1.rank  } and ${  v2.rank  }.`);
//       util.assert(v1.size === v2.size, `Error in dotProduct: size of inputs (${  v1.size  }) and (${
//             v2.size  }) must match.`);
//       return this.matMul(v1.as2D(1, - 1), v2.as2D(- 1, 1)).asScalar();
//     };
//     NDArrayMath.prototype.outerProduct = function (v1, v2) {
//       util.assert(v1.rank === 1 && v2.rank === 1, `Error in outerProduct: inputs must be rank 1, but got ranks ${
//             v1.rank  } and ${  v2.rank  }.`);
//       return this.matMul(v1.as2D(- 1, 1), v2.as2D(1, - 1));
//     };
//     NDArrayMath.prototype.clone = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`clone`, function () { return _this.cloneInternal(ndarray); });
//     };
//     NDArrayMath.prototype.reshape = function (ndarray, newShape) {
//       console.warn(`math.reshape() is deprecated. Please call reshape() ` +
//             `directly on the ndarray object`);
//       return ndarray.reshape(newShape);
//     };
//     NDArrayMath.prototype.slice1D = function (input, begin, size) {
//       const _this = this;
//       slice_util.assertParamsValid(input, [begin], [size]);
//       return this.executeOp(`slice1D`, function () { return _this.slice1DInternal(input, begin, size); });
//     };
//     NDArrayMath.prototype.slice2D = function (input, begin, size) {
//       const _this = this;
//       slice_util.assertParamsValid(input, begin, size);
//       return this.executeOp(`slice2D`, function () { return _this.slice2DInternal(input, begin, size); });
//     };
//     NDArrayMath.prototype.slice3D = function (input, begin, size) {
//       const _this = this;
//       slice_util.assertParamsValid(input, begin, size);
//       return this.executeOp(`slice3D`, function () { return _this.slice3DInternal(input, begin, size); });
//     };
//     NDArrayMath.prototype.slice4D = function (input, begin, size) {
//       const _this = this;
//       slice_util.assertParamsValid(input, begin, size);
//       return this.executeOp(`slice4D`, function () { return _this.slice4DInternal(input, begin, size); });
//     };
//     NDArrayMath.prototype.copy2D = function (source, sourceBegin, sourceSize, dest, destBegin, destSize) {
//       const _this = this;
//       util.assert(sourceBegin[0] + sourceSize[0] <= source.shape[0] &&
//             sourceBegin[1] + sourceSize[1] <= source.shape[1], `Error in copy2D: requested source start position ${  sourceBegin  } ` +
//             `and source size ${  sourceSize  } would overflow source NDArray` +
//             `of shape ${  source.shape  }.`);
//       util.assert(destBegin[0] + destSize[0] <= dest.shape[0] &&
//             destBegin[1] + destSize[1] <= dest.shape[1], `Error in copy2D: requested dest start position ${  destBegin  } ` +
//             `and source size ${  destSize  } would overflow dest NDArray of` +
//             `shape ${  dest.shape  }.`);
//       copy2d_util.validateShapes(sourceSize, destSize);
//       this.executeOp(`copy2D`, function () {
//         _this.copy2DInternal(source, sourceBegin, sourceSize, dest, destBegin, destSize);
//         return dest;
//       });
//     };
//     NDArrayMath.prototype.concat1D = function (a, b) {
//       const _this = this;
//       concat_util.assertParams(a.shape, b.shape, 0);
//       return this.executeOp(`concat1D`, function () { return _this.concat1DInternal(a, b); });
//     };
//     NDArrayMath.prototype.concat2D = function (a, b, axis) {
//       const _this = this;
//       concat_util.assertParams(a.shape, b.shape, axis);
//       return this.executeOp(`concat2D`, function () { return _this.concat2DInternal(a, b, axis); });
//     };
//     NDArrayMath.prototype.concat3D = function (ndarray1, ndarray2, axis) {
//       const _this = this;
//       concat_util.assertParams(ndarray1.shape, ndarray2.shape, axis);
//       return this.executeOp(`concat3D`, function () { return _this.concat3DInternal(ndarray1, ndarray2, axis); });
//     };
//     NDArrayMath.prototype.concat4D = function (ndarray1, ndarray2, axis) {
//       const _this = this;
//       concat_util.assertParams(ndarray1.shape, ndarray2.shape, axis);
//       return this.executeOp(`concat4D`, function () { return _this.concat4DInternal(ndarray1, ndarray2, axis); });
//     };
//     NDArrayMath.prototype.logSumExp = function (input, axis, keepDims) {
//       const _this = this;
//       if (axis === void 0) { axis = null; }
//       if (keepDims === void 0) { keepDims = false; }
//       const axes = axis_util.parseAxisParam(axis, input.shape);
//       return this.executeOp(`logSumExp`, function () {
//         const xMax = _this.max(input, axes, true);
//         const a = _this.subtract(input, xMax);
//         const b = _this.exp(a);
//         const c = _this.sum(b, axes);
//         const d = _this.log(c);
//         const res = _this.add(xMax.reshape(d.shape), d);
//         if (keepDims) {
//           const newShape = axis_util.expandShapeToKeepDim(res.shape, axes);
//           return res.reshape(newShape);
//         }
//         return res;
//       });
//     };
//     NDArrayMath.prototype.sum = function (input, axis, keepDims) {
//       const _this = this;
//       if (axis === void 0) { axis = null; }
//       if (keepDims === void 0) { keepDims = false; }
//       const origAxes = axis_util.parseAxisParam(axis, input.shape);
//       let axes = origAxes;
//       const permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
//       return this.executeOp(`sum`, function () {
//         if (permutedAxes != null) {
//           input = _this.transpose(input, permutedAxes);
//           axes = axis_util.getInnerMostAxes(axes.length, input.rank);
//         }
//         const res = _this.sumInternal(input, axes);
//         if (keepDims) {
//           const newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
//           return res.reshape(newShape);
//         }
//         return res;
//       });
//     };
//     NDArrayMath.prototype.mean = function (x, axis, keepDims) {
//       const _this = this;
//       if (axis === void 0) { axis = null; }
//       if (keepDims === void 0) { keepDims = false; }
//       const axes = axis_util.parseAxisParam(axis, x.shape);
//       const shapes = axis_util.computeOutAndReduceShapes(x.shape, axes);
//       const reduceShape = shapes[1];
//       const reduceSize = util.sizeFromShape(reduceShape);
//       return this.executeOp(`mean`, function () {
//         return _this.scope(function (keep, track) {
//           const res = _this.divide(x, track(ndarray_1.Scalar.new(reduceSize)));
//           return _this.sum(res, axis, keepDims);
//         });
//       });
//     };
//     NDArrayMath.prototype.argMin = function (input, axis) {
//       const _this = this;
//       if (axis === void 0) { axis = null; }
//       let axes = axis_util.parseAxisParam(axis, input.shape);
//       const permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
//       return this.executeOp(`argMin`, function () {
//         if (permutedAxes != null) {
//           input = _this.transpose(input, permutedAxes);
//           axes = axis_util.getInnerMostAxes(axes.length, input.rank);
//         }
//         return _this.argMinInternal(input, axes);
//       });
//     };
//     NDArrayMath.prototype.argMax = function (input, axis) {
//       const _this = this;
//       if (axis === void 0) { axis = null; }
//       let axes = axis_util.parseAxisParam(axis, input.shape);
//       const permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
//       return this.executeOp(`argMax`, function () {
//         if (permutedAxes != null) {
//           input = _this.transpose(input, permutedAxes);
//           axes = axis_util.getInnerMostAxes(axes.length, input.rank);
//         }
//         return _this.argMaxInternal(input, axes);
//       });
//     };
//     NDArrayMath.prototype.argMaxEquals = function (x1, x2) {
//       const _this = this;
//       util.assertShapesMatch(x1.shape, x2.shape, `Error in argMaxEquals: `);
//       return this.executeOp(`argMaxEquals`, function () { return _this.scope(function () {
//         return _this.equal(_this.argMax(x1), _this.argMax(x2));
//       }); });
//     };
//     NDArrayMath.prototype.equal = function (x, y) {
//       const _this = this;
//       return this.executeOp(`equal`, function () { return _this.equalInternal(x, y); });
//     };
//     NDArrayMath.prototype.equalStrict = function (x, y) {
//       util.assertShapesMatch(x.shape, y.shape, `Error in equalStrict: `);
//       return this.equal(x, y);
//     };
//     NDArrayMath.prototype.topK = function (ndarray, k) {
//       const _this = this;
//       util.assert(k <= ndarray.size, `Error in topK: k value (${  k  }) must be less than size of input ` +
//             `ndarray, got shape ${  ndarray.shape  }.`);
//       let result;
//       this.executeOp(`topK`, function () {
//         result = _this.topKInternal(ndarray, k);
//         return result.values;
//       });
//       this.track(result.indices);
//       return result;
//     };
//     NDArrayMath.prototype.min = function (input, axis, keepDims) {
//       const _this = this;
//       if (axis === void 0) { axis = null; }
//       if (keepDims === void 0) { keepDims = false; }
//       const origAxes = axis_util.parseAxisParam(axis, input.shape);
//       let axes = origAxes;
//       const permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
//       return this.executeOp(`min`, function () {
//         if (permutedAxes != null) {
//           input = _this.transpose(input, permutedAxes);
//           axes = axis_util.getInnerMostAxes(axes.length, input.rank);
//         }
//         const res = _this.minInternal(input, axes);
//         if (keepDims) {
//           const newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
//           return res.reshape(newShape);
//         }
//         return res;
//       });
//     };
//     NDArrayMath.prototype.max = function (input, axis, keepDims) {
//       const _this = this;
//       if (axis === void 0) { axis = null; }
//       if (keepDims === void 0) { keepDims = false; }
//       const origAxes = axis_util.parseAxisParam(axis, input.shape);
//       let axes = origAxes;
//       const permutedAxes = axis_util.getPermutedAxes(axes, input.rank);
//       return this.executeOp(`max`, function () {
//         if (permutedAxes != null) {
//           input = _this.transpose(input, permutedAxes);
//           axes = axis_util.getInnerMostAxes(axes.length, input.rank);
//         }
//         const res = _this.maxInternal(input, axes);
//         if (keepDims) {
//           const newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
//           return res.reshape(newShape);
//         }
//         return res;
//       });
//     };
//     NDArrayMath.prototype.softmax = function (logits, dim) {
//       const _this = this;
//       if (dim === void 0) { dim = - 1; }
//       if (dim === - 1) {
//         dim = logits.rank - 1;
//       }
//       if (dim !== logits.rank - 1) {
//         throw Error(`Softmax along a non-last dimension is not yet supported. ` +
//                 `Logits was rank ${  logits.rank  } and dim was ${  dim}`);
//       }
//       return this.executeOp(`softmax`, function () {
//         return _this.scope(function () {
//           const lse = _this.logSumExp(logits, [dim], true);
//           const logResult = _this.subtract(logits, lse);
//           return _this.exp(logResult);
//         });
//       });
//     };
//     NDArrayMath.prototype.switchDim = function (a, newDim) {
//       return this.transpose(a, newDim);
//     };
//     NDArrayMath.prototype.tile = function (a, reps) {
//       const _this = this;
//       util.assert(a.rank === reps.length, `Error in transpose: rank of input ${  a.rank  } ` +
//             `must match length of reps ${  reps  }.`);
//       return this.executeOp(`tile`, function () { return _this.tileInternal(a, reps); });
//     };
//     NDArrayMath.prototype.transpose = function (a, perm) {
//       const _this = this;
//       if (perm == null) {
//         perm = a.shape.map(function (s, i) { return i; }).reverse();
//       }
//       util.assert(a.rank === perm.length, `Error in transpose: rank of input ${  a.rank  } ` +
//             `must match length of perm ${  perm  }.`);
//       return this.executeOp(`transpose`, function () { return _this.transposeInternal(a, perm); });
//     };
//     NDArrayMath.prototype.scalarPlusArray = function (c, a) {
//       util.assert(c.size === 1, `Error in scalarPlusArray: first argument must be rank 0, but got ` +
//             `rank ${  c.rank  }.`);
//       return this.add(c, a);
//     };
//     NDArrayMath.prototype.scalarMinusArray = function (c, a) {
//       util.assert(c.size === 1, `Error in scalarMinusArray: first argument must be rank 0, but got ` +
//             `rank ${  c.rank  }.`);
//       return this.subtract(c, a);
//     };
//     NDArrayMath.prototype.arrayMinusScalar = function (a, c) {
//       util.assert(c.size === 1, `Error in arrayMinusScalar: second argument must be rank 0, but ` +
//             `got rank ${  c.rank  }.`);
//       return this.subtract(a, c);
//     };
//     NDArrayMath.prototype.neg = function (a) {
//       const _this = this;
//       return this.executeOp(`neg`, function () { return _this.negInternal(a); });
//     };
//     NDArrayMath.prototype.add = function (a, b) {
//       const _this = this;
//       broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
//       return this.executeOp(`add`, function () { return _this.addInternal(a, b); });
//     };
//     NDArrayMath.prototype.addStrict = function (a, b) {
//       util.assertShapesMatch(a.shape, b.shape, `Error in addStrict: `);
//       return this.add(a, b);
//     };
//     NDArrayMath.prototype.subtract = function (a, b) {
//       const _this = this;
//       broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
//       return this.executeOp(`subtract`, function () { return _this.subtractInternal(a, b); });
//     };
//     NDArrayMath.prototype.sub = function (a, b) {
//       return this.subtract(a, b);
//     };
//     NDArrayMath.prototype.subStrict = function (a, b) {
//       util.assertShapesMatch(a.shape, b.shape, `Error in subStrict: `);
//       return this.subtract(a, b);
//     };
//     NDArrayMath.prototype.multiply = function (a, b) {
//       const _this = this;
//       broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
//       return this.executeOp(`multiply`, function () { return _this.multiplyInternal(a, b); });
//     };
//     NDArrayMath.prototype.elementWiseMul = function (a, b) {
//       return this.multiplyStrict(a, b);
//     };
//     NDArrayMath.prototype.multiplyStrict = function (a, b) {
//       util.assertShapesMatch(a.shape, b.shape, `Error in multiplyStrict: `);
//       return this.multiply(a, b);
//     };
//     NDArrayMath.prototype.divide = function (a, b) {
//       const _this = this;
//       broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
//       return this.executeOp(`divide`, function () { return _this.divideInternal(a, b); });
//     };
//     NDArrayMath.prototype.divideStrict = function (a, b) {
//       util.assertShapesMatch(a.shape, b.shape, `Error in divideStrict: `);
//       return this.divide(a, b);
//     };
//     NDArrayMath.prototype.scalarDividedByArray = function (c, a) {
//       util.assert(c.size === 1, `Error in scalarDividedByArray: first argument must be rank 0, but ` +
//             `got NDArray of rank ${  c.rank  }.`);
//       return this.divide(c, a);
//     };
//     NDArrayMath.prototype.arrayDividedByScalar = function (a, c) {
//       util.assert(c.size === 1, `Error in arrayDividedByScalar: second argument must be rank 0, ` +
//             `but got NDArray of rank ${  c.rank  }.`);
//       return this.divide(a, c);
//     };
//     NDArrayMath.prototype.ceil = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`ceil`, function () { return _this.ceilInternal(ndarray); });
//     };
//     NDArrayMath.prototype.floor = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`floor`, function () { return _this.floorInternal(ndarray); });
//     };
//     NDArrayMath.prototype.exp = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`exp`, function () { return _this.expInternal(ndarray); });
//     };
//     NDArrayMath.prototype.log = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`log`, function () { return _this.logInternal(ndarray); });
//     };
//     NDArrayMath.prototype.sqrt = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`sqrt`, function () { return _this.sqrtInternal(ndarray); });
//     };
//     NDArrayMath.prototype.square = function (x) {
//       const _this = this;
//       return this.executeOp(`square`, function () { return _this.squareInternal(x); });
//     };
//     NDArrayMath.prototype.abs = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`abs`, function () { return _this.absInternal(ndarray); });
//     };
//     NDArrayMath.prototype.clip = function (ndarray, min, max) {
//       const _this = this;
//       util.assert((min <= max), `Error in clip: min (${  min  }) must be` +
//             `less than or equal to max (${  max  }).`);
//       return this.executeOp(`clip`, function () { return _this.clipInternal(ndarray, min, max); });
//     };
//     NDArrayMath.prototype.relu = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`relu`, function () { return _this.reluInternal(ndarray); });
//     };
//     NDArrayMath.prototype.elu = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`elu`, function () { return _this.eluInternal(ndarray); });
//     };
//     NDArrayMath.prototype.leakyRelu = function (ndarray, alpha) {
//       const _this = this;
//       if (alpha === void 0) { alpha = 0.2; }
//       return this.executeOp(`leakyRelu`, function () { return _this.leakyReluInternal(ndarray, alpha); });
//     };
//     NDArrayMath.prototype.sigmoid = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`sigmoid`, function () { return _this.sigmoidInternal(ndarray); });
//     };
//     NDArrayMath.prototype.sin = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`sin`, function () { return _this.sinInternal(ndarray); });
//     };
//     NDArrayMath.prototype.cos = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`cos`, function () { return _this.cosInternal(ndarray); });
//     };
//     NDArrayMath.prototype.tan = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`tan`, function () { return _this.tanInternal(ndarray); });
//     };
//     NDArrayMath.prototype.asin = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`asin`, function () { return _this.asinInternal(ndarray); });
//     };
//     NDArrayMath.prototype.acos = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`acos`, function () { return _this.acosInternal(ndarray); });
//     };
//     NDArrayMath.prototype.atan = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`atan`, function () { return _this.atanInternal(ndarray); });
//     };
//     NDArrayMath.prototype.sinh = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`sinh`, function () { return _this.sinhInternal(ndarray); });
//     };
//     NDArrayMath.prototype.cosh = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`cosh`, function () { return _this.coshInternal(ndarray); });
//     };
//     NDArrayMath.prototype.tanh = function (ndarray) {
//       const _this = this;
//       return this.executeOp(`tanh`, function () { return _this.tanhInternal(ndarray); });
//     };
//     NDArrayMath.prototype.step = function (ndarray, alpha) {
//       const _this = this;
//       if (alpha === void 0) { alpha = 0.0; }
//       return this.executeOp(`step`, function () { return _this.stepInternal(ndarray, alpha); });
//     };
//     NDArrayMath.prototype.scaledArrayAdd = function (c1, a, c2, b) {
//       const _this = this;
//       util.assert(c1.size === 1, `Error in scaledArrayAdd: first argument must rank 0, but got ` +
//             ` rank ${  c1.rank  }.`);
//       util.assert(c2.size === 1, `Error in scaledArrayAdd: third argument must be rank 0, but got ` +
//             `NDArray of rank ${  c2.rank  }.`);
//       util.assertShapesMatch(a.shape, b.shape, `Error in scaledArrayAdd: `);
//       return this.executeOp(`scaledArrayAdd`, function () { return _this.scaledArrayAddInternal(c1, a, c2, b); });
//     };
//     NDArrayMath.prototype.scalarTimesArray = function (c, a) {
//       util.assert(c.size === 1, `Error in arrayDividedByScalar: first argument must be rank 0, but ` +
//             `got rank ${  c.rank  }.`);
//       return this.multiply(c, a);
//     };
//     NDArrayMath.prototype.elementWiseMulBroadcast = function (a, b) {
//       util.assert(a.rank === 2, `Error in elementWiseMulBroadcast: first argument must be ` +
//             `rank 2, but got rank ${  a.rank  }.`);
//       util.assert(b.rank === 2, `Error in elementWiseMulBroadcast: second argument must be ` +
//             `rank 2, but got rank ${  b.rank  }.`);
//       return this.multiply(a, b);
//     };
//     NDArrayMath.prototype.conv2d = function (x, filter, bias, strides, pad) {
//       const _this = this;
//       util.assert(x.rank === 3, `Error in conv2d: x must be rank 3, but got rank ${  x.rank  }.`);
//       util.assert(filter.rank === 4, `Error in conv2d: filter must be rank 4, but got rank ${
//             filter.rank  }.`);
//       if (bias != null) {
//         util.assert(bias.rank === 1, `Error in conv2d: bias must be rank 1, but got rank ${
//                 bias.rank  }.`);
//       }
//       util.assert(x.shape[2] === filter.shape[2], `Error in conv2d: depth of input (${  x.shape[2]  }) must match  ` +
//             `input depth for filter ${  filter.shape[2]  }.`);
//       const filterHeight = filter.shape[0];
//       const filterWidth = filter.shape[1];
//       const outDepth = filter.shape[3];
//       let _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
//       const convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
//       return this.executeOp(`conv2d`, function () { return _this.conv2dInternal(x, filter, bias, convInfo); });
//     };
//     NDArrayMath.prototype.conv2dBackProp = function (x, dy, filter, strides, pad) {
//       const dw = this.conv2dDerFilter(x, dy, filter.shape, strides, pad);
//       const db = this.conv2dDerBias(dy);
//       const dx = this.conv2dDerInput(x.shape, dy, filter, strides, pad);
//       return {db: db, dw: dw, dx: dx};
//     };
//     NDArrayMath.prototype.conv2dDerInput = function (inShape, dy, filter, strides, pad) {
//       const _this = this;
//       const inDepth = inShape[2];
//       const outDepth = dy.shape[2];
//       util.assert(inShape.length === 3, `Error in conv2dDerInput: x must be rank 3, but got rank ${
//             inShape.length  }.`);
//       util.assert(dy.rank === 3, `Error in conv2dDerInput: dy must be rank 3, but got ` +
//             `rank ${  dy.rank}`);
//       util.assert(filter.rank === 4, `Error in conv2dDerInput: filter must be rank 4, but got ` +
//             `rank ${  filter.rank}`);
//       util.assert(inDepth === filter.shape[2], `Error in conv2dDerInput: depth of input (${  inDepth  }) must ` +
//             `match input depth for filter ${  filter.shape[2]  }.`);
//       util.assert(outDepth === filter.shape[3], `Error in conv2dDerInput: depth of output (${  outDepth  }) must` +
//             `match output depth for filter ${  filter.shape[3]  }.`);
//       const filterHeight = filter.shape[0];
//       const filterWidth = filter.shape[1];
//       let _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
//       const convInfo = conv_util.computeConv2DInfo(inShape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
//       return this.executeOp(`conv2dDerInput`, function () { return _this.conv2dDerInputInternal(dy, filter, convInfo); });
//     };
//     NDArrayMath.prototype.conv2dDerBias = function (dy) {
//       return this.track(this.conv2dDerBiasInternal(dy));
//     };
//     NDArrayMath.prototype.conv2dDerFilter = function (x, dy, filterSize, strides, pad) {
//       util.assert(x.rank === 3, `Error in conv2dDerFilter: x must be rank 3, but got shape ${
//             x.shape  }.`);
//       util.assert(dy.rank === 3, `Error in conv2dDerFilter: dy must be rank 3, but got shape ${
//             dy.shape  }.`);
//       util.assert(filterSize.length === 4, `Error in conv2dDerFilter: filterSize must be length 4, but got ${
//             filterSize  }.`);
//       util.assert(x.shape[2] === filterSize[2], `Error in conv2dDerFilter: depth of x ${  x.shape[2]  }) must ` +
//             `match input depth in filter (${  filterSize[2]  }.`);
//       util.assert(dy.shape[2] === filterSize[3], `Error in conv2dDerFilter: depth of dy (${  dy.shape[2]  }) must ` +
//             `match output depth for filter (${  filterSize[3]  }).`);
//       const filterHeight = filterSize[0];
//       const filterWidth = filterSize[1];
//       const outDepth = filterSize[3];
//       let _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];
//       const convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
//       return this.track(this.conv2dDerFilterInternal(x, dy, convInfo));
//     };
//     NDArrayMath.prototype.conv2dTranspose = function (x, filter, outputShape, strides, pad) {
//       return this.conv2dDerInput(outputShape, x, filter, strides, pad);
//     };
//     NDArrayMath.prototype.depthwiseConv2D = function (input, filter, strides, pad, rates) {
//       const _this = this;
//       if (rates === void 0) { rates = [1, 1]; }
//       let input4D = input;
//       let reshapedTo4D = false;
//       if (input.rank === 3) {
//         reshapedTo4D = true;
//         input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
//       }
//       util.assert(input4D.rank === 4, `Error in depthwiseConv2D: input must be rank 4, but got ` +
//             `rank ${  input4D.rank  }.`);
//       util.assert(filter.rank === 4, `Error in depthwiseConv2D: filter must be rank 4, but got rank ${
//             filter.rank  }.`);
//       util.assert(input4D.shape[3] === filter.shape[2], `Error in depthwiseConv2D: number of input channels ` +
//             `(${  input4D.shape[3]  }) must match the inChannels dimension in ` +
//             `filter ${  filter.shape[2]  }.`);
//       rates = rates || [1, 1];
//       let _a = parseTupleParam(rates), rateHeight = _a[0], rateWidth = _a[1];
//       util.assert(rateHeight === 1 && rateWidth === 1, `Error in depthwiseConv2D: rates greater than 1 are not yet ` +
//             `supported. Got rates '${  rates  }'`);
//       const convInfo = conv_util.computeDepthwiseConv2DInfo(input4D.shape, filter.shape, strides, pad);
//       return this.executeOp(`depthwiseConv2D`, function () {
//         const res = _this.depthwiseConv2DInternal(input4D, filter, convInfo);
//         if (reshapedTo4D) {
//           return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
//         }
//         return res;
//       });
//     };
//     NDArrayMath.prototype.maxPool = function (x, filterSize, strides, pad) {
//       const _this = this;
//       util.assert(x.rank === 3, `Error in maxPool: x must be rank 3 but got rank ${  x.rank  }.`);
//       let _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
//       const outDepth = x.shape[2];
//       let _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
//       const convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
//       return this.executeOp(`maxPool`, function () { return _this.maxPoolInternal(x, convInfo); });
//     };
//     NDArrayMath.prototype.maxPoolBackprop = function (dy, x, filterSize, strides, pad) {
//       const _this = this;
//       util.assert(dy.rank === 3, `Error in maxPoolBackprop: dy must be rank 3 but got rank ${
//             dy.rank  }.`);
//       util.assert(x.rank === 3, `Error in maxPoolBackprop: x must be rank 3 but got rank ${
//             x.rank  }.`);
//       let _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
//       const outDepth = x.shape[2];
//       let _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
//       const convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
//       return this.executeOp(`maxPoolBackprop`, function () { return _this.maxPoolBackpropInternal(dy, x, convInfo); });
//     };
//     NDArrayMath.prototype.minPool = function (x, filterSize, strides, pad) {
//       const _this = this;
//       util.assert(x.rank === 3, `Error in minPool: x must be rank 3 but got rank ${  x.rank  }.`);
//       let _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
//       const outDepth = x.shape[2];
//       let _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
//       const convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
//       return this.executeOp(`minPool`, function () { return _this.minPoolInternal(x, convInfo); });
//     };
//     NDArrayMath.prototype.avgPool = function (x, filterSize, strides, pad) {
//       const _this = this;
//       util.assert(x.rank === 3, `Error in avgPool: x must be rank 3 but got rank ${  x.rank  }.`);
//       let _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
//       const outDepth = x.shape[2];
//       let _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
//       const convInfo = conv_util.computeConv2DInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);
//       return this.executeOp(`avgPool`, function () { return _this.avgPoolInternal(x, convInfo); });
//     };
//     NDArrayMath.prototype.resizeBilinear3D = function (x, newShape2D, alignCorners) {
//       const _this = this;
//       if (alignCorners === void 0) { alignCorners = false; }
//       util.assert(x.rank === 3, `Error in resizeBilinear3D: x must be rank 3 but got rank ${  x.rank  }.`);
//       util.assert(newShape2D.length === 2, `Error in resizeBilinear3D: new shape must 2D, but got shape ${
//             newShape2D  }.`);
//       return this.executeOp(`resizeBilinear3D`, function () { return _this.resizeBilinear3DInternal(x, newShape2D, alignCorners); });
//     };
//     NDArrayMath.prototype.batchNormalization2D = function (x, mean, variance, varianceEpsilon, scale, offset) {
//       const _this = this;
//       if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
//       util.assert(x.rank === 2, `Error in batchNormalization3D: x must be rank 3 but got rank ${
//             x.rank  }.`);
//       util.assert(mean.rank === 2 || mean.rank === 1, `Error in batchNormalization2D: mean must be rank 2 or rank 1 but ` +
//             `got rank ${  mean.rank  }.`);
//       util.assert(variance.rank === 2 || variance.rank === 1, `Error in batchNormalization2D: variance must be rank 2 or rank 1 ` +
//             `but got rank ${  variance.rank  }.`);
//       if (scale != null) {
//         util.assert(scale.rank === 2 || scale.rank === 1, `Error in batchNormalization2D: scale must be rank 2 or rank 1 ` +
//                 `but got rank ${  scale.rank  }.`);
//       }
//       if (offset != null) {
//         util.assert(offset.rank === 2 || offset.rank === 1, `Error in batchNormalization2D: offset must be rank 2 or rank 1 ` +
//                 `but got rank ${  offset.rank  }.`);
//       }
//       return this.executeOp(`batchNorm2D`, function () { return _this.batchNormalization2DInternal(x, mean, variance, varianceEpsilon, scale, offset); });
//     };
//     NDArrayMath.prototype.batchNormalization3D = function (x, mean, variance, varianceEpsilon, scale, offset) {
//       const _this = this;
//       if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
//       util.assert(x.rank === 3, `Error in batchNormalization3D: x must be rank 3 but got rank ${
//             x.rank  }.`);
//       util.assert(mean.rank === 3 || mean.rank === 1, `Error in batchNormalization3D: mean must be rank 3 or rank 1 but ` +
//             `got rank ${  mean.rank  }.`);
//       util.assert(variance.rank === 3 || variance.rank === 1, `Error in batchNormalization3D: variance must be rank 3 or rank 1 ` +
//             `but got rank ${  variance.rank  }.`);
//       if (scale != null) {
//         util.assert(scale.rank === 3 || scale.rank === 1, `Error in batchNormalization3D: scale must be rank 3 or rank 1 ` +
//                 `but got rank ${  scale.rank  }.`);
//       }
//       if (offset != null) {
//         util.assert(offset.rank === 3 || offset.rank === 1, `Error in batchNormalization3D: offset must be rank 3 or rank 1 ` +
//                 `but got rank ${  offset.rank  }.`);
//       }
//       return this.executeOp(`batchNorm3D`, function () { return _this.batchNormalization3DInternal(x, mean, variance, varianceEpsilon, scale, offset); });
//     };
//     NDArrayMath.prototype.multiRNNCell = function (lstmCells, data, c, h) {
//       const res = this.scope(function () {
//         let input = data;
//         const newStates = [];
//         for (let i = 0;i < lstmCells.length;i ++) {
//           const output = lstmCells[i](input, c[i], h[i]);
//           newStates.push(output[0]);
//           newStates.push(output[1]);
//           input = output[1];
//         }
//         return newStates;
//       });
//       const newC = [];
//       const newH = [];
//       for (let i = 0;i < res.length;i += 2) {
//         newC.push(res[i]);
//         newH.push(res[i + 1]);
//       }
//       return [newC, newH];
//     };
//     NDArrayMath.prototype.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {
//       const _this = this;
//       const res = this.scope(function () {
//         const combined = _this.concat2D(data, h, 1);
//         const weighted = _this.matMul(combined, lstmKernel);
//         const res = _this.add(weighted, lstmBias);
//         const batchSize = res.shape[0];
//         const sliceCols = res.shape[1] / 4;
//         const sliceSize = [batchSize, sliceCols];
//         const i = _this.slice2D(res, [0, 0], sliceSize);
//         const j = _this.slice2D(res, [0, sliceCols], sliceSize);
//         const f = _this.slice2D(res, [0, sliceCols * 2], sliceSize);
//         const o = _this.slice2D(res, [0, sliceCols * 3], sliceSize);
//         const newC = _this.addStrict(_this.multiplyStrict(c, _this.sigmoid(_this.scalarPlusArray(forgetBias, f))), _this.multiplyStrict(_this.sigmoid(i), _this.tanh(j)));
//         const newH = _this.multiplyStrict(_this.tanh(newC), _this.sigmoid(o));
//         return [newC, newH];
//       });
//       return [res[0], res[1]];
//     };
//     NDArrayMath.prototype.multinomial = function (probabilities, numSamples, seed) {
//       const _this = this;
//       const numOutcomes = probabilities.size;
//       if (numOutcomes < 2) {
//         throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${
//                 numOutcomes  }.`);
//       }
//       if (probabilities.rank > 2) {
//         throw new Error(`Rank of probabilities must be 1 or 2, but is ${  probabilities.rank}`);
//       }
//       seed = seed || Math.random();
//       const origRank = probabilities.rank;
//       if (probabilities.rank === 1) {
//         probabilities = probabilities.as2D(1, - 1);
//       }
//       return this.executeOp(`multinomial`, function () {
//         const res = _this.multinomialInternal(probabilities, numSamples, seed);
//         if (origRank === 1) {
//           return res.as1D();
//         }
//         return res;
//       });
//     };
//     NDArrayMath.prototype.oneHot = function (indices, depth, onValue, offValue) {
//       const _this = this;
//       if (onValue === void 0) { onValue = 1; }
//       if (offValue === void 0) { offValue = 0; }
//       if (depth < 2) {
//         throw new Error(`Error in oneHot: depth must be >=2, but it is ${  depth}`);
//       }
//       return this.executeOp(`oneHot`, function () { return _this.oneHotInternal(indices, depth, onValue, offValue); });
//     };
//     NDArrayMath.prototype.moments = function (x, axis, keepDims) {
//       const _this = this;
//       if (axis === void 0) { axis = null; }
//       if (keepDims === void 0) { keepDims = false; }
//       const axes = axis_util.parseAxisParam(axis, x.shape);
//       const result = this.scope(function () {
//         const mean = _this.mean(x, axes, keepDims);
//         let keepDimsShape = mean.shape;
//         if (!keepDims) {
//           keepDimsShape = axis_util.expandShapeToKeepDim(mean.shape, axes);
//         }
//         const devSquared = _this.square(_this.subtract(x, mean.reshape(keepDimsShape)));
//         const variance = _this.mean(devSquared, axes, keepDims);
//         return {mean: mean, variance: variance};
//       });
//       return result;
//     };
//     return NDArrayMath;
//   }());
//   exports.NDArrayMath = NDArrayMath;
//   let MatrixOrientation;
//   (function (MatrixOrientation) {
//     MatrixOrientation[MatrixOrientation[`REGULAR`] = 0] = `REGULAR`;
//     MatrixOrientation[MatrixOrientation[`TRANSPOSED`] = 1] = `TRANSPOSED`;
//   })(MatrixOrientation = exports.MatrixOrientation || (exports.MatrixOrientation = {}));
//   function parseTupleParam(param) {
//     return typeof param === `number` ? [param, param] : param;
//   }
//
// }, {"../util": 88, "./axis_util": 46, "./broadcast_util": 47, "./concat_util": 48, "./conv_util": 49, "./copy2d_util": 50, "./ndarray": 55, "./slice_util": 57}], 53: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const seedrandom = require(`seedrandom`);
//   const util = require(`../util`);
//   const axis_util = require(`./axis_util`);
//   const broadcast_util = require(`./broadcast_util`);
//   const concat_util = require(`./concat_util`);
//   const conv_util = require(`./conv_util`);
//   const copy2D_util = require(`./copy2d_util`);
//   const math_1 = require(`./math`);
//   const ndarray_1 = require(`./ndarray`);
//   const NDArrayMathCPU = (function (_super) {
//     __extends(NDArrayMathCPU, _super);
//     function NDArrayMathCPU(safeMode) {
//       if (safeMode === void 0) { safeMode = false; }
//       return _super.call(this, safeMode) || this;
//     }
//     NDArrayMathCPU.prototype.cloneInternal = function (ndarray) {
//       return ndarray_1.NDArray.make(ndarray.shape, {values: new Float32Array(ndarray.getValues())});
//     };
//     NDArrayMathCPU.prototype.slice1DInternal = function (input, begin, size) {
//       const newVals = input.getValues().slice(begin, begin + size);
//       return ndarray_1.Array1D.new(newVals);
//     };
//     NDArrayMathCPU.prototype.slice2DInternal = function (input, begin, size) {
//       const result = ndarray_1.Array2D.zeros(size);
//       let startI = begin[0], startJ = begin[1];
//       for (let i = 0;i < size[0];++ i) {
//         for (let j = 0;j < size[1];++ j) {
//           const val = input.get(i + startI, j + startJ);
//           result.set(val, i, j);
//         }
//       }
//       return result;
//     };
//     NDArrayMathCPU.prototype.slice3DInternal = function (input, begin, size) {
//       const result = ndarray_1.Array3D.zeros(size);
//       let startI = begin[0], startJ = begin[1], startK = begin[2];
//       for (let i = 0;i < size[0];++ i) {
//         for (let j = 0;j < size[1];++ j) {
//           for (let k = 0;k < size[2];++ k) {
//             const val = input.get(i + startI, j + startJ, k + startK);
//             result.set(val, i, j, k);
//           }
//         }
//       }
//       return result;
//     };
//     NDArrayMathCPU.prototype.slice4DInternal = function (input, begin, size) {
//       const result = ndarray_1.Array4D.zeros(size);
//       let startI = begin[0], startJ = begin[1], startK = begin[2], startL = begin[3];
//       for (let i = 0;i < size[0];++ i) {
//         for (let j = 0;j < size[1];++ j) {
//           for (let k = 0;k < size[2];++ k) {
//             for (let l = 0;l < size[3];++ l) {
//               const val = input.get(i + startI, j + startJ, k + startK, l + startL);
//               result.set(val, i, j, k, l);
//             }
//           }
//         }
//       }
//       return result;
//     };
//     NDArrayMathCPU.prototype.copy2DInternal = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
//       copy2D_util.validateShapes(sourceSizeRowCol, destSizeRowCol);
//       const srcValues = source.getValues();
//       const dstValues = dest.getValues();
//       const n = sourceSizeRowCol[0] * sourceSizeRowCol[1];
//       for (let i = 0;i < n;++ i) {
//         const srcRow = sourceBeginRowCol[0] + Math.floor(i / sourceSizeRowCol[1]);
//         const srcCol = sourceBeginRowCol[1] + (i % sourceSizeRowCol[1]);
//         const srcOff = srcRow * source.shape[1] + srcCol;
//         const dstRow = destBeginRowCol[0] + Math.floor(i / destSizeRowCol[1]);
//         const dstCol = destBeginRowCol[1] + (i % destSizeRowCol[1]);
//         const dstOff = dstRow * dest.shape[1] + dstCol;
//         dstValues[dstOff] = srcValues[srcOff];
//       }
//     };
//     NDArrayMathCPU.prototype.concat1DInternal = function (a, b) {
//       const outShape = concat_util.computeOutShape(a.shape, b.shape, 0);
//       const result = ndarray_1.Array1D.zeros(outShape);
//       const aVals = a.getValues();
//       const bVals = b.getValues();
//       const vals = result.getValues();
//       vals.set(aVals, 0);
//       vals.set(bVals, a.size);
//       return result;
//     };
//     NDArrayMathCPU.prototype.concat2DInternal = function (a, b, axis) {
//       const outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
//       const result = ndarray_1.Array2D.zeros(outShape);
//       if (axis === 0) {
//         const aVals = a.getValues();
//         const bVals = b.getValues();
//         const vals = result.getValues();
//         vals.set(aVals, 0);
//         vals.set(bVals, a.size);
//         return result;
//       }
//       for (let i = 0;i < outShape[0];++ i) {
//         for (let j = 0;j < outShape[1];++ j) {
//           const index = [i, j];
//           let value = void 0;
//           if (index[axis] < a.shape[axis]) {
//             value = a.get(i, j);
//           }
//           else {
//             index[axis] -= a.shape[axis];
//             let i2 = index[0], j2 = index[1];
//             value = b.get(i2, j2);
//           }
//           result.set(value, i, j);
//         }
//       }
//       return result;
//     };
//     NDArrayMathCPU.prototype.concat3DInternal = function (a, b, axis) {
//       const outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
//       const result = ndarray_1.Array3D.zeros(outShape);
//       if (axis === 0) {
//         const aVals = a.getValues();
//         const bVals = b.getValues();
//         const vals = result.getValues();
//         vals.set(aVals, 0);
//         vals.set(bVals, a.size);
//         return result;
//       }
//       for (let i = 0;i < outShape[0];++ i) {
//         for (let j = 0;j < outShape[1];++ j) {
//           for (let k = 0;k < outShape[2];++ k) {
//             const index = [i, j, k];
//             let value = void 0;
//             if (index[axis] < a.shape[axis]) {
//               value = a.get(i, j, k);
//             }
//             else {
//               index[axis] -= a.shape[axis];
//               let i2 = index[0], j2 = index[1], k2 = index[2];
//               value = b.get(i2, j2, k2);
//             }
//             result.set(value, i, j, k);
//           }
//         }
//       }
//       return result;
//     };
//     NDArrayMathCPU.prototype.concat4DInternal = function (a, b, axis) {
//       const outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
//       const result = ndarray_1.Array4D.zeros(outShape);
//       if (axis === 0) {
//         const aVals = a.getValues();
//         const bVals = b.getValues();
//         const vals = result.getValues();
//         vals.set(aVals, 0);
//         vals.set(bVals, a.size);
//         return result;
//       }
//       for (let i = 0;i < outShape[0];++ i) {
//         for (let j = 0;j < outShape[1];++ j) {
//           for (let k = 0;k < outShape[2];++ k) {
//             for (let l = 0;l < outShape[3];++ l) {
//               const index = [i, j, k, l];
//               let value = void 0;
//               if (index[axis] < a.shape[axis]) {
//                 value = a.get(i, j, k, l);
//               }
//               else {
//                 index[axis] -= a.shape[axis];
//                 let i2 = index[0], j2 = index[1], k2 = index[2], l2 = index[3];
//                 value = b.get(i2, j2, k2, l2);
//               }
//               result.set(value, i, j, k, l);
//             }
//           }
//         }
//       }
//       return result;
//     };
//     NDArrayMathCPU.prototype.scaledArrayAddInternal = function (c1, a, c2, b) {
//       const c1Val = c1.get();
//       const c2Val = c2.get();
//       return this.broadcastedBinaryOp(a, b, `float32`, function (aVal, bVal) {
//         return c1Val * aVal + c2Val * bVal;
//       });
//     };
//     NDArrayMathCPU.prototype.negInternal = function (a) {
//       return this.scalarTimesArray(ndarray_1.Scalar.NEG_ONE, a);
//     };
//     NDArrayMathCPU.prototype.addInternal = function (a, b) {
//       return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE, a, ndarray_1.Scalar.ONE, b);
//     };
//     NDArrayMathCPU.prototype.subtractInternal = function (a, b) {
//       return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE, a, ndarray_1.Scalar.NEG_ONE, b);
//     };
//     NDArrayMathCPU.prototype.matMulInternal = function (a, b, aOrientation, bOrientation) {
//       if (aOrientation === void 0) { aOrientation = math_1.MatrixOrientation.REGULAR; }
//       if (bOrientation === void 0) { bOrientation = math_1.MatrixOrientation.REGULAR; }
//       const sharedDim = (aOrientation === math_1.MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
//       const leftDim = (aOrientation === math_1.MatrixOrientation.REGULAR) ? a.shape[0] : a.shape[1];
//       const rightDim = (bOrientation === math_1.MatrixOrientation.REGULAR) ? b.shape[1] : b.shape[0];
//       const normalGetter = function (matrix, i, j) {
//         return matrix.get(i, j);
//       };
//       const transposedGetter = function (matrix, i, j) {
//         return matrix.get(j, i);
//       };
//       const aGetter = (aOrientation === math_1.MatrixOrientation.REGULAR) ?
//             normalGetter :
//             transposedGetter;
//       const bGetter = (bOrientation === math_1.MatrixOrientation.REGULAR) ?
//             normalGetter :
//             transposedGetter;
//       const values = new Float32Array(leftDim * rightDim);
//       let index = 0;
//       for (let i = 0;i < leftDim;++ i) {
//         for (let j = 0;j < rightDim;++ j) {
//           let sum = 0;
//           for (let k = 0;k < sharedDim;++ k) {
//             sum += aGetter(a, i, k) * bGetter(b, k, j);
//           }
//           values[index ++] = sum;
//         }
//       }
//       return ndarray_1.Array2D.new([leftDim, rightDim], values);
//     };
//     NDArrayMathCPU.prototype.multiplyInternal = function (a, b) {
//       const newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
//       const newValues = new Float32Array(util.sizeFromShape(newShape));
//       const aValues = a.getValues();
//       const bValues = b.getValues();
//       for (let i = 0;i < newValues.length;++ i) {
//         newValues[i] = aValues[i % a.size] * bValues[i % b.size];
//       }
//       return ndarray_1.NDArray.make(newShape, {values: newValues});
//     };
//     NDArrayMathCPU.prototype.divideInternal = function (a, b) {
//       const newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
//       const newValues = new Float32Array(util.sizeFromShape(newShape));
//       const aValues = a.getValues();
//       const bValues = b.getValues();
//       for (let i = 0;i < newValues.length;++ i) {
//         newValues[i] = aValues[i % a.size] / bValues[i % b.size];
//       }
//       return ndarray_1.NDArray.make(newShape, {values: newValues}, `float32`);
//     };
//     NDArrayMathCPU.prototype.sumInternal = function (input, axes) {
//       axis_util.assertAxesAreInnerMostDims(`sum`, axes, input.rank);
//       let _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
//       const resultDtype = math_1.SumTypesMap[input.dtype];
//       const result = ndarray_1.NDArray.zeros(outShape, resultDtype);
//       const reduceSize = util.sizeFromShape(reduceShape);
//       const vals = result.getValues();
//       const aVals = input.getValues();
//       for (let i = 0;i < vals.length;++ i) {
//         const offset = i * reduceSize;
//         let sum = 0;
//         for (let j = 0;j < reduceSize;++ j) {
//           sum += aVals[offset + j];
//         }
//         vals[i] = sum;
//       }
//       return result;
//     };
//     NDArrayMathCPU.prototype.argMinInternal = function (input, axes) {
//       axis_util.assertAxesAreInnerMostDims(`argMin`, axes, input.rank);
//       let _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
//       const result = ndarray_1.NDArray.zeros(outShape, `int32`);
//       const reduceSize = util.sizeFromShape(reduceShape);
//       const vals = result.getValues();
//       const aVals = input.getValues();
//       for (let i = 0;i < vals.length;++ i) {
//         const offset = i * reduceSize;
//         let min = aVals[offset];
//         let minIndex = 0;
//         for (let j = 0;j < reduceSize;++ j) {
//           const value = aVals[offset + j];
//           if (isNaN(value)) {
//             minIndex = util.NAN_INT32;
//             break;
//           }
//           if (value < min) {
//             min = value;
//             minIndex = j;
//           }
//         }
//         vals[i] = minIndex;
//       }
//       return result;
//     };
//     NDArrayMathCPU.prototype.argMaxInternal = function (input, axes) {
//       axis_util.assertAxesAreInnerMostDims(`argMax`, axes, input.rank);
//       let _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
//       const result = ndarray_1.NDArray.zeros(outShape, `int32`);
//       const reduceSize = util.sizeFromShape(reduceShape);
//       const vals = result.getValues();
//       const aVals = input.getValues();
//       for (let i = 0;i < vals.length;++ i) {
//         const offset = i * reduceSize;
//         let max = aVals[offset];
//         let maxIndex = 0;
//         for (let j = 0;j < reduceSize;++ j) {
//           const value = aVals[offset + j];
//           if (isNaN(value)) {
//             maxIndex = util.NAN_INT32;
//             break;
//           }
//           if (value > max) {
//             max = value;
//             maxIndex = j;
//           }
//         }
//         vals[i] = maxIndex;
//       }
//       return result;
//     };
//     NDArrayMathCPU.prototype.equalInternal = function (a, b) {
//       return this.broadcastedBinaryOp(a, b, `bool`, function (aVal, bVal) {
//         if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
//           return util.getNaN(`bool`);
//         }
//         else {
//           return (aVal === bVal) ? 1 : 0;
//         }
//       });
//     };
//     NDArrayMathCPU.prototype.topKInternal = function (ndarray, k) {
//       const values = ndarray.getValues();
//       const valuesAndIndices = [];
//       for (var i = 0;i < values.length;i ++) {
//         valuesAndIndices.push({value: values[i], index: i});
//       }
//       valuesAndIndices.sort(function (a, b) {
//         return b.value - a.value;
//       });
//       const topkValues = new Float32Array(k);
//       const topkIndices = new Float32Array(k);
//       for (var i = 0;i < k;i ++) {
//         topkValues[i] = valuesAndIndices[i].value;
//         topkIndices[i] = valuesAndIndices[i].index;
//       }
//       return {values: ndarray_1.Array1D.new(topkValues), indices: ndarray_1.Array1D.new(topkIndices)};
//     };
//     NDArrayMathCPU.prototype.minInternal = function (input, axes) {
//       axis_util.assertAxesAreInnerMostDims(`min`, axes, input.rank);
//       let _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
//       const result = ndarray_1.NDArray.zeros(outShape, input.dtype);
//       const reduceSize = util.sizeFromShape(reduceShape);
//       const vals = result.getValues();
//       const aVals = input.getValues();
//       for (let i = 0;i < vals.length;++ i) {
//         const offset = i * reduceSize;
//         let min = aVals[0];
//         for (let j = 0;j < reduceSize;++ j) {
//           const value = aVals[offset + j];
//           if (isNaN(value)) {
//             min = Number.NaN;
//             break;
//           }
//           if (value < min) {
//             min = value;
//           }
//         }
//         vals[i] = min;
//       }
//       return result;
//     };
//     NDArrayMathCPU.prototype.maxInternal = function (input, axes) {
//       axis_util.assertAxesAreInnerMostDims(`max`, axes, input.rank);
//       let _a = axis_util.computeOutAndReduceShapes(input.shape, axes), outShape = _a[0], reduceShape = _a[1];
//       const result = ndarray_1.NDArray.zeros(outShape, input.dtype);
//       const reduceSize = util.sizeFromShape(reduceShape);
//       const vals = result.getValues();
//       const aVals = input.getValues();
//       for (let i = 0;i < vals.length;++ i) {
//         const offset = i * reduceSize;
//         let max = aVals[offset];
//         for (let j = 0;j < reduceSize;++ j) {
//           const value = aVals[offset + j];
//           if (isNaN(value)) {
//             max = Number.NaN;
//             break;
//           }
//           if (value > max) {
//             max = value;
//           }
//         }
//         vals[i] = max;
//       }
//       return result;
//     };
//     NDArrayMathCPU.prototype.ceilInternal = function (ndarray) {
//       const values = ndarray.getValues();
//       const newValues = new Float32Array(values.length);
//       for (let i = 0;i < values.length;++ i) {
//         newValues[i] = Math.ceil(values[i]);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: newValues});
//     };
//     NDArrayMathCPU.prototype.floorInternal = function (ndarray) {
//       const values = ndarray.getValues();
//       const newValues = new Float32Array(values.length);
//       for (let i = 0;i < values.length;++ i) {
//         newValues[i] = Math.floor(values[i]);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: newValues});
//     };
//     NDArrayMathCPU.prototype.expInternal = function (ndarray) {
//       const values = ndarray.getValues();
//       const newValues = new Float32Array(values.length);
//       for (let i = 0;i < values.length;++ i) {
//         newValues[i] = Math.exp(values[i]);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: newValues});
//     };
//     NDArrayMathCPU.prototype.logInternal = function (ndarray) {
//       const values = ndarray.getValues();
//       const newValues = new Float32Array(values.length);
//       for (let i = 0;i < values.length;++ i) {
//         const value = values[i];
//         newValues[i] = Math.log(value);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: newValues});
//     };
//     NDArrayMathCPU.prototype.sqrtInternal = function (ndarray) {
//       const values = ndarray.getValues();
//       const newValues = new Float32Array(values.length);
//       for (let i = 0;i < values.length;++ i) {
//         const value = values[i];
//         newValues[i] = Math.sqrt(value);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: newValues});
//     };
//     NDArrayMathCPU.prototype.squareInternal = function (x) {
//       const values = x.getValues();
//       const newValues = new Float32Array(values.length);
//       for (let i = 0;i < values.length;++ i) {
//         const value = values[i];
//         newValues[i] = value * value;
//       }
//       return ndarray_1.NDArray.make(x.shape, {values: newValues});
//     };
//     NDArrayMathCPU.prototype.reluInternal = function (input) {
//       const res = ndarray_1.NDArray.zeros(input.shape, input.dtype);
//       const resVals = res.getValues();
//       const inVals = input.getValues();
//       for (let i = 0;i < inVals.length;++ i) {
//         const val = inVals[i];
//         if (util.isValNaN(val, input.dtype)) {
//           resVals[i] = util.getNaN(res.dtype);
//         }
//         else {
//           resVals[i] = Math.max(0, inVals[i]);
//         }
//       }
//       return res;
//     };
//     NDArrayMathCPU.prototype.eluInternal = function (ndarray) {
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.dataSync();
//       for (let i = 0;i < values.length;++ i) {
//         const v = values[i];
//         if (v >= 0) {
//           resultValues[i] = v;
//         }
//         else {
//           resultValues[i] = (Math.exp(v) - 1);
//         }
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.leakyReluInternal = function (ndarray, alpha) {
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.dataSync();
//       for (let i = 0;i < values.length;i ++) {
//         const v = values[i];
//         if (v >= 0) {
//           resultValues[i] = v;
//         }
//         else {
//           resultValues[i] = alpha * v;
//         }
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.clipInternal = function (ndarray, min, max) {
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.getValues();
//       for (let i = 0;i < values.length;++ i) {
//         resultValues[i] = Math.min(max, Math.max(min, values[i]));
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.absInternal = function (ndarray) {
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.getValues();
//       for (let i = 0;i < values.length;++ i) {
//         resultValues[i] = Math.abs(values[i]);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.sigmoidInternal = function (ndarray) {
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.getValues();
//       for (let i = 0;i < values.length;++ i) {
//         resultValues[i] = 1 / (1 + Math.exp(- values[i]));
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.sinInternal = function (ndarray) {
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.getValues();
//       for (let i = 0;i < values.length;++ i) {
//         resultValues[i] = Math.sin(values[i]);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.cosInternal = function (ndarray) {
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.getValues();
//       for (let i = 0;i < values.length;++ i) {
//         resultValues[i] = Math.cos(values[i]);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.tanInternal = function (ndarray) {
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.getValues();
//       for (let i = 0;i < values.length;++ i) {
//         resultValues[i] = Math.tan(values[i]);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.asinInternal = function (ndarray) {
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.getValues();
//       for (let i = 0;i < values.length;++ i) {
//         resultValues[i] = Math.asin(values[i]);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.acosInternal = function (ndarray) {
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.getValues();
//       for (let i = 0;i < values.length;++ i) {
//         resultValues[i] = Math.acos(values[i]);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.atanInternal = function (ndarray) {
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.getValues();
//       for (let i = 0;i < values.length;++ i) {
//         resultValues[i] = Math.atan(values[i]);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.sinhInternal = function (ndarray) {
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.getValues();
//       for (let i = 0;i < values.length;++ i) {
//         resultValues[i] = Math.sinh(values[i]);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.coshInternal = function (ndarray) {
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.getValues();
//       for (let i = 0;i < values.length;++ i) {
//         resultValues[i] = Math.cosh(values[i]);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.tanhInternal = function (ndarray) {
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.getValues();
//       for (let i = 0;i < values.length;++ i) {
//         resultValues[i] = util.tanh(values[i]);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.stepInternal = function (ndarray, alpha) {
//       if (alpha === void 0) { alpha = 0; }
//       const resultValues = new Float32Array(ndarray.size);
//       const values = ndarray.getValues();
//       for (let i = 0;i < values.length;++ i) {
//         const value = values[i];
//         resultValues[i] = value > 0 ? 1 : (value < 0 ? alpha : value);
//       }
//       return ndarray_1.NDArray.make(ndarray.shape, {values: resultValues});
//     };
//     NDArrayMathCPU.prototype.conv2dInternal = function (x, filter, bias, convInfo) {
//       let _a = x.shape, xRows = _a[0], xCols = _a[1], inputDepth = _a[2];
//       const filterHeight = filter.shape[0];
//       const filterWidth = filter.shape[1];
//       const outDepth = filter.shape[3];
//       const padLeft = convInfo.padInfo.left;
//       const padTop = convInfo.padInfo.top;
//       const y = ndarray_1.Array3D.zeros(convInfo.outShape);
//       for (let d2 = 0;d2 < outDepth;++ d2) {
//         for (let yR = 0;yR < y.shape[0];++ yR) {
//           const xRCorner = yR * convInfo.strideHeight - padLeft;
//           const xRMin = Math.max(0, xRCorner);
//           const xRMax = Math.min(xRows, filterHeight + xRCorner);
//           for (let yC = 0;yC < y.shape[1];++ yC) {
//             const xCCorner = yC * convInfo.strideWidth - padTop;
//             const xCMin = Math.max(0, xCCorner);
//             const xCMax = Math.min(xCols, filterWidth + xCCorner);
//             let dotProd = 0;
//             for (let xR = xRMin;xR < xRMax;++ xR) {
//               const wR = xR - xRCorner;
//               for (let xC = xCMin;xC < xCMax;++ xC) {
//                 const wC = xC - xCCorner;
//                 for (let d1 = 0;d1 < inputDepth;++ d1) {
//                   const pixel = x.get(xR, xC, d1);
//                   const weight = filter.get(wR, wC, d1, d2);
//                   dotProd += pixel * weight;
//                 }
//               }
//             }
//             const biasVal = (bias != null) ? bias.get(d2) : 0;
//             y.set(dotProd + biasVal, yR, yC, d2);
//           }
//         }
//       }
//       return y;
//     };
//     NDArrayMathCPU.prototype.conv2dDerInputInternal = function (dy, filter, convInfo) {
//       const inDepth = filter.shape[2];
//       const outDepth = filter.shape[3];
//       const yRows = dy.shape[0];
//       const yCols = dy.shape[1];
//       const filterHeight = filter.shape[0];
//       const filterWidth = filter.shape[1];
//       const topPad = filterHeight - 1 - convInfo.padInfo.top;
//       const leftPad = filterWidth - 1 - convInfo.padInfo.left;
//       const strideHeight = convInfo.strideHeight;
//       const strideWidth = convInfo.strideWidth;
//       const dx = ndarray_1.Array3D.zeros(convInfo.inShape);
//       for (let d1 = 0;d1 < inDepth;++ d1) {
//         for (let xR = 0;xR < dx.shape[0];++ xR) {
//           const xRCorner = xR - leftPad;
//           const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
//           const yRMax = Math.min(yRows, (filterHeight + xRCorner) / strideHeight);
//           for (let xC = 0;xC < dx.shape[1];++ xC) {
//             const xCCorner = xC - topPad;
//             const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
//             const yCMax = Math.min(yCols, (filterWidth + xCCorner) / strideWidth);
//             let dotProd = 0;
//             for (let yR = xRMin;yR < yRMax;++ yR) {
//               const wR = yR * strideHeight - xRCorner;
//               for (let yC = xCMin;yC < yCMax;++ yC) {
//                 const wC = yC * strideWidth - xCCorner;
//                 for (let d2 = 0;d2 < outDepth;++ d2) {
//                   const pixel = dy.get(yR, yC, d2);
//                   const weight = filter.get(filterHeight - 1 - wR, filterWidth - 1 - wC, d1, d2);
//                   dotProd += pixel * weight;
//                 }
//               }
//             }
//             dx.set(dotProd, xR, xC, d1);
//           }
//         }
//       }
//       return dx;
//     };
//     NDArrayMathCPU.prototype.conv2dDerFilterInternal = function (x, dY, convInfo) {
//       const inputDepth = x.shape[2];
//       const outputDepth = dY.shape[2];
//       const strideHeight = convInfo.strideHeight;
//       const strideWidth = convInfo.strideWidth;
//       const filterHeight = convInfo.filterHeight;
//       const filterWidth = convInfo.filterWidth;
//       const weightsShape = conv_util.computeWeightsShape4D(inputDepth, outputDepth, filterHeight, filterWidth);
//       const dW = ndarray_1.Array4D.zeros(weightsShape);
//       const yNumRows = dY.shape[0];
//       const yNumCols = dY.shape[1];
//       const xNumRows = x.shape[0];
//       const xNumCols = x.shape[1];
//       const leftPad = convInfo.padInfo.left;
//       const topPad = convInfo.padInfo.top;
//       for (let wR = 0;wR < filterHeight;++ wR) {
//         const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
//         const yRMax = Math.min(yNumRows, (xNumRows + topPad - wR) / strideHeight);
//         for (let wC = 0;wC < filterWidth;++ wC) {
//           const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
//           const yCMax = Math.min(yNumCols, (xNumCols + leftPad - wC) / strideWidth);
//           for (let d1 = 0;d1 < inputDepth;++ d1) {
//             for (let d2 = 0;d2 < outputDepth;++ d2) {
//               let dotProd = 0;
//               for (let yR = yRMin;yR < yRMax;++ yR) {
//                 const xR = wR + yR * strideHeight - topPad;
//                 for (let yC = yCMin;yC < yCMax;++ yC) {
//                   const xC = wC + yC * strideWidth - leftPad;
//                   dotProd += x.get(xR, xC, d1) * dY.get(yR, yC, d2);
//                 }
//               }
//               dW.set(dotProd, wR, wC, d1, d2);
//             }
//           }
//         }
//       }
//       return dW;
//     };
//     NDArrayMathCPU.prototype.conv2dDerBiasInternal = function (dY) {
//       const outputDepth = dY.shape[2];
//       const numRows = dY.shape[0];
//       const numCols = dY.shape[1];
//       const values = new Float32Array(outputDepth);
//       for (let d2 = 0;d2 < outputDepth;++ d2) {
//         let sum = 0;
//         for (let r = 0;r < numRows;++ r) {
//           for (let c = 0;c < numCols;++ c) {
//             sum += dY.get(r, c, d2);
//           }
//         }
//         values[d2] = sum;
//       }
//       return ndarray_1.Array1D.new(values);
//     };
//     NDArrayMathCPU.prototype.depthwiseConv2DInternal = function (input, filter, convInfo) {
//       let _a = convInfo.inShape, numBatches = _a[0], xRows = _a[1], xCols = _a[2], inChannels = _a[3];
//       const filterHeight = convInfo.filterHeight;
//       const filterWidth = convInfo.filterWidth;
//       const padLeft = convInfo.padInfo.left;
//       const padTop = convInfo.padInfo.top;
//       const yRows = convInfo.outShape[1];
//       const yCols = convInfo.outShape[2];
//       const chMul = convInfo.channelMul;
//       const y = ndarray_1.Array4D.zeros(convInfo.outShape);
//       for (let b = 0;b < numBatches;++ b) {
//         for (let d1 = 0;d1 < inChannels;++ d1) {
//           for (let yR = 0;yR < yRows;++ yR) {
//             const xRCorner = yR * convInfo.strideHeight - padLeft;
//             const xRMin = Math.max(0, xRCorner);
//             const xRMax = Math.min(xRows, filterHeight + xRCorner);
//             for (let yC = 0;yC < yCols;++ yC) {
//               const xCCorner = yC * convInfo.strideWidth - padTop;
//               const xCMin = Math.max(0, xCCorner);
//               const xCMax = Math.min(xCols, filterWidth + xCCorner);
//               for (let q = 0;q < chMul;++ q) {
//                 let dotProd = 0;
//                 for (let xR = xRMin;xR < xRMax;++ xR) {
//                   const wR = xR - xRCorner;
//                   for (let xC = xCMin;xC < xCMax;++ xC) {
//                     const wC = xC - xCCorner;
//                     const pixel = input.get(b, xR, xC, d1);
//                     const weight = filter.get(wR, wC, d1, q);
//                     dotProd += pixel * weight;
//                   }
//                 }
//                 y.set(dotProd, b, yR, yC, d1 * chMul + q);
//               }
//             }
//           }
//         }
//       }
//       return y;
//     };
//     NDArrayMathCPU.prototype.tileInternal = function (a, reps) {
//       const newShape = new Array(a.rank);
//       for (var i = 0;i < newShape.length;i ++) {
//         newShape[i] = a.shape[i] * reps[i];
//       }
//       let dtype;
//       if (a.dtype === `float32`) {
//         dtype = Float32Array;
//       }
//       else if (a.dtype === `int32`) {
//         dtype = Int32Array;
//       }
//       else if (a.dtype === `bool`) {
//         dtype = Uint8Array;
//       }
//       else {
//         throw new Error(`Dtype ${  a.dtype  } not supported for tile`);
//       }
//       const resultValues = new dtype(util.sizeFromShape(newShape));
//       const result = ndarray_1.NDArray.make(newShape, {values: resultValues}, a.dtype);
//       const values = a.getValues();
//       for (var i = 0;i < result.size;++ i) {
//         const newLoc = result.indexToLoc(i);
//         const originalLoc = new Array(a.rank);
//         for (let i_1 = 0;i_1 < originalLoc.length;i_1 ++) {
//           originalLoc[i_1] = newLoc[i_1] % a.shape[i_1];
//         }
//         const originalIndex = a.locToIndex(originalLoc);
//         resultValues[i] = values[originalIndex];
//       }
//       return result;
//     };
//     NDArrayMathCPU.prototype.transposeInternal = function (a, perm) {
//       const newShape = new Array(a.rank);
//       for (var i = 0;i < newShape.length;i ++) {
//         newShape[i] = a.shape[perm[i]];
//       }
//       const resultValues = new Float32Array(a.size);
//       const values = a.getValues();
//       const result = ndarray_1.NDArray.make(newShape, {values: resultValues});
//       for (var i = 0;i < a.size;++ i) {
//         const loc = a.indexToLoc(i);
//         const newLoc = new Array(loc.length);
//         for (let i_2 = 0;i_2 < newLoc.length;i_2 ++) {
//           newLoc[i_2] = loc[perm[i_2]];
//         }
//         const newIndex = result.locToIndex(newLoc);
//         resultValues[newIndex] = values[i];
//       }
//       return result;
//     };
//     NDArrayMathCPU.prototype.pool = function (x, convInfo, poolType) {
//       let _a = x.shape, xRows = _a[0], xCols = _a[1], depth = _a[2];
//       const strideHeight = convInfo.strideHeight;
//       const strideWidth = convInfo.strideWidth;
//       const filterHeight = convInfo.filterHeight;
//       const filterWidth = convInfo.filterWidth;
//       const y = ndarray_1.Array3D.zeros(convInfo.outShape);
//       const padTop = convInfo.padInfo.top;
//       const padLeft = convInfo.padInfo.left;
//       for (let d = 0;d < depth;++ d) {
//         for (let yR = 0;yR < y.shape[0];++ yR) {
//           const xRCorner = yR * strideHeight - padTop;
//           const xRMin = Math.max(0, xRCorner);
//           const xRMax = Math.min(xRows, filterHeight + xRCorner);
//           for (let yC = 0;yC < y.shape[1];++ yC) {
//             const xCCorner = yC * strideWidth - padLeft;
//             const xCMin = Math.max(0, xCCorner);
//             const xCMax = Math.min(xCols, filterWidth + xCCorner);
//             let minMaxValue = (poolType === `max` ? Number.NEGATIVE_INFINITY :
//                         Number.POSITIVE_INFINITY);
//             let avgValue = 0;
//             for (let xR = xRMin;xR < xRMax;++ xR) {
//               for (let xC = xCMin;xC < xCMax;++ xC) {
//                 const pixel = x.get(xR, xC, d);
//                 if (isNaN(pixel)) {
//                   minMaxValue = NaN;
//                   avgValue = NaN;
//                   break;
//                 }
//                 if ((poolType === `max` && pixel > minMaxValue) ||
//                                 (poolType === `min` && pixel < minMaxValue)) {
//                   minMaxValue = pixel;
//                 }
//                 else if (poolType === `avg`) {
//                   avgValue += pixel / (filterHeight * filterWidth);
//                 }
//               }
//               if (isNaN(minMaxValue)) {
//                 break;
//               }
//             }
//             y.set(poolType === `avg` ? avgValue : minMaxValue, yR, yC, d);
//           }
//         }
//       }
//       return y;
//     };
//     NDArrayMathCPU.prototype.maxPoolInternal = function (x, convInfo) {
//       return this.pool(x, convInfo, `max`);
//     };
//     NDArrayMathCPU.prototype.maxPoolPositions = function (x, convInfo) {
//       let _a = x.shape, xRows = _a[0], xCols = _a[1], depth = _a[2];
//       const outputShape = convInfo.outShape;
//       const maxPositions = ndarray_1.Array3D.zeros(outputShape);
//       const strideHeight = convInfo.strideHeight;
//       const strideWidth = convInfo.strideWidth;
//       const filterHeight = convInfo.filterHeight;
//       const filterWidth = convInfo.filterWidth;
//       const padTop = convInfo.padInfo.top;
//       const padLeft = convInfo.padInfo.left;
//       for (let d = 0;d < depth;++ d) {
//         for (let yR = 0;yR < outputShape[0];++ yR) {
//           const xRCorner = yR * strideHeight - padTop;
//           const xRMin = Math.max(0, xRCorner);
//           const xRMax = Math.min(xRows, filterHeight + xRCorner);
//           for (let yC = 0;yC < outputShape[1];++ yC) {
//             const xCCorner = yC * strideWidth - padLeft;
//             const xCMin = Math.max(0, xCCorner);
//             const xCMax = Math.min(xCols, filterWidth + xCCorner);
//             let maxValue = Number.NEGATIVE_INFINITY;
//             let maxPosition = - 1;
//             for (let xR = xRMin;xR < xRMax;++ xR) {
//               const wR = xR - xRCorner;
//               for (let xC = xCMin;xC < xCMax;++ xC) {
//                 const wC = xC - xCCorner;
//                 const pixel = x.get(xR, xC, d);
//                 if (pixel > maxValue) {
//                   maxValue = pixel;
//                   maxPosition = wR * filterWidth + wC;
//                 }
//               }
//             }
//             maxPositions.set(maxPosition, yR, yC, d);
//           }
//         }
//       }
//       return maxPositions;
//     };
//     NDArrayMathCPU.prototype.maxPoolBackpropInternal = function (dy, x, convInfo) {
//       const maxPositions = this.maxPoolPositions(x, convInfo);
//       const strideHeight = convInfo.strideHeight;
//       const strideWidth = convInfo.strideWidth;
//       const filterHeight = convInfo.filterHeight;
//       const filterWidth = convInfo.filterWidth;
//       const padLeft = filterWidth - 1 - convInfo.padInfo.left;
//       const padTop = filterHeight - 1 - convInfo.padInfo.top;
//       let _a = dy.shape, dyRows = _a[0], dyCols = _a[1], depth = _a[2];
//       const dx = ndarray_1.Array3D.zeros(x.shape);
//       for (let d = 0;d < depth;++ d) {
//         for (let dxR = 0;dxR < dx.shape[0];++ dxR) {
//           for (let dxC = 0;dxC < dx.shape[1];++ dxC) {
//             const dyRCorner = dxR - padTop;
//             const dyCCorner = dxC - padLeft;
//             let dotProd = 0;
//             for (let wR = 0;wR < filterHeight;++ wR) {
//               const dyR = (dyRCorner + wR) / strideHeight;
//               if (dyR < 0 || dyR >= dyRows || Math.floor(dyR) !== dyR) {
//                 continue;
//               }
//               for (let wC = 0;wC < filterWidth;++ wC) {
//                 const dyC = (dyCCorner + wC) / strideWidth;
//                 if (dyC < 0 || dyC >= dyCols || Math.floor(dyC) !== dyC) {
//                   continue;
//                 }
//                 const maxPos = filterHeight * filterWidth - 1 -
//                                 maxPositions.get(dyR, dyC, d);
//                 const curPos = wR * filterWidth + wC;
//                 const mask = maxPos === curPos ? 1 : 0;
//                 if (mask === 0) {
//                   continue;
//                 }
//                 const pixel = dy.get(dyR, dyC, d);
//                 dotProd += pixel * mask;
//               }
//             }
//             dx.set(dotProd, dxR, dxC, d);
//           }
//         }
//       }
//       return dx;
//     };
//     NDArrayMathCPU.prototype.minPoolInternal = function (x, convInfo) {
//       return this.pool(x, convInfo, `min`);
//     };
//     NDArrayMathCPU.prototype.avgPoolInternal = function (x, convInfo) {
//       return this.pool(x, convInfo, `avg`);
//     };
//     NDArrayMathCPU.prototype.resizeBilinear3DInternal = function (x, newShape2D, alignCorners) {
//       const output = ndarray_1.Array3D.zeros([newShape2D[0], newShape2D[1], x.shape[2]]);
//       const effectiveInputSize = alignCorners ? [x.shape[0] - 1, x.shape[1] - 1, x.shape[2]] : x.shape;
//       const effectiveOutputSize = alignCorners ?
//             [output.shape[0] - 1, output.shape[1] - 1, output.shape[2]] :
//             output.shape;
//       for (let r = 0;r < output.shape[0];r ++) {
//         for (let c = 0;c < output.shape[1];c ++) {
//           for (let d = 0;d < output.shape[2];d ++) {
//             const sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);
//             const sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);
//             const sourceRowFloor = Math.floor(sourceFracRow);
//             const sourceRowCeil = Math.min(x.shape[0] - 1, Math.ceil(sourceFracRow));
//             const sourceColFloor = Math.floor(sourceFracCol);
//             const sourceColCeil = Math.min(x.shape[1] - 1, Math.ceil(sourceFracCol));
//             const topLeft = x.get(sourceRowFloor, sourceColFloor, d);
//             const bottomLeft = x.get(sourceRowCeil, sourceColFloor, d);
//             const topRight = x.get(sourceRowFloor, sourceColCeil, d);
//             const bottomRight = x.get(sourceRowCeil, sourceColCeil, d);
//             const rowFrac = sourceFracRow - sourceRowFloor;
//             const colFrac = sourceFracCol - sourceColFloor;
//             const top_1 = topLeft + (topRight - topLeft) * colFrac;
//             const bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
//             const newValue = top_1 + (bottom - top_1) * rowFrac;
//             output.set(newValue, r, c, d);
//           }
//         }
//       }
//       return output;
//     };
//     NDArrayMathCPU.prototype.batchNormalization2DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
//       const xValues = x.getValues();
//       const meanValues = mean.getValues();
//       const varianceValues = variance.getValues();
//       const scaleValues = scale ? scale.getValues() : new Float32Array([1]);
//       const offsetValues = offset ? offset.getValues() : new Float32Array([0]);
//       const outValues = new Float32Array(xValues.length);
//       for (let i = 0;i < xValues.length;i ++) {
//         outValues[i] = offsetValues[i % offsetValues.length] +
//                 (xValues[i] - meanValues[i % meanValues.length]) *
//                     scaleValues[i % scaleValues.length] /
//                     Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
//       }
//       return ndarray_1.Array2D.new(x.shape, outValues);
//     };
//     NDArrayMathCPU.prototype.batchNormalization3DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
//       const xValues = x.getValues();
//       const meanValues = mean.getValues();
//       const varianceValues = variance.getValues();
//       const scaleValues = scale ? scale.getValues() : new Float32Array([1]);
//       const offsetValues = offset ? offset.getValues() : new Float32Array([0]);
//       const outValues = new Float32Array(xValues.length);
//       for (let i = 0;i < xValues.length;i ++) {
//         outValues[i] = offsetValues[i % offsetValues.length] +
//                 (xValues[i] - meanValues[i % meanValues.length]) *
//                     scaleValues[i % scaleValues.length] /
//                     Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
//       }
//       return ndarray_1.Array3D.new(x.shape, outValues);
//     };
//     NDArrayMathCPU.prototype.multinomialInternal = function (probabilities, numSamples, seed) {
//       const batchSize = probabilities.shape[0];
//       const numEvents = probabilities.shape[1];
//       const res = ndarray_1.Array2D.zeros([batchSize, numSamples], `int32`);
//       const resVals = res.getValues();
//       const probVals = probabilities.getValues();
//       for (let b = 0;b < batchSize;++ b) {
//         const offset = b * numEvents;
//         const cdf = new Float32Array(numEvents - 1);
//         cdf[0] = probVals[offset];
//         for (let event_1 = 1;event_1 < cdf.length;++ event_1) {
//           cdf[event_1] = cdf[event_1 - 1] + probVals[offset + event_1];
//         }
//         const random = seedrandom.alea(seed.toString());
//         const outOffset = b * numSamples;
//         for (let sampleId = 0;sampleId < numSamples;++ sampleId) {
//           const r = random();
//           resVals[outOffset + sampleId] = cdf.length;
//           for (let event_2 = 0;event_2 < cdf.length;event_2 ++) {
//             if (r < cdf[event_2]) {
//               resVals[outOffset + sampleId] = event_2;
//               break;
//             }
//           }
//         }
//       }
//       return res;
//     };
//     NDArrayMathCPU.prototype.oneHotInternal = function (indices, depth, onValue, offValue) {
//       const res = new Float32Array(indices.size * depth);
//       res.fill(offValue);
//       for (let event_3 = 0;event_3 < indices.size;++ event_3) {
//         res[event_3 * depth + indices.get(event_3)] = onValue;
//       }
//       return ndarray_1.Array2D.new([indices.size, depth], res);
//     };
//     NDArrayMathCPU.prototype.broadcastedBinaryOp = function (a, b, dtype, op) {
//       const newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
//       const result = ndarray_1.NDArray.zeros(newShape, dtype);
//       const newValues = result.getValues();
//       const aValues = a.getValues();
//       const bValues = b.getValues();
//       const aBroadcastDims = broadcast_util.getBroadcastDims(a.shape, newShape);
//       const bBroadcastDims = broadcast_util.getBroadcastDims(b.shape, newShape);
//       const _loop_1 = function (i) {
//         const loc = result.indexToLoc(i);
//         const aLoc = loc.slice(- a.rank);
//         aBroadcastDims.forEach(function (d) { return aLoc[d] = 0; });
//         const aIndex = a.locToIndex(aLoc);
//         const bLoc = loc.slice(- b.rank);
//         bBroadcastDims.forEach(function (d) { return bLoc[d] = 0; });
//         const bIndex = b.locToIndex(bLoc);
//         newValues[i] = op(aValues[aIndex], bValues[bIndex]);
//       };
//       for (let i = 0;i < newValues.length;++ i) {
//         _loop_1(i);
//       }
//       return result;
//     };
//     return NDArrayMathCPU;
//   }(math_1.NDArrayMath));
//   exports.NDArrayMathCPU = NDArrayMathCPU;
//
// }, {"../util": 88, "./axis_util": 46, "./broadcast_util": 47, "./concat_util": 48, "./conv_util": 49, "./copy2d_util": 50, "./math": 52, "./ndarray": 55, seedrandom: 90}], 54: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const util = require(`../util`);
//   const axis_util = require(`./axis_util`);
//   const math_1 = require(`./math`);
//   const ndarray = require(`./ndarray`);
//   const ndarray_1 = require(`./ndarray`);
//   const reduce_util = require(`./reduce_util`);
//   const addscaledmat_gpu_1 = require(`./webgl/addscaledmat_gpu`);
//   const argminmax_gpu_1 = require(`./webgl/argminmax_gpu`);
//   const batchnorm_gpu_1 = require(`./webgl/batchnorm_gpu`);
//   const binaryop_gpu = require(`./webgl/binaryop_gpu`);
//   const binaryop_gpu_1 = require(`./webgl/binaryop_gpu`);
//   const clip_gpu_1 = require(`./webgl/clip_gpu`);
//   const concat_gpu_1 = require(`./webgl/concat_gpu`);
//   const conv_backprop_gpu_1 = require(`./webgl/conv_backprop_gpu`);
//   const conv_gpu_1 = require(`./webgl/conv_gpu`);
//   const conv_gpu_depthwise_1 = require(`./webgl/conv_gpu_depthwise`);
//   const copy_gpu_1 = require(`./webgl/copy_gpu`);
//   const gpgpu_context_1 = require(`./webgl/gpgpu_context`);
//   const gpgpu_math = require(`./webgl/gpgpu_math`);
//   const gpgpu_util = require(`./webgl/gpgpu_util`);
//   const max_pool_backprop_gpu_1 = require(`./webgl/max_pool_backprop_gpu`);
//   const mulmat_gpu_1 = require(`./webgl/mulmat_gpu`);
//   const multinomial_gpu_1 = require(`./webgl/multinomial_gpu`);
//   const onehot_gpu_1 = require(`./webgl/onehot_gpu`);
//   const pool_gpu_1 = require(`./webgl/pool_gpu`);
//   const reduce_gpu_1 = require(`./webgl/reduce_gpu`);
//   const resize_bilinear_gpu_1 = require(`./webgl/resize_bilinear_gpu`);
//   const slice_gpu_1 = require(`./webgl/slice_gpu`);
//   const texture_manager_1 = require(`./webgl/texture_manager`);
//   const tile_gpu_1 = require(`./webgl/tile_gpu`);
//   const transpose_gpu_1 = require(`./webgl/transpose_gpu`);
//   const unary_op = require(`./webgl/unaryop_gpu`);
//   const unaryop_gpu_1 = require(`./webgl/unaryop_gpu`);
//   const webgl_util = require(`./webgl/webgl_util`);
//   const NDArrayMathGPU = (function (_super) {
//     __extends(NDArrayMathGPU, _super);
//     function NDArrayMathGPU(gpgpu, safeMode) {
//       if (safeMode === void 0) { safeMode = false; }
//       const _this = _super.call(this, safeMode) || this;
//       _this.binaryCache = {};
//       if (gpgpu == null) {
//         const gl = gpgpu_util.createWebGLContext();
//         _this.gpgpu = new gpgpu_context_1.GPGPUContext(gl);
//         _this.gpgpuCreatedLocally = true;
//       }
//       else {
//         _this.gpgpu = gpgpu;
//         _this.gpgpuCreatedLocally = false;
//       }
//       _this.textureManager = new texture_manager_1.TextureManager(_this.gpgpu);
//       ndarray.initializeGPU(_this.gpgpu, _this.textureManager);
//       return _this;
//     }
//     NDArrayMathGPU.prototype.getGPGPUContext = function () {
//       return this.gpgpu;
//     };
//     NDArrayMathGPU.prototype.cloneInternal = function (a) {
//       const texShape = a.getTextureShapeRC();
//       const source = a.as2D(texShape[0], texShape[1]);
//       const output = this.makeOutputArray(texShape, a.dtype);
//       this.copy2D(source, [0, 0], texShape, output, [0, 0], texShape);
//       return output.reshape(a.shape);
//     };
//     NDArrayMathGPU.prototype.slice1DInternal = function (input, begin, size) {
//       const program = new slice_gpu_1.SliceProgram([size]);
//       const customSetup = program.getCustomSetupFunc([begin]);
//       return this.compileAndRun(program, [input], null, customSetup);
//     };
//     NDArrayMathGPU.prototype.slice2DInternal = function (input, begin, size) {
//       const program = new slice_gpu_1.SliceProgram(size);
//       const customSetup = program.getCustomSetupFunc(begin);
//       return this.compileAndRun(program, [input], null, customSetup);
//     };
//     NDArrayMathGPU.prototype.slice3DInternal = function (input, begin, size) {
//       const program = new slice_gpu_1.SliceProgram(size);
//       const customSetup = program.getCustomSetupFunc(begin);
//       return this.compileAndRun(program, [input], null, customSetup);
//     };
//     NDArrayMathGPU.prototype.slice4DInternal = function (input, begin, size) {
//       const program = new slice_gpu_1.SliceProgram(size);
//       const customSetup = program.getCustomSetupFunc(begin);
//       return this.compileAndRun(program, [input], null, customSetup);
//     };
//     NDArrayMathGPU.prototype.copy2DInternal = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
//       const program = new copy_gpu_1.Copy2DProgram(sourceSizeRowCol[1], destSizeRowCol[1]);
//       const customSetup = program.getCustomSetupFunc(sourceBeginRowCol, destBeginRowCol, destSizeRowCol);
//       this.compileAndRun(program, [source], dest, customSetup);
//     };
//     NDArrayMathGPU.prototype.concat1DInternal = function (a, b) {
//       const program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, 0);
//       return this.compileAndRun(program, [a, b]);
//     };
//     NDArrayMathGPU.prototype.concat2DInternal = function (a, b, axis) {
//       const program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, axis);
//       return this.compileAndRun(program, [a, b]);
//     };
//     NDArrayMathGPU.prototype.concat3DInternal = function (x1, x2, axis) {
//       const program = new concat_gpu_1.ConcatProgram(x1.shape, x2.shape, axis);
//       return this.compileAndRun(program, [x1, x2]);
//     };
//     NDArrayMathGPU.prototype.concat4DInternal = function (x1, x2, axis) {
//       const program = new concat_gpu_1.ConcatProgram(x1.shape, x2.shape, axis);
//       return this.compileAndRun(program, [x1, x2]);
//     };
//     NDArrayMathGPU.prototype.scaledArrayAddInternal = function (c1, a, c2, b) {
//       const program = new addscaledmat_gpu_1.AddScaledMatProgram(a.shape, b.shape);
//       return this.compileAndRun(program, [a, b, c1, c2]);
//     };
//     NDArrayMathGPU.prototype.negInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.NEG);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.makeOutputArray = function (shape, dtype) {
//       const textureShapeRC = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);
//       const texture = this.textureManager.acquireTexture(textureShapeRC);
//       return ndarray_1.NDArray.make(shape, {texture: texture, textureShapeRC: textureShapeRC}, dtype);
//     };
//     NDArrayMathGPU.prototype.compileAndRun = function (program, inputs, output, customSetup) {
//       const _this = this;
//       if (output == null) {
//         output = this.makeOutputArray(program.outputShape, inputs[0].dtype);
//       }
//       const key = gpgpu_math.makeShaderKey(program, inputs, output);
//       const binary = this.getAndSaveBinary(key, function () {
//         return gpgpu_math.compileProgram(_this.gpgpu, program, inputs, output);
//       });
//       gpgpu_math.runProgram(binary, inputs, output, customSetup);
//       return output;
//     };
//     NDArrayMathGPU.prototype.matMulInternal = function (a, b, aOrientation, bOrientation) {
//       const program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, aOrientation, bOrientation);
//       return this.compileAndRun(program, [a, b]);
//     };
//     NDArrayMathGPU.prototype.multiplyInternal = function (a, b) {
//       const program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);
//       return this.compileAndRun(program, [a, b]);
//     };
//     NDArrayMathGPU.prototype.batchNormalization2DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
//       const inputs = [x, mean, variance];
//       let offsetShape = null;
//       if (offset != null) {
//         offsetShape = offset.shape;
//         inputs.push(offset);
//       }
//       let scaleShape = null;
//       if (scale != null) {
//         scaleShape = scale.shape;
//         inputs.push(scale);
//       }
//       const program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
//       return this.compileAndRun(program, inputs);
//     };
//     NDArrayMathGPU.prototype.batchNormalization3DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
//       const inputs = [x, mean, variance];
//       let offsetShape = null;
//       if (offset != null) {
//         offsetShape = offset.shape;
//         inputs.push(offset);
//       }
//       let scaleShape = null;
//       if (scale != null) {
//         scaleShape = scale.shape;
//         inputs.push(scale);
//       }
//       const program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
//       return this.compileAndRun(program, inputs);
//     };
//     NDArrayMathGPU.prototype.tileInternal = function (a, reps) {
//       const program = new tile_gpu_1.TileProgram(a.shape, reps);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.transposeInternal = function (a, perm) {
//       const program = new transpose_gpu_1.TransposeProgram(a.shape, perm);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.reduce = function (a, reduceType, dtype) {
//       const batchSize = a.shape[0];
//       const inSize = a.shape[1];
//       const windowSize = reduce_util.computeOptimalWindowSize(inSize);
//       const reduceInfo = {windowSize: windowSize, inSize: inSize, batchSize: batchSize};
//       const program = new reduce_gpu_1.ReduceProgram(reduceInfo, reduceType);
//       let _a = program.outputShape, rows = _a[0], cols = _a[1];
//       const output = this.makeOutputArray(program.outputShape, dtype).as2D(rows, cols);
//       this.compileAndRun(program, [a], output);
//       if (output.shape[1] === 1) {
//         return output;
//       }
//       return this.reduce(output, reduceType, dtype);
//     };
//     NDArrayMathGPU.prototype.argReduce = function (a, reduceType, bestIndicesA) {
//       if (bestIndicesA === void 0) { bestIndicesA = null; }
//       let batchSize = a.shape[0];
//       let inSize = a.shape[1];
//       if (bestIndicesA != null) {
//         batchSize = bestIndicesA.shape[0];
//         inSize = bestIndicesA.shape[1];
//       }
//       const windowSize = reduce_util.computeOptimalWindowSize(inSize);
//       const reduceInfo = {windowSize: windowSize, inSize: inSize, batchSize: batchSize};
//       const program = new argminmax_gpu_1.ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
//       let _a = program.outputShape, rows = _a[0], cols = _a[1];
//       const output = this.makeOutputArray(program.outputShape, `int32`).as2D(rows, cols);
//       const inputs = [a];
//       if (bestIndicesA != null) {
//         inputs.push(bestIndicesA);
//       }
//       this.compileAndRun(program, inputs, output);
//       if (output.shape[1] === 1) {
//         return output;
//       }
//       return this.argReduce(a, reduceType, output);
//     };
//     NDArrayMathGPU.prototype.sumInternal = function (a, axes) {
//       axis_util.assertAxesAreInnerMostDims(`sum`, axes, a.rank);
//       let _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
//       const inSize = util.sizeFromShape(reduceShape);
//       const a2D = a.as2D(- 1, inSize);
//       const outputDType = math_1.SumTypesMap[a.dtype];
//       return this.reduce(a2D, `sum`, outputDType).reshape(outShape);
//     };
//     NDArrayMathGPU.prototype.argMinInternal = function (a, axes) {
//       axis_util.assertAxesAreInnerMostDims(`argMin`, axes, a.rank);
//       let _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
//       const inSize = util.sizeFromShape(reduceShape);
//       const a2D = a.as2D(- 1, inSize);
//       return this.argReduce(a2D, `min`).reshape(outShape);
//     };
//     NDArrayMathGPU.prototype.argMaxInternal = function (a, axes) {
//       axis_util.assertAxesAreInnerMostDims(`argMax`, axes, a.rank);
//       let _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
//       const inSize = util.sizeFromShape(reduceShape);
//       const a2D = a.as2D(- 1, inSize);
//       return this.argReduce(a2D, `max`).reshape(outShape);
//     };
//     NDArrayMathGPU.prototype.equalInternal = function (x, y) {
//       const program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL, x.shape, y.shape);
//       const output = this.makeOutputArray(program.outputShape, `bool`);
//       return this.compileAndRun(program, [x, y], output);
//     };
//     NDArrayMathGPU.prototype.topKInternal = function (ndarray, k) {
//       throw new Error(`topK GPU not yet implemented!`);
//     };
//     NDArrayMathGPU.prototype.minInternal = function (a, axes) {
//       axis_util.assertAxesAreInnerMostDims(`min`, axes, a.rank);
//       let _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
//       const inSize = util.sizeFromShape(reduceShape);
//       const a2D = a.as2D(- 1, inSize);
//       return this.reduce(a2D, `min`, a2D.dtype).reshape(outShape);
//     };
//     NDArrayMathGPU.prototype.maxInternal = function (a, axes) {
//       axis_util.assertAxesAreInnerMostDims(`max`, axes, a.rank);
//       let _a = axis_util.computeOutAndReduceShapes(a.shape, axes), outShape = _a[0], reduceShape = _a[1];
//       const inSize = util.sizeFromShape(reduceShape);
//       const a2D = a.as2D(- 1, inSize);
//       return this.reduce(a2D, `max`, a2D.dtype).reshape(outShape);
//     };
//     NDArrayMathGPU.prototype.divideInternal = function (a, b) {
//       const program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.DIV, a.shape, b.shape);
//       const output = this.makeOutputArray(program.outputShape, `float32`);
//       return this.compileAndRun(program, [a, b], output);
//     };
//     NDArrayMathGPU.prototype.addInternal = function (a, b) {
//       const program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);
//       return this.compileAndRun(program, [a, b]);
//     };
//     NDArrayMathGPU.prototype.subtractInternal = function (a, b) {
//       const program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);
//       return this.compileAndRun(program, [a, b]);
//     };
//     NDArrayMathGPU.prototype.ceilInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.CEIL);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.floorInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.FLOOR);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.expInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.EXP);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.logInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.LOG);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.sqrtInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SQRT);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.squareInternal = function (x) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQUARE);
//       return this.compileAndRun(program, [x]);
//     };
//     NDArrayMathGPU.prototype.reluInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.RELU);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.eluInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ELU);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.leakyReluInternal = function (a, alpha) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.LEAKY_RELU(alpha));
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.clipInternal = function (a, min, max) {
//       const program = new clip_gpu_1.ClipProgram(a.shape, min, max);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.absInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ABS);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.sigmoidInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SIGMOID);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.sinInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SIN);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.cosInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.COS);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.tanInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.TAN);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.asinInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ASIN);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.acosInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ACOS);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.atanInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ATAN);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.sinhInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SINH);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.coshInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.COSH);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.tanhInternal = function (a) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.TANH);
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.stepInternal = function (a, alpha) {
//       const program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.STEP(alpha));
//       return this.compileAndRun(program, [a]);
//     };
//     NDArrayMathGPU.prototype.conv2dInternal = function (x, filter, bias, convInfo) {
//       const program = new conv_gpu_1.Conv2DProgram(convInfo, bias != null);
//       const inputs = bias != null ? [x, filter, bias] : [x, filter];
//       return this.compileAndRun(program, inputs);
//     };
//     NDArrayMathGPU.prototype.conv2dDerInputInternal = function (dy, filter, convInfo) {
//       const program = new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);
//       return this.compileAndRun(program, [dy, filter]);
//     };
//     NDArrayMathGPU.prototype.conv2dDerFilterInternal = function (x, dY, convInfo) {
//       const program = new conv_backprop_gpu_1.Conv2DDerWeightsProgram(convInfo);
//       return this.compileAndRun(program, [x, dY]);
//     };
//     NDArrayMathGPU.prototype.conv2dDerBiasInternal = function (dY) {
//       const program = new conv_backprop_gpu_1.Conv2DDerBiasProgram(dY.shape);
//       return this.compileAndRun(program, [dY]);
//     };
//     NDArrayMathGPU.prototype.depthwiseConv2DInternal = function (input, filter, convInfo) {
//       const program = new conv_gpu_depthwise_1.DepthwiseConv2DProgram(convInfo);
//       return this.compileAndRun(program, [input, filter]);
//     };
//     NDArrayMathGPU.prototype.maxPoolInternal = function (x, convInfo) {
//       const program = new pool_gpu_1.Pool2DProgram(convInfo, `max`, false);
//       return this.compileAndRun(program, [x]);
//     };
//     NDArrayMathGPU.prototype.minPoolInternal = function (x, convInfo) {
//       const program = new pool_gpu_1.Pool2DProgram(convInfo, `min`, false);
//       return this.compileAndRun(program, [x]);
//     };
//     NDArrayMathGPU.prototype.avgPoolInternal = function (x, convInfo) {
//       const program = new pool_gpu_1.Pool2DProgram(convInfo, `avg`, false);
//       return this.compileAndRun(program, [x]);
//     };
//     NDArrayMathGPU.prototype.maxPoolBackpropInternal = function (dy, x, convInfo) {
//       const getPositions = true;
//       const maxPoolPositionsProgram = new pool_gpu_1.Pool2DProgram(convInfo, `max`, getPositions);
//       const maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);
//       const maxPoolBackPropProgram = new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);
//       const result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions]);
//       maxPoolPositions.dispose();
//       return result;
//     };
//     NDArrayMathGPU.prototype.resizeBilinear3DInternal = function (x, newShape2D, alignCorners) {
//       const program = new resize_bilinear_gpu_1.ResizeBilinear3DProgram(x.shape, newShape2D, alignCorners);
//       return this.compileAndRun(program, [x]);
//     };
//     NDArrayMathGPU.prototype.multinomialInternal = function (probs, numSamples, seed) {
//       const batchSize = probs.shape[0];
//       const numOutcomes = probs.shape[1];
//       const program = new multinomial_gpu_1.MultinomialProgram(batchSize, numOutcomes, numSamples);
//       const output = this.makeOutputArray(program.outputShape, `int32`);
//       const customSetup = program.getCustomSetupFunc(seed);
//       return this.compileAndRun(program, [probs], output, customSetup);
//     };
//     NDArrayMathGPU.prototype.oneHotInternal = function (indices, depth, onValue, offValue) {
//       const program = new onehot_gpu_1.OneHotProgram(indices.size, depth, onValue, offValue);
//       return this.compileAndRun(program, [indices]);
//     };
//     NDArrayMathGPU.prototype.getAndSaveBinary = function (key, getBinary) {
//       if (!(key in this.binaryCache)) {
//         this.binaryCache[key] = getBinary();
//       }
//       return this.binaryCache[key];
//     };
//     NDArrayMathGPU.prototype.getTextureManager = function () {
//       return this.textureManager;
//     };
//     NDArrayMathGPU.prototype.dispose = function () {
//       for (const key in this.binaryCache) {
//         this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
//       }
//       this.textureManager.dispose();
//       if (this.gpgpuCreatedLocally) {
//         this.gpgpu.dispose();
//       }
//     };
//     return NDArrayMathGPU;
//   }(math_1.NDArrayMath));
//   exports.NDArrayMathGPU = NDArrayMathGPU;
//
// }, {"../util": 88, "./axis_util": 46, "./math": 52, "./ndarray": 55, "./reduce_util": 56, "./webgl/addscaledmat_gpu": 58, "./webgl/argminmax_gpu": 59, "./webgl/batchnorm_gpu": 60, "./webgl/binaryop_gpu": 61, "./webgl/clip_gpu": 62, "./webgl/concat_gpu": 63, "./webgl/conv_backprop_gpu": 64, "./webgl/conv_gpu": 65, "./webgl/conv_gpu_depthwise": 66, "./webgl/copy_gpu": 67, "./webgl/gpgpu_context": 68, "./webgl/gpgpu_math": 69, "./webgl/gpgpu_util": 70, "./webgl/max_pool_backprop_gpu": 71, "./webgl/mulmat_gpu": 72, "./webgl/multinomial_gpu": 73, "./webgl/onehot_gpu": 74, "./webgl/pool_gpu": 75, "./webgl/reduce_gpu": 76, "./webgl/resize_bilinear_gpu": 78, "./webgl/slice_gpu": 80, "./webgl/texture_manager": 82, "./webgl/tile_gpu": 83, "./webgl/transpose_gpu": 84, "./webgl/unaryop_gpu": 85, "./webgl/webgl_util": 86}], 55: [function(require, module, exports) {
//   "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   const __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
//     return new (P || (P = Promise))(function (resolve, reject) {
//       function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
//       function rejected(value) { try { step(generator[`throw`](value)); } catch (e) { reject(e); } }
//       function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
//       step((generator = generator.apply(thisArg, _arguments || [])).next());
//     });
//   };
//   const __generator = (this && this.__generator) || function (thisArg, body) {
//     let _ = {label: 0, sent: function() { if (t[0] & 1) throw t[1];return t[1]; }, trys: [], ops: []}, f, y, t, g;
//     return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === `function` && (g[Symbol.iterator] = function() { return this; }), g;
//     function verb(n) { return function (v) { return step([n, v]); }; }
//     function step(op) {
//       if (f) throw new TypeError(`Generator is already executing.`);
//       while (_) try {
//         if (f = 1, y && (t = y[op[0] & 2 ? `return` : op[0] ? `throw` : `next`]) && !(t = t.call(y, op[1])).done) return t;
//         if (y = 0, t) op = [0, t.value];
//         switch (op[0]) {
//         case 0: case 1: t = op;break;
//         case 4: _.label++;return {value: op[1], done: false};
//         case 5: _.label++;y = op[1];op = [0];continue;
//         case 7: op = _.ops.pop();_.trys.pop();continue;
//         default:
//           if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0;continue; }
//           if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1];break; }
//           if (op[0] === 6 && _.label < t[1]) { _.label = t[1];t = op;break; }
//           if (t && _.label < t[2]) { _.label = t[2];_.ops.push(op);break; }
//           if (t[2]) _.ops.pop();
//           _.trys.pop();continue;
//         }
//         op = body.call(thisArg, _);
//       } catch (e) { op = [6, e];y = 0; } finally { f = t = 0; }
//       if (op[0] & 5) throw op[1];return {value: op[0] ? op[1] : void 0, done: true};
//     }
//   };
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const environment_1 = require(`../environment`);
//   const util = require(`../util`);
//   const tex_util_1 = require(`./webgl/tex_util`);
//   const webgl_util = require(`./webgl/webgl_util`);
//   exports.GPGPU = null;
//   exports.TEXTURE_MANAGER = null;
//   let DType;
//   (function (DType) {
//     DType[`float32`] = `float32`;
//     DType[`int32`] = `int32`;
//     DType[`bool`] = `bool`;
//   })(DType = exports.DType || (exports.DType = {}));
//   function initializeGPU(gpgpu, textureManager) {
//     exports.GPGPU = gpgpu;
//     exports.TEXTURE_MANAGER = textureManager;
//   }
//   exports.initializeGPU = initializeGPU;
//   function throwIfGPUNotInitialized() {
//     if (exports.GPGPU == null || exports.TEXTURE_MANAGER == null) {
//       throw new Error(`GPU not intialized.`);
//     }
//   }
//   const NDArray = (function () {
//     function NDArray(shape, data, dtype) {
//       util.assert(data.values != null || data.texture != null, `Either \`values\` or \`texture\` must be defined`);
//       util.assert(data.texture == null || (data.textureShapeRC != null), `\`textureShape\` must be defined when \`texture\` is defined`);
//       this.size = util.sizeFromShape(shape);
//       if (data.values != null) {
//         util.assert(this.size === data.values.length, `Constructing ndarray of shape (${  this.size  }) should match the ` +
//                 `length of values (${  data.values.length  })`);
//       }
//       this.shape = shape;
//       if (data.textureType == null) {
//         data.textureType = tex_util_1.TextureType.DEFAULT;
//       }
//       this.ndarrayData = data;
//       this.dtype = dtype || `float32`;
//       const dim = this.shape.length;
//       if (dim < 2) {
//         this.strides = [];
//       }
//       else {
//         this.strides = new Array(dim - 1);
//         this.strides[dim - 2] = this.shape[dim - 1];
//         for (let i = dim - 3;i >= 0;-- i) {
//           this.strides[i] = this.strides[i + 1] * this.shape[i + 1];
//         }
//       }
//     }
//     NDArray.zeros = function (shape, dtype) {
//       const values = makeZerosTypedArray(util.sizeFromShape(shape), dtype);
//       return NDArray.make(shape, {values: values}, dtype);
//     };
//     NDArray.zerosLike = function (another) {
//       return NDArray.zeros(another.shape, another.dtype);
//     };
//     NDArray.like = function (another) {
//       const newValues = copyTypedArray(another.getValues(), another.dtype);
//       return NDArray.make(another.shape, {values: newValues}, another.dtype);
//     };
//     NDArray.make = function (shape, data, dtype) {
//       if (data.isDisposed) {
//         throw new Error(`Cannot make new NDArray from disposed NDArrayData.`);
//       }
//       switch (shape.length) {
//       case 0:
//         return new Scalar(data, dtype);
//       case 1:
//         return new Array1D(data, dtype);
//       case 2:
//         return new Array2D(shape, data, dtype);
//       case 3:
//         return new Array3D(shape, data, dtype);
//       case 4:
//         return new Array4D(shape, data, dtype);
//       default:
//         return new NDArray(shape, data, dtype);
//       }
//     };
//     NDArray.fromPixels = function (pixels, numChannels) {
//       if (numChannels === void 0) { numChannels = 3; }
//       if (numChannels > 4) {
//         throw new Error(`Cannot construct NDArray with more than 4 channels from pixels.`);
//       }
//       const shape = [pixels.height, pixels.width, numChannels];
//       const textureShapeRC = [shape[0], shape[1]];
//       const texture = exports.TEXTURE_MANAGER.acquireTexture(textureShapeRC);
//       const textureType = tex_util_1.TextureType.RGBA_COLOR;
//       exports.GPGPU.uploadPixelDataToTexture(texture, pixels);
//       return Array3D.make(shape, {texture: texture, textureShapeRC: textureShapeRC, textureType: textureType});
//     };
//     NDArray.prototype.reshape = function (newShape) {
//       this.throwIfDisposed();
//       newShape = util.inferFromImplicitShape(newShape, this.size);
//       if (util.arraysEqual(this.shape, newShape)) {
//         return this;
//       }
//       util.assert(this.size === util.sizeFromShape(newShape), `new shape and old shape must have the same number of elements.`);
//       return NDArray.make(newShape, this.ndarrayData, this.dtype);
//     };
//     NDArray.prototype.flatten = function () {
//       if (this instanceof Array1D) {
//         return this;
//       }
//       return this.as1D();
//     };
//     NDArray.prototype.asScalar = function () {
//       util.assert(this.size === 1, `The array must have only 1 element.`);
//       return this.reshape([]);
//     };
//     NDArray.prototype.as1D = function () {
//       return this.reshape([this.size]);
//     };
//     NDArray.prototype.as2D = function (rows, columns) {
//       return this.reshape([rows, columns]);
//     };
//     NDArray.prototype.as3D = function (rows, columns, depth) {
//       return this.reshape([rows, columns, depth]);
//     };
//     NDArray.prototype.as4D = function (rows, columns, depth, depth2) {
//       return this.reshape([rows, columns, depth, depth2]);
//     };
//     NDArray.prototype.asType = function (dtype) {
//       this.throwIfDisposed();
//       let newData = this.getData();
//       if (newData.values != null) {
//         newData = {values: toTypedArray(newData.values, dtype)};
//       }
//       return NDArray.make(this.shape, newData, dtype);
//     };
//     Object.defineProperty(NDArray.prototype, `rank`, {
//       get: function () {
//         this.throwIfDisposed();
//         return this.shape.length;
//       },
//       enumerable: true,
//       configurable: true
//     });
//     NDArray.prototype.get = function () {
//       const locs = [];
//       for (let _i = 0;_i < arguments.length;_i ++) {
//         locs[_i] = arguments[_i];
//       }
//       this.throwIfDisposed();
//       let index = locs[locs.length - 1];
//       for (let i = 0;i < locs.length - 1;++ i) {
//         index += this.strides[i] * locs[i];
//       }
//       return this.getValues()[index];
//     };
//     NDArray.prototype.add = function (value) {
//       const locs = [];
//       for (let _i = 1;_i < arguments.length;_i ++) {
//         locs[_i - 1] = arguments[_i];
//       }
//       this.throwIfDisposed();
//       this.set.apply(this, [this.get.apply(this, locs) + value].concat(locs));
//     };
//     NDArray.prototype.set = function (value) {
//       const locs = [];
//       for (let _i = 1;_i < arguments.length;_i ++) {
//         locs[_i - 1] = arguments[_i];
//       }
//       this.throwIfDisposed();
//       let index = locs[locs.length - 1];
//       for (let i = 0;i < locs.length - 1;++ i) {
//         index += this.strides[i] * locs[i];
//       }
//       this.getValues()[index] = value;
//     };
//     NDArray.prototype.val = function () {
//       const locs = [];
//       for (let _i = 0;_i < arguments.length;_i ++) {
//         locs[_i] = arguments[_i];
//       }
//       return __awaiter(this, void 0, void 0, function () {
//         return __generator(this, function (_a) {
//           switch (_a.label) {
//           case 0:
//             this.throwIfDisposed();
//             return [4, this.data()];
//           case 1:
//             _a.sent();
//             return [2, this.get.apply(this, locs)];
//           }
//         });
//       });
//     };
//     NDArray.prototype.locToIndex = function (locs) {
//       let index = locs[locs.length - 1];
//       for (let i = 0;i < locs.length - 1;++ i) {
//         index += this.strides[i] * locs[i];
//       }
//       return index;
//     };
//     NDArray.prototype.indexToLoc = function (index) {
//       const locs = new Array(this.shape.length);
//       for (let i = 0;i < locs.length - 1;++ i) {
//         locs[i] = Math.floor(index / this.strides[i]);
//         index -= locs[i] * this.strides[i];
//       }
//       locs[locs.length - 1] = index;
//       return locs;
//     };
//     NDArray.prototype.fill = function (value) {
//       this.throwIfDisposed();
//       this.getValues().fill(value);
//     };
//     NDArray.prototype.getData = function () {
//       return this.ndarrayData;
//     };
//     NDArray.prototype.getValues = function () {
//       return this.dataSync();
//     };
//     NDArray.prototype.getValuesAsync = function () {
//       return this.data();
//     };
//     NDArray.prototype.data = function () {
//       return __awaiter(this, void 0, void 0, function () {
//         let _a, queryFn;
//         return __generator(this, function (_b) {
//           switch (_b.label) {
//           case 0:
//             this.throwIfDisposed();
//             if (this.ndarrayData.values != null) {
//               return [2, this.ndarrayData.values];
//             }
//             if (!(environment_1.ENV.get(`WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED`) &&
//                             this.ndarrayData.textureType === tex_util_1.TextureType.DEFAULT)) return [3, 2];
//             _a = this.ndarrayData;
//             return [4, exports.GPGPU.downloadMatrixFromTextureAsync(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1])];
//           case 1:
//             _a.values = _b.sent();
//             return [2, this.ndarrayData.values];
//           case 2:
//             if (environment_1.ENV.get(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED`)) return [3, 4];
//             return [4, this.dataSync()];
//           case 3: return [2, _b.sent()];
//           case 4:
//             queryFn = function () { };
//             return [4, exports.GPGPU.runQuery(queryFn)];
//           case 5:
//             _b.sent();
//             return [2, this.dataSync()];
//           }
//         });
//       });
//     };
//     NDArray.prototype.dataSync = function () {
//       this.throwIfDisposed();
//       if (this.ndarrayData.values == null) {
//         throwIfGPUNotInitialized();
//         let values = void 0;
//         if (this.ndarrayData.textureType === tex_util_1.TextureType.DEFAULT) {
//           values = exports.GPGPU.downloadMatrixFromTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1]);
//         }
//         else {
//           values = exports.GPGPU.downloadMatrixFromRGBAColorTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1], this.shape[2]);
//         }
//         this.ndarrayData.values = float32ToTypedArray(values, this.dtype);
//         this.disposeTexture();
//       }
//       return this.ndarrayData.values;
//     };
//     NDArray.prototype.uploadToGPU = function () {
//       throwIfGPUNotInitialized();
//       this.throwIfDisposed();
//       this.ndarrayData.textureShapeRC =
//             webgl_util.getTextureShapeFromLogicalShape(exports.GPGPU.gl, this.shape);
//       this.ndarrayData.texture =
//             exports.TEXTURE_MANAGER.acquireTexture(this.ndarrayData.textureShapeRC);
//       this.ndarrayData.textureType = tex_util_1.TextureType.DEFAULT;
//       exports.GPGPU.uploadMatrixToTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC[0], this.ndarrayData.textureShapeRC[1], typedArrayToFloat32(this.ndarrayData.values, this.dtype));
//       this.ndarrayData.values = null;
//     };
//     NDArray.prototype.getTexture = function () {
//       this.throwIfDisposed();
//       if (this.ndarrayData.texture == null) {
//         this.uploadToGPU();
//       }
//       return this.ndarrayData.texture;
//     };
//     NDArray.prototype.getTextureShapeRC = function () {
//       this.throwIfDisposed();
//       if (this.ndarrayData.textureShapeRC == null) {
//         this.uploadToGPU();
//       }
//       return this.ndarrayData.textureShapeRC;
//     };
//     NDArray.prototype.throwIfDisposed = function () {
//       if (this.ndarrayData.isDisposed) {
//         throw new Error(`NDArray is disposed.`);
//       }
//     };
//     NDArray.prototype.dispose = function () {
//       this.ndarrayData.values = null;
//       this.shape = null;
//       this.ndarrayData.isDisposed = true;
//       if (this.ndarrayData.texture != null) {
//         this.disposeTexture();
//       }
//     };
//     NDArray.prototype.disposeTexture = function () {
//       throwIfGPUNotInitialized();
//       exports.TEXTURE_MANAGER.releaseTexture(this.ndarrayData.texture, this.ndarrayData.textureShapeRC);
//       this.ndarrayData.texture = null;
//       this.ndarrayData.textureShapeRC = null;
//       this.ndarrayData.textureType = null;
//     };
//     NDArray.prototype.inGPU = function () {
//       this.throwIfDisposed();
//       return this.ndarrayData.texture != null;
//     };
//     NDArray.prototype.equals = function (t) {
//       this.throwIfDisposed();
//       return this.dtype === t.dtype && util.arraysEqual(this.shape, t.shape) &&
//             util.arraysEqual(this.getValues(), t.getValues());
//     };
//     NDArray.rand = function (shape, randFunction) {
//       const size = util.sizeFromShape(shape);
//       const values = new Float32Array(size);
//       for (let i = 0;i < size;i ++) {
//         values[i] = randFunction();
//       }
//       return NDArray.make(shape, {values: values});
//     };
//     NDArray.randNormal = function (shape, mean, stdDev) {
//       if (mean === void 0) { mean = 0; }
//       if (stdDev === void 0) { stdDev = 1; }
//       return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
//     };
//     NDArray.randTruncatedNormal = function (shape, mean, stdDev) {
//       if (mean === void 0) { mean = 0; }
//       if (stdDev === void 0) { stdDev = 1; }
//       return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
//     };
//     NDArray.randUniform = function (shape, a, b) {
//       return NDArray.rand(shape, function () { return util.randUniform(a, b); });
//     };
//     return NDArray;
//   }());
//   exports.NDArray = NDArray;
//   var Scalar = (function (_super) {
//     __extends(Scalar, _super);
//     function Scalar(data, dtype) {
//       let _this = this;
//       if (data.texture != null) {
//         data.textureShapeRC = [1, 1];
//       }
//       _this = _super.call(this, [], data, dtype) || this;
//       return _this;
//     }
//     Scalar.new = function (value, dtype) {
//       const values = [value];
//       return new Scalar({values: toTypedArray(values, dtype)}, dtype);
//     };
//     Scalar.prototype.get = function () {
//       return this.getValues()[0];
//     };
//     Scalar.prototype.val = function () {
//       return __awaiter(this, void 0, void 0, function () {
//         return __generator(this, function (_a) {
//           switch (_a.label) {
//           case 0: return [4, this.data()];
//           case 1:
//             _a.sent();
//             return [2, this.get()];
//           }
//         });
//       });
//     };
//     Scalar.prototype.set = function (value) {
//       this.getValues()[0] = value;
//     };
//     Scalar.prototype.add = function (value) {
//       this.getValues()[0] += value;
//     };
//     Scalar.prototype.asType = function (dtype) {
//       return _super.prototype.asType.call(this, dtype);
//     };
//     Scalar.prototype.locToIndex = function (loc) {
//       return 0;
//     };
//     Scalar.prototype.indexToLoc = function (index) {
//       return [];
//     };
//     Scalar.ZERO = Scalar.new(0);
//     Scalar.ONE = Scalar.new(1);
//     Scalar.TWO = Scalar.new(2);
//     Scalar.NEG_ONE = Scalar.new(- 1);
//     return Scalar;
//   }(NDArray));
//   exports.Scalar = Scalar;
//   var Array1D = (function (_super) {
//     __extends(Array1D, _super);
//     function Array1D(data, dtype) {
//       let _this = this;
//       const shape = (data.values != null) ?
//             [data.values.length] :
//             [util.sizeFromShape(data.textureShapeRC)];
//       _this = _super.call(this, shape, data, dtype) || this;
//       return _this;
//     }
//     Array1D.new = function (values, dtype) {
//       if (!instanceofTypedArray(values)) {
//         const inferredShape = util.inferShape(values);
//         util.assert(inferredShape.length === 1, `Error constructing Array1D. Shape of values ${  inferredShape  } is ` +
//                 `not 1 dimensional.`);
//       }
//       return new Array1D({values: toTypedArray(values, dtype)}, dtype);
//     };
//     Array1D.prototype.get = function (i) {
//       return this.getValues()[i];
//     };
//     Array1D.prototype.set = function (value, i) {
//       this.getValues()[i] = value;
//     };
//     Array1D.prototype.val = function (i) {
//       return __awaiter(this, void 0, void 0, function () {
//         return __generator(this, function (_a) {
//           switch (_a.label) {
//           case 0: return [4, this.data()];
//           case 1:
//             _a.sent();
//             return [2, this.get(i)];
//           }
//         });
//       });
//     };
//     Array1D.prototype.add = function (value, i) {
//       this.getValues()[i] += value;
//     };
//     Array1D.prototype.locToIndex = function (loc) {
//       return loc[0];
//     };
//     Array1D.prototype.indexToLoc = function (index) {
//       return [index];
//     };
//     Array1D.prototype.asType = function (dtype) {
//       return _super.prototype.asType.call(this, dtype);
//     };
//     Array1D.zeros = function (shape, dtype) {
//       return NDArray.zeros(shape, dtype);
//     };
//     Array1D.randNormal = function (shape, mean, stdDev) {
//       if (mean === void 0) { mean = 0; }
//       if (stdDev === void 0) { stdDev = 1; }
//       return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
//     };
//     Array1D.randTruncatedNormal = function (shape, mean, stdDev) {
//       if (mean === void 0) { mean = 0; }
//       if (stdDev === void 0) { stdDev = 1; }
//       return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
//     };
//     Array1D.randUniform = function (shape, a, b) {
//       return NDArray.rand(shape, function () { return util.randUniform(a, b); });
//     };
//     return Array1D;
//   }(NDArray));
//   exports.Array1D = Array1D;
//   var Array2D = (function (_super) {
//     __extends(Array2D, _super);
//     function Array2D(shape, data, dtype) {
//       let _this = this;
//       util.assert(shape.length === 2, `Shape should be of length 2`);
//       _this = _super.call(this, shape, data, dtype) || this;
//       _this.stride0 = _this.strides[0];
//       return _this;
//     }
//     Array2D.new = function (shape, values, dtype) {
//       if (!instanceofTypedArray(values)) {
//         const inferredShape = util.inferShape(values);
//         if (inferredShape.length > 1) {
//           util.assertShapesMatch(shape, inferredShape, `Error when constructing Array2D. Shape of values ${
//                     inferredShape  } does not match the provided shape ${shape  }. `);
//         }
//       }
//       return new Array2D(shape, {values: toTypedArray(values, dtype)}, dtype);
//     };
//     Array2D.prototype.get = function (i, j) {
//       return this.getValues()[this.stride0 * i + j];
//     };
//     Array2D.prototype.set = function (value, i, j) {
//       this.getValues()[this.stride0 * i + j] = value;
//     };
//     Array2D.prototype.add = function (value, i, j) {
//       this.getValues()[this.stride0 * i + j] += value;
//     };
//     Array2D.prototype.val = function (i, j) {
//       return __awaiter(this, void 0, void 0, function () {
//         return __generator(this, function (_a) {
//           switch (_a.label) {
//           case 0: return [4, this.data()];
//           case 1:
//             _a.sent();
//             return [2, this.get(i, j)];
//           }
//         });
//       });
//     };
//     Array2D.prototype.locToIndex = function (locs) {
//       return this.stride0 * locs[0] + locs[1];
//     };
//     Array2D.prototype.indexToLoc = function (index) {
//       return [Math.floor(index / this.stride0), index % this.stride0];
//     };
//     Array2D.prototype.asType = function (dtype) {
//       return _super.prototype.asType.call(this, dtype);
//     };
//     Array2D.zeros = function (shape, dtype) {
//       return NDArray.zeros(shape, dtype);
//     };
//     Array2D.randNormal = function (shape, mean, stdDev) {
//       if (mean === void 0) { mean = 0; }
//       if (stdDev === void 0) { stdDev = 1; }
//       return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
//     };
//     Array2D.randTruncatedNormal = function (shape, mean, stdDev) {
//       if (mean === void 0) { mean = 0; }
//       if (stdDev === void 0) { stdDev = 1; }
//       return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
//     };
//     Array2D.randUniform = function (shape, a, b) {
//       return NDArray.rand(shape, function () { return util.randUniform(a, b); });
//     };
//     return Array2D;
//   }(NDArray));
//   exports.Array2D = Array2D;
//   var Array3D = (function (_super) {
//     __extends(Array3D, _super);
//     function Array3D(shape, data, dtype) {
//       let _this = this;
//       util.assert(shape.length === 3, `Shape should be of length 3`);
//       _this = _super.call(this, shape, data, dtype) || this;
//       _this.stride0 = _this.strides[0];
//       _this.stride1 = _this.strides[1];
//       return _this;
//     }
//     Array3D.new = function (shape, values, dtype) {
//       if (!instanceofTypedArray(values)) {
//         const inferredShape = util.inferShape(values);
//         if (inferredShape.length > 1) {
//           util.assertShapesMatch(shape, inferredShape, `Error when constructing Array3D. Shape of values ${
//                     inferredShape  } does not match the provided shape ${shape  }. `);
//         }
//       }
//       return new Array3D(shape, {values: toTypedArray(values, dtype)}, dtype);
//     };
//     Array3D.prototype.get = function (i, j, k) {
//       return this.getValues()[this.stride0 * i + this.stride1 * j + k];
//     };
//     Array3D.prototype.set = function (value, i, j, k) {
//       this.getValues()[this.stride0 * i + this.stride1 * j + k] = value;
//     };
//     Array3D.prototype.val = function (i, j, k) {
//       return __awaiter(this, void 0, void 0, function () {
//         return __generator(this, function (_a) {
//           switch (_a.label) {
//           case 0: return [4, this.data()];
//           case 1:
//             _a.sent();
//             return [2, this.get(i, j, k)];
//           }
//         });
//       });
//     };
//     Array3D.prototype.add = function (value, i, j, k) {
//       this.getValues()[this.stride0 * i + this.stride1 * j + k] += value;
//     };
//     Array3D.prototype.locToIndex = function (locs) {
//       return this.stride0 * locs[0] + this.stride1 * locs[1] + locs[2];
//     };
//     Array3D.prototype.indexToLoc = function (index) {
//       const i = Math.floor(index / this.stride0);
//       index -= i * this.stride0;
//       return [i, Math.floor(index / this.stride1), index % this.stride1];
//     };
//     Array3D.prototype.asType = function (dtype) {
//       return _super.prototype.asType.call(this, dtype);
//     };
//     Array3D.zeros = function (shape, dtype) {
//       return NDArray.zeros(shape, dtype);
//     };
//     Array3D.randNormal = function (shape, mean, stdDev) {
//       if (mean === void 0) { mean = 0; }
//       if (stdDev === void 0) { stdDev = 1; }
//       return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
//     };
//     Array3D.randTruncatedNormal = function (shape, mean, stdDev) {
//       if (mean === void 0) { mean = 0; }
//       if (stdDev === void 0) { stdDev = 1; }
//       return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
//     };
//     Array3D.randUniform = function (shape, a, b) {
//       return NDArray.rand(shape, function () { return util.randUniform(a, b); });
//     };
//     return Array3D;
//   }(NDArray));
//   exports.Array3D = Array3D;
//   var Array4D = (function (_super) {
//     __extends(Array4D, _super);
//     function Array4D(shape, data, dtype) {
//       let _this = this;
//       util.assert(shape.length === 4, `Shape should be of length 4`);
//       _this = _super.call(this, shape, data, dtype) || this;
//       _this.stride0 = _this.strides[0];
//       _this.stride1 = _this.strides[1];
//       _this.stride2 = _this.strides[2];
//       return _this;
//     }
//     Array4D.new = function (shape, values, dtype) {
//       if (!instanceofTypedArray(values)) {
//         const inferredShape = util.inferShape(values);
//         if (inferredShape.length > 1) {
//           util.assertShapesMatch(shape, inferredShape, `Error when constructing Array4D. Shape of values ${
//                     inferredShape  } does not match the provided shape ${shape  }. `);
//         }
//       }
//       return new Array4D(shape, {values: toTypedArray(values, dtype)}, dtype);
//     };
//     Array4D.prototype.get = function (i, j, k, l) {
//       return this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l];
//     };
//     Array4D.prototype.set = function (value, i, j, k, l) {
//       this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] = value;
//     };
//     Array4D.prototype.val = function (i, j, k, l) {
//       return __awaiter(this, void 0, void 0, function () {
//         return __generator(this, function (_a) {
//           switch (_a.label) {
//           case 0: return [4, this.data()];
//           case 1:
//             _a.sent();
//             return [2, this.get(i, j, k, l)];
//           }
//         });
//       });
//     };
//     Array4D.prototype.add = function (value, i, j, k, l) {
//       this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] += value;
//     };
//     Array4D.prototype.locToIndex = function (locs) {
//       return this.stride0 * locs[0] + this.stride1 * locs[1] +
//             this.stride2 * locs[2] + locs[3];
//     };
//     Array4D.prototype.indexToLoc = function (index) {
//       const i = Math.floor(index / this.stride0);
//       index -= i * this.stride0;
//       const j = Math.floor(index / this.stride1);
//       index -= j * this.stride1;
//       return [i, j, Math.floor(index / this.stride2), index % this.stride2];
//     };
//     Array4D.prototype.asType = function (dtype) {
//       return _super.prototype.asType.call(this, dtype);
//     };
//     Array4D.zeros = function (shape, dtype) {
//       return NDArray.zeros(shape, dtype);
//     };
//     Array4D.randNormal = function (shape, mean, stdDev) {
//       if (mean === void 0) { mean = 0; }
//       if (stdDev === void 0) { stdDev = 1; }
//       return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
//     };
//     Array4D.randTruncatedNormal = function (shape, mean, stdDev) {
//       if (mean === void 0) { mean = 0; }
//       if (stdDev === void 0) { stdDev = 1; }
//       return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
//     };
//     Array4D.randUniform = function (shape, a, b) {
//       return NDArray.rand(shape, function () { return util.randUniform(a, b); });
//     };
//     return Array4D;
//   }(NDArray));
//   exports.Array4D = Array4D;
//   function copyTypedArray(array, dtype) {
//     if (dtype == null || dtype === `float32`) {
//       return new Float32Array(array);
//     }
//     else if (dtype === `int32`) {
//       return new Int32Array(array);
//     }
//     else if (dtype === `bool`) {
//       const bool = new Uint8Array(array.length);
//       for (let i = 0;i < bool.length;++ i) {
//         const val = array[i];
//         if (util.isValNaN(val, `bool`)) {
//           bool[i] = util.getNaN(`bool`);
//         }
//         else if (val) {
//           bool[i] = 1;
//         }
//       }
//       return bool;
//     }
//     else {
//       throw new Error(`Unknown data type ${  dtype}`);
//     }
//   }
//   function instanceofTypedArray(a) {
//     return a instanceof Float32Array || a instanceof Int32Array ||
//         a instanceof Uint8Array;
//   }
//   function noConversionNeeded(a, dtype) {
//     return (a instanceof Float32Array && dtype === `float32`) ||
//         (a instanceof Int32Array && dtype === `int32`) ||
//         (a instanceof Uint8Array && dtype === `bool`);
//   }
//   function toTypedArray(a, dtype) {
//     if (noConversionNeeded(a, dtype)) {
//       return a;
//     }
//     if (Array.isArray(a)) {
//       a = util.flatten(a);
//     }
//     return copyTypedArray(a, dtype);
//   }
//   function makeZerosTypedArray(size, dtype) {
//     if (dtype == null || dtype === `float32`) {
//       return new Float32Array(size);
//     }
//     else if (dtype === `int32`) {
//       return new Int32Array(size);
//     }
//     else if (dtype === `bool`) {
//       return new Uint8Array(size);
//     }
//     else {
//       throw new Error(`Unknown data type ${  dtype}`);
//     }
//   }
//   function typedArrayToFloat32(a, dtype) {
//     if (a instanceof Float32Array) {
//       return a;
//     }
//     else {
//       const res = new Float32Array(a.length);
//       for (let i = 0;i < res.length;i ++) {
//         const val = a[i];
//         res[i] = util.isValNaN(val, dtype) ? NaN : val;
//       }
//       return res;
//     }
//   }
//   function float32ToTypedArray(a, dtype) {
//     if (dtype === `float32`) {
//       return a;
//     }
//     else if (dtype === `int32` || dtype === `bool`) {
//       const result = (dtype === `int32`) ? new Int32Array(a.length) :
//             new Uint8Array(a.length);
//       for (let i = 0;i < result.length;++ i) {
//         let val = a[i];
//         val = isNaN(val) ? util.getNaN(dtype) : Math.round(val);
//         result[i] = val;
//       }
//       return result;
//     }
//     else {
//       throw new Error(`Unknown dtype ${  dtype}`);
//     }
//   }
//
// }, {"../environment": 7, "../util": 88, "./webgl/tex_util": 81, "./webgl/webgl_util": 86}], 56: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   exports.PARALLELIZE_THRESHOLD = 30;
//   function computeOptimalWindowSize(inSize) {
//     if (inSize <= exports.PARALLELIZE_THRESHOLD) {
//       return inSize;
//     }
//     return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
//   }
//   exports.computeOptimalWindowSize = computeOptimalWindowSize;
//   function nearestDivisor(size, start) {
//     for (let i = start;i < size;++ i) {
//       if (size % i === 0) {
//         return i;
//       }
//     }
//     return size;
//   }
//
// }, {}], 57: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const util = require(`../util`);
//   function assertParamsValid(input, begin, size) {
//     util.assert(input.rank === begin.length, `Error in slice${  input.rank  }D: Length of begin ${  begin  } must ` +
//         `match the rank of the array (${  input.rank  }).`);
//     util.assert(input.rank === size.length, `Error in slice${  input.rank  }D: Length of size ${  size  } must ` +
//         `match the rank of the array (${  input.rank  }).`);
//     for (let i = 0;i < input.rank;++ i) {
//       util.assert(begin[i] + size[i] <= input.shape[i], `Error in slice${  input.rank  }D: begin[${  i  }] + size[${  i  }] ` +
//             `(${  begin[i] + size[i]  }) would overflow input.shape[${  i  }] (${  input.shape[i]  })`);
//     }
//   }
//   exports.assertParamsValid = assertParamsValid;
//
// }, {"../util": 88}], 58: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const broadcast_util = require(`../broadcast_util`);
//   const AddScaledMatProgram = (function () {
//     function AddScaledMatProgram(aShape, bShape) {
//       this.variableNames = [`A`, `B`, `c1`, `c2`];
//       this.supportsBroadcasting = true;
//       this.outputShape =
//             broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
//       this.userCode = `\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        float c1 = getC1();\n        float c2 = getC2();\n        setOutput(dot(vec2(c1, c2), vec2(a, b)));\n      }\n    `;
//     }
//     return AddScaledMatProgram;
//   }());
//   exports.AddScaledMatProgram = AddScaledMatProgram;
//
// }, {"../broadcast_util": 47}], 59: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ArgMinMaxProgram = (function () {
//     function ArgMinMaxProgram(reduceInfo, op, firstPass) {
//       this.variableNames = [`A`];
//       const windowSize = reduceInfo.windowSize;
//       const batchSize = reduceInfo.batchSize;
//       const inSize = reduceInfo.inSize;
//       const outSize = Math.ceil(inSize / windowSize);
//       if (!firstPass) {
//         this.variableNames.push(`bestIndicesA`);
//       }
//       this.outputShape = [batchSize, outSize];
//       const compOp = (op === `max`) ? `>` : `<`;
//       const indexSnippet = firstPass ?
//             `inOffset + i;` :
//             `round(getBestIndicesA(batch, inOffset + i));`;
//       this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${  windowSize  };\n\n        int bestIndex = 0;\n        float bestValue = getA(batch, inOffset);\n\n        for (int i = 0; i < ${  windowSize  }; i++) {\n          int inIdx = ${  indexSnippet  };\n          float candidate = getA(batch, inIdx);\n          if (isNaN(candidate)) {\n            setOutput(candidate);\n            return;\n          }\n          if (candidate ${  compOp  } bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `;
//     }
//     return ArgMinMaxProgram;
//   }());
//   exports.ArgMinMaxProgram = ArgMinMaxProgram;
//
// }, {}], 60: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const broadcast_util = require(`../broadcast_util`);
//   const BatchNormProgram = (function () {
//     function BatchNormProgram(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
//       this.outputShape = [];
//       this.supportsBroadcasting = true;
//       this.variableNames = [`x`, `mean`, `variance`];
//       broadcast_util.assertAndGetBroadcastShape(xShape, meanShape);
//       broadcast_util.assertAndGetBroadcastShape(xShape, varianceShape);
//       let offsetSnippet = `0.0`;
//       if (offsetShape != null) {
//         broadcast_util.assertAndGetBroadcastShape(xShape, offsetShape);
//         this.variableNames.push(`offset`);
//         offsetSnippet = `getOffsetAtOutCoords()`;
//       }
//       let scaleSnippet = `1.0`;
//       if (scaleShape != null) {
//         broadcast_util.assertAndGetBroadcastShape(xShape, scaleShape);
//         this.variableNames.push(`scale`);
//         scaleSnippet = `getScaleAtOutCoords()`;
//       }
//       this.outputShape = xShape;
//       this.userCode = `\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${  offsetSnippet  };\n        float scale = ${  scaleSnippet  };\n        float inv = scale / sqrt(variance + float(${  varianceEpsilon  }));\n        setOutput((x - mean) * inv + offset);\n      }\n    `;
//     }
//     return BatchNormProgram;
//   }());
//   exports.BatchNormProgram = BatchNormProgram;
//
// }, {"../broadcast_util": 47}], 61: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const broadcast_util = require(`../broadcast_util`);
//   exports.ADD = `return a + b;`;
//   exports.SUB = `return a - b;`;
//   exports.MUL = `return a * b;`;
//   exports.DIV = `return a / b;`;
//   exports.EQUAL = `\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n  return float(a == b);\n`;
//   const BinaryOpProgram = (function () {
//     function BinaryOpProgram(op, aShape, bShape) {
//       this.variableNames = [`A`, `B`];
//       this.supportsBroadcasting = true;
//       this.outputShape =
//             broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
//       this.userCode = `\n      float binaryOperation(float a, float b) {\n        ${  op  }\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `;
//     }
//     return BinaryOpProgram;
//   }());
//   exports.BinaryOpProgram = BinaryOpProgram;
//
// }, {"../broadcast_util": 47}], 62: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ClipProgram = (function () {
//     function ClipProgram(aShape, min, max) {
//       this.variableNames = [`A`];
//       this.outputShape = aShape;
//       const minFixed = min.toFixed(20);
//       const maxFixed = max.toFixed(20);
//       this.userCode = `\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, ${  minFixed  }, ${  maxFixed  }));\n      }\n    `;
//     }
//     return ClipProgram;
//   }());
//   exports.ClipProgram = ClipProgram;
//
// }, {}], 63: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const concat_util = require(`../concat_util`);
//   const shader_compiler_1 = require(`./shader_compiler`);
//   const ConcatProgram = (function () {
//     function ConcatProgram(aShape, bShape, axis) {
//       this.variableNames = [`A`, `B`];
//       this.outputShape = [];
//       const yAxes = [`yR`, `yC`, `yD`, `yW`];
//       const concatAxis = yAxes[axis];
//       this.outputShape = concat_util.computeOutShape(aShape, bShape, axis);
//       const dType = shader_compiler_1.getCoordsDataType(aShape.length);
//       const unpackSnippet = getUnpack(aShape.length);
//       const sampleCoords = getSampleCoords(aShape.length);
//       this.userCode = `\n      void main() {\n        ${  dType  } coords = getOutputCoords();\n        ${  unpackSnippet  }\n\n        float value = 0.0;\n        if (${  concatAxis  } < ${  aShape[axis]  }) {\n          value = getA(${  sampleCoords  });\n        } else {\n          ${  concatAxis  } -= ${  aShape[axis]  };\n          value = getB(${  sampleCoords  });\n        }\n\n        setOutput(value);\n      }\n    `;
//     }
//     return ConcatProgram;
//   }());
//   exports.ConcatProgram = ConcatProgram;
//   function getSampleCoords(rank) {
//     if (rank === 1) {
//       return `yR`;
//     }
//     else if (rank === 2) {
//       return `yR, yC`;
//     }
//     else if (rank === 3) {
//       return `yR, yC, yD`;
//     }
//     else if (rank === 4) {
//       return `yR, yC, yD, yW`;
//     }
//     else {
//       throw Error(`Concat for rank ${  rank  } is not yet supported`);
//     }
//   }
//   function getUnpack(rank) {
//     let res = rank === 1 ? `int yR = coords;` : `int yR = coords.x;`;
//     if (rank > 1) {
//       res += `\nint yC = coords.y;`;
//     }
//     if (rank > 2) {
//       res += `\nint yD = coords.z;`;
//     }
//     if (rank > 3) {
//       res += `\nint yW = coords.w;`;
//     }
//     if (rank > 4) {
//       throw Error(`Concat for rank ${  rank  } is not yet supported`);
//     }
//     return res;
//   }
//
// }, {"../concat_util": 48, "./shader_compiler": 79}], 64: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const conv_util = require(`../conv_util`);
//   const Conv2DDerWeightsProgram = (function () {
//     function Conv2DDerWeightsProgram(convInfo) {
//       this.variableNames = [`x`, `dy`];
//       let _a = convInfo.outShape, yNumRows = _a[0], yNumCols = _a[1], outDepth = _a[2];
//       let _b = convInfo.inShape, xNumRows = _b[0], xNumCols = _b[1], inDepth = _b[2];
//       const strideHeight = convInfo.strideHeight;
//       const strideWidth = convInfo.strideWidth;
//       this.outputShape = conv_util.computeWeightsShape4D(inDepth, outDepth, convInfo.filterHeight, convInfo.filterWidth);
//       const padTop = convInfo.padInfo.top;
//       const padLeft = convInfo.padInfo.left;
//       this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int yR = 0; yR < ${  yNumRows  }; yR++) {\n          int xR = wR + yR * ${  strideHeight  } - ${  padTop  };\n\n          if (xR < 0 || xR >= ${  xNumRows  }) {\n            continue;\n          }\n\n          for (int yC = 0; yC < ${  yNumCols  }; yC++) {\n            int xC = wC + yC * ${  strideWidth  } - ${  padLeft  };\n\n            if (xC < 0 || xC >= ${  xNumCols  }) {\n              continue;\n            }\n\n            float dyValue = getDy(yR, yC, d2);\n            float xValue = getX(xR, xC, d1);\n            dotProd += (xValue * dyValue);\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;
//     }
//     return Conv2DDerWeightsProgram;
//   }());
//   exports.Conv2DDerWeightsProgram = Conv2DDerWeightsProgram;
//   const Conv2DDerInputProgram = (function () {
//     function Conv2DDerInputProgram(convInfo) {
//       this.variableNames = [`dy`, `W`];
//       let _a = convInfo.outShape, yRows = _a[0], yCols = _a[1], outDepth = _a[2];
//       this.outputShape = convInfo.inShape;
//       const filterHeight = convInfo.filterHeight;
//       const filterWidth = convInfo.filterWidth;
//       const strideHeight = convInfo.strideHeight;
//       const strideWidth = convInfo.strideWidth;
//       const padTop = filterHeight - 1 - convInfo.padInfo.top;
//       const padLeft = filterWidth - 1 - convInfo.padInfo.left;
//       this.userCode = `\n      const ivec2 pads = ivec2(${  padTop  }, ${  padLeft  });\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d1 = coords.z;\n\n        ivec2 dyCorner = coords.xy - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${  filterHeight  }; wR++) {\n          float dyR = float(dyRCorner + wR) / ${  strideHeight  }.0;\n\n          if (dyR < 0.0 || dyR >= ${  yRows  }.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${  filterHeight  } - 1 - wR;\n\n          for (int wC = 0; wC < ${  filterWidth  }; wC++) {\n            float dyC = float(dyCCorner + wC) / ${  strideWidth  }.0;\n\n            if (dyC < 0.0 || dyC >= ${  yCols  }.0 || fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${  filterWidth  } - 1 - wC;\n\n            for (int d2 = 0; d2 < ${  outDepth  }; d2++) {\n              float xValue = getDy(idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;
//     }
//     return Conv2DDerInputProgram;
//   }());
//   exports.Conv2DDerInputProgram = Conv2DDerInputProgram;
//   const Conv2DDerBiasProgram = (function () {
//     function Conv2DDerBiasProgram(yShape) {
//       this.variableNames = [`dy`];
//       let yNumRows = yShape[0], yNumCols = yShape[1], outputDepth = yShape[2];
//       this.outputShape = [outputDepth];
//       this.userCode = `\n      void main() {\n        int d2 = getOutputCoords();\n\n        float derBias = 0.0;\n        for (int yR = 0; yR < ${  yNumRows  }; yR++) {\n          for (int yC = 0; yC < ${  yNumCols  }; yC++) {\n            derBias += getDy(yR, yC, d2);\n          }\n        }\n        setOutput(derBias);\n      }\n    `;
//     }
//     return Conv2DDerBiasProgram;
//   }());
//   exports.Conv2DDerBiasProgram = Conv2DDerBiasProgram;
//
// }, {"../conv_util": 49}], 65: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const Conv2DProgram = (function () {
//     function Conv2DProgram(convInfo, hasBias) {
//       this.variableNames = [`x`, `W`];
//       if (hasBias) {
//         this.variableNames.push(`bias`);
//       }
//       this.outputShape = convInfo.outShape;
//       const biasSnippet = hasBias ? `dotProd += getBias(d2);` : ``;
//       let _a = convInfo.inShape, xNumRows = _a[0], xNumCols = _a[1], inputDepth = _a[2];
//       const padTop = convInfo.padInfo.top;
//       const padLeft = convInfo.padInfo.left;
//       const strideHeight = convInfo.strideHeight;
//       const strideWidth = convInfo.strideWidth;
//       const filterHeight = convInfo.filterHeight;
//       const filterWidth = convInfo.filterWidth;
//       const inputDepthNearestVec4 = Math.floor(inputDepth / 4) * 4;
//       const inputDepthVec4Remainder = inputDepth % 4;
//       this.userCode = `\n      const ivec2 strides = ivec2(${  strideHeight  }, ${  strideWidth  });\n      const ivec2 pads = ivec2(${  padTop  }, ${  padLeft  });\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d2 = coords.z;\n\n        ivec2 xRCCorner = coords.xy * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${  filterHeight  }; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${  xNumRows  }) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${  filterWidth  }; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= ${  xNumCols  }) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${  inputDepthNearestVec4  }; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(xR, xC, d1),\n                getX(xR, xC, d1 + 1),\n                getX(xR, xC, d1 + 2),\n                getX(xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if (${  inputDepthVec4Remainder === 1  }) {\n              dotProd +=\n                getX(xR, xC, ${  inputDepthNearestVec4  }) *\n                getW(wR, wC, ${  inputDepthNearestVec4  }, d2);\n            } else if (${  inputDepthVec4Remainder === 2  }) {\n              vec2 xValues = vec2(\n                getX(xR, xC, ${  inputDepthNearestVec4  }),\n                getX(xR, xC, ${  inputDepthNearestVec4  } + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, ${  inputDepthNearestVec4  }, d2),\n                getW(wR, wC, ${  inputDepthNearestVec4  } + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if (${  inputDepthVec4Remainder === 3  }) {\n              vec3 xValues = vec3(\n                getX(xR, xC, ${  inputDepthNearestVec4  }),\n                getX(xR, xC, ${  inputDepthNearestVec4  } + 1),\n                getX(xR, xC, ${  inputDepthNearestVec4  } + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, ${  inputDepthNearestVec4  }, d2),\n                getW(wR, wC, ${  inputDepthNearestVec4  } + 1, d2),\n                getW(wR, wC, ${  inputDepthNearestVec4  } + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        ${  biasSnippet  }\n        setOutput(dotProd);\n      }\n    `;
//     }
//     return Conv2DProgram;
//   }());
//   exports.Conv2DProgram = Conv2DProgram;
//
// }, {}], 66: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const DepthwiseConv2DProgram = (function () {
//     function DepthwiseConv2DProgram(convInfo) {
//       this.variableNames = [`x`, `W`];
//       this.outputShape = convInfo.outShape;
//       const xNumRows = convInfo.inShape[1];
//       const xNumCols = convInfo.inShape[2];
//       const padTop = convInfo.padInfo.top;
//       const padLeft = convInfo.padInfo.left;
//       const strideHeight = convInfo.strideHeight;
//       const strideWidth = convInfo.strideWidth;
//       const filterHeight = convInfo.filterHeight;
//       const filterWidth = convInfo.filterWidth;
//       const channelMul = convInfo.channelMul;
//       this.userCode = `\n      const ivec2 strides = ivec2(${  strideHeight  }, ${  strideWidth  });\n      const ivec2 pads = ivec2(${  padTop  }, ${  padLeft  });\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${  channelMul  };\n        int q = d2 - d1 * ${  channelMul  };\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${  filterHeight  }; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${  xNumRows  }) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${  filterWidth  }; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= ${  xNumCols  }) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;
//     }
//     return DepthwiseConv2DProgram;
//   }());
//   exports.DepthwiseConv2DProgram = DepthwiseConv2DProgram;
//
// }, {}], 67: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const Copy2DProgram = (function () {
//     function Copy2DProgram(srcNumCols, destNumCols) {
//       this.variableNames = [`source`];
//       this.outputShape = null;
//       this.userCode = `\n      uniform ivec2 sourceStart;\n      uniform ivec2 destStart;\n\n      void main() {\n        ivec2 destCoords = getOutputCoords() - destStart;\n        int index = destCoords.x * ${  destNumCols  } + destCoords.y;\n        int r = index / ${  srcNumCols  };\n        ivec2 sourceCoords = sourceStart + ivec2(r, index - r * ${  srcNumCols  });\n        setOutput(getSource(sourceCoords.x, sourceCoords.y));\n      }\n    `;
//     }
//     Copy2DProgram.prototype.getCustomSetupFunc = function (sourceStart, destStart, destSize) {
//       return function (gpgpu, webGLProgram) {
//         gpgpu.setOutputMatrixWriteRegion(destStart[0], destSize[0], destStart[1], destSize[1]);
//         const sourceStartCRLoc = gpgpu.getUniformLocation(webGLProgram, `sourceStart`);
//         gpgpu.gl.uniform2i(sourceStartCRLoc, sourceStart[0], sourceStart[1]);
//         const destStartCRLoc = gpgpu.getUniformLocation(webGLProgram, `destStart`);
//         gpgpu.gl.uniform2i(destStartCRLoc, destStart[0], destStart[1]);
//       };
//     };
//     return Copy2DProgram;
//   }());
//   exports.Copy2DProgram = Copy2DProgram;
//
// }, {}], 68: [function(require, module, exports) {
//   "use strict";
//   const __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
//     return new (P || (P = Promise))(function (resolve, reject) {
//       function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
//       function rejected(value) { try { step(generator[`throw`](value)); } catch (e) { reject(e); } }
//       function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
//       step((generator = generator.apply(thisArg, _arguments || [])).next());
//     });
//   };
//   const __generator = (this && this.__generator) || function (thisArg, body) {
//     let _ = {label: 0, sent: function() { if (t[0] & 1) throw t[1];return t[1]; }, trys: [], ops: []}, f, y, t, g;
//     return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === `function` && (g[Symbol.iterator] = function() { return this; }), g;
//     function verb(n) { return function (v) { return step([n, v]); }; }
//     function step(op) {
//       if (f) throw new TypeError(`Generator is already executing.`);
//       while (_) try {
//         if (f = 1, y && (t = y[op[0] & 2 ? `return` : op[0] ? `throw` : `next`]) && !(t = t.call(y, op[1])).done) return t;
//         if (y = 0, t) op = [0, t.value];
//         switch (op[0]) {
//         case 0: case 1: t = op;break;
//         case 4: _.label++;return {value: op[1], done: false};
//         case 5: _.label++;y = op[1];op = [0];continue;
//         case 7: op = _.ops.pop();_.trys.pop();continue;
//         default:
//           if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0;continue; }
//           if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1];break; }
//           if (op[0] === 6 && _.label < t[1]) { _.label = t[1];t = op;break; }
//           if (t && _.label < t[2]) { _.label = t[2];_.ops.push(op);break; }
//           if (t[2]) _.ops.pop();
//           _.trys.pop();continue;
//         }
//         op = body.call(thisArg, _);
//       } catch (e) { op = [6, e];y = 0; } finally { f = t = 0; }
//       if (op[0] & 5) throw op[1];return {value: op[0] ? op[1] : void 0, done: true};
//     }
//   };
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const environment_1 = require(`../../environment`);
//   const util = require(`../../util`);
//   const gpgpu_util = require(`./gpgpu_util`);
//   const tex_util = require(`./tex_util`);
//   const webgl_util = require(`./webgl_util`);
//   const GPGPUContext = (function () {
//     function GPGPUContext(gl) {
//       this.outputTexture = null;
//       this.program = null;
//       this.disposed = false;
//       this.autoDebugValidate = false;
//       if (gl != null) {
//         this.gl = gl;
//       }
//       else {
//         this.gl = gpgpu_util.createWebGLContext();
//       }
//       if (environment_1.ENV.get(`WEBGL_VERSION`) === 1) {
//         this.textureFloatExtension =
//                 webgl_util.getExtensionOrThrow(this.gl, `OES_texture_float`);
//         this.colorBufferFloatExtension =
//                 this.gl.getExtension(`WEBGL_color_buffer_float`);
//       }
//       else {
//         this.colorBufferFloatExtension =
//                 webgl_util.getExtensionOrThrow(this.gl, `EXT_color_buffer_float`);
//       }
//       this.loseContextExtension =
//             webgl_util.getExtensionOrThrow(this.gl, `WEBGL_lose_context`);
//       if (environment_1.ENV.get(`WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED`)) {
//         this.getBufferSubDataAsyncExtension =
//                 this.gl.getExtension(`WEBGL_get_buffer_sub_data_async`);
//       }
//       this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);
//       this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);
//       this.framebuffer = webgl_util.createFramebuffer(this.gl);
//     }
//     GPGPUContext.prototype.dispose = function () {
//       const _this = this;
//       this.throwIfDisposed();
//       if (this.program != null) {
//         console.warn(`Disposing a GPGPUContext that still has a bound WebGLProgram.` +
//                 ` This is probably a resource leak, delete the program with ` +
//                 `GPGPUContext.deleteProgram before disposing.`);
//       }
//       if (this.outputTexture != null) {
//         console.warn(`Disposing a GPGPUContext that still has a bound output matrix ` +
//                 `texture.  This is probably a resource leak, delete the output ` +
//                 `matrix texture with GPGPUContext.deleteMatrixTexture before ` +
//                 `disposing.`);
//       }
//       const gl = this.gl;
//       webgl_util.callAndCheck(gl, function () { return gl.finish(); });
//       webgl_util.callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
//       webgl_util.callAndCheck(gl, function () { return gl.deleteFramebuffer(_this.framebuffer); });
//       webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, null); });
//       webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.vertexBuffer); });
//       webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); });
//       webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.indexBuffer); });
//       this.loseContextExtension.loseContext();
//       this.disposed = true;
//     };
//     GPGPUContext.prototype.enableAutomaticDebugValidation = function (enabled) {
//       this.autoDebugValidate = enabled;
//       webgl_util.enableDebugWebGLErrorChecking(enabled);
//     };
//     GPGPUContext.prototype.createMatrixTexture = function (rows, columns) {
//       this.throwIfDisposed();
//       return gpgpu_util.createMatrixTexture(this.gl, rows, columns);
//     };
//     GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {
//       this.throwIfDisposed();
//       gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);
//     };
//     GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {
//       this.throwIfDisposed();
//       return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns);
//     };
//     GPGPUContext.prototype.deleteMatrixTexture = function (texture) {
//       const _this = this;
//       this.throwIfDisposed();
//       if (this.outputTexture === texture) {
//         webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
//         this.outputTexture = null;
//       }
//       webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteTexture(texture); });
//     };
//     GPGPUContext.prototype.uploadMatrixToTexture = function (texture, rows, columns, matrix) {
//       this.throwIfDisposed();
//       const numChannels = 1;
//       return gpgpu_util.uploadMatrixToTexture(this.gl, texture, rows, columns, matrix, numChannels);
//     };
//     GPGPUContext.prototype.uploadMatrixToPackedTexture = function (texture, rows, columns, matrix) {
//       this.throwIfDisposed();
//       return gpgpu_util.uploadMatrixToPackedTexture(this.gl, texture, rows, columns, matrix);
//     };
//     GPGPUContext.prototype.downloadMatrixFromTexture = function (texture, rows, columns) {
//       const _this = this;
//       return this.downloadMatrixDriver(texture, function () {
//         return gpgpu_util.downloadMatrixFromOutputTexture(_this.gl, rows, columns);
//       });
//     };
//     GPGPUContext.prototype.downloadMatrixFromTextureAsync = function (texture, rows, columns) {
//       return __awaiter(this, void 0, void 0, function () {
//         const _this = this;
//         return __generator(this, function (_a) {
//           if (this.getBufferSubDataAsyncExtension == null) {
//             throw new Error(`Cannot download matrix from output texture asynchronously, ` +
//                         `WEBGL_get_buffer_sub_data_async is not enabled.`);
//           }
//           return [2, this.downloadMatrixDriverAsync(texture, function () { return gpgpu_util.downloadMatrixFromOutputTextureAsync(_this.gl, _this.getBufferSubDataAsyncExtension, rows, columns); })];
//         });
//       });
//     };
//     GPGPUContext.prototype.downloadMatrixFromRGBAColorTexture = function (texture, rows, columns, channels) {
//       const _this = this;
//       return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromRGBAColorTexture(_this.gl, rows, columns, channels); });
//     };
//     GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, rows, columns) {
//       const _this = this;
//       return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl, rows, columns); });
//     };
//     GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {
//       this.throwIfDisposed();
//       const gl = this.gl;
//       const fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);
//       const vertexShader = gpgpu_util.createVertexShader(gl);
//       const program = webgl_util.createProgram(gl);
//       webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, vertexShader); });
//       webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, fragmentShader); });
//       webgl_util.linkProgram(gl, program);
//       if (this.autoDebugValidate) {
//         webgl_util.validateProgram(gl, program);
//       }
//       return program;
//     };
//     GPGPUContext.prototype.deleteProgram = function (program) {
//       const _this = this;
//       this.throwIfDisposed();
//       if (program === this.program) {
//         this.program = null;
//       }
//       if (program != null) {
//         webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteProgram(program); });
//       }
//     };
//     GPGPUContext.prototype.setProgram = function (program) {
//       const _this = this;
//       this.throwIfDisposed();
//       this.program = program;
//       if ((this.program != null) && this.autoDebugValidate) {
//         webgl_util.validateProgram(this.gl, this.program);
//       }
//       webgl_util.callAndCheck(this.gl, function () { return _this.gl.useProgram(program); });
//     };
//     GPGPUContext.prototype.getUniformLocation = function (program, uniformName) {
//       this.throwIfDisposed();
//       return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);
//     };
//     GPGPUContext.prototype.getAttributeLocation = function (program, attribute) {
//       const _this = this;
//       this.throwIfDisposed();
//       return webgl_util.callAndCheck(this.gl, function () { return _this.gl.getAttribLocation(program, attribute); });
//     };
//     GPGPUContext.prototype.getUniformLocationNoThrow = function (program, uniformName) {
//       this.throwIfDisposed();
//       return this.gl.getUniformLocation(program, uniformName);
//     };
//     GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformLocation, textureUnit) {
//       this.throwIfDisposed();
//       this.throwIfNoProgram();
//       webgl_util.bindTextureToProgramUniformSampler(this.gl, this.program, inputMatrixTexture, uniformLocation, textureUnit);
//     };
//     GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {
//       this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
//     };
//     GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {
//       this.throwIfDisposed();
//       let _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
//       this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
//     };
//     GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
//       this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
//     };
//     GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
//       throw new Error(`setOutputPackedMatrixWriteRegion not implemented.`);
//     };
//     GPGPUContext.prototype.debugValidate = function () {
//       if (this.program != null) {
//         webgl_util.validateProgram(this.gl, this.program);
//       }
//       webgl_util.validateFramebuffer(this.gl);
//     };
//     GPGPUContext.prototype.executeProgram = function (attribLocations) {
//       this.throwIfDisposed();
//       this.throwIfNoProgram();
//       const gl = this.gl;
//       gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer, attribLocations);
//       if (this.autoDebugValidate) {
//         this.debugValidate();
//       }
//       webgl_util.callAndCheck(gl, function () { return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); });
//     };
//     GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {
//       const _this = this;
//       this.throwIfDisposed();
//       webgl_util.callAndCheck(this.gl, function () { return _this.gl.finish(); });
//     };
//     GPGPUContext.prototype.runQuery = function (queryFn) {
//       if (environment_1.ENV.get(`WEBGL_VERSION`) === 2) {
//         return this.runQueryWebGL2(queryFn);
//       }
//       return this.runQueryWebGL1(queryFn);
//     };
//     GPGPUContext.prototype.runQueryWebGL2 = function (benchmark) {
//       const _this = this;
//       const ext = webgl_util.getExtensionOrThrow(this.gl, `EXT_disjoint_timer_query_webgl2`);
//       const query = this.gl.createQuery();
//       this.gl.beginQuery(ext.TIME_ELAPSED_EXT, query);
//       benchmark();
//       this.gl.endQuery(ext.TIME_ELAPSED_EXT);
//       return new Promise(function (resolve, reject) {
//         const queryGPU = function () {
//           const available = _this.gl
//                     .getQueryParameter(query, _this.gl.QUERY_RESULT_AVAILABLE);
//           const disjoint = _this.gl.getParameter(ext.GPU_DISJOINT_EXT);
//           return available && !disjoint;
//         };
//         const getTimeElapsed = function () {
//           const timeElapsedNanos = _this.gl
//                     .getQueryParameter(query, _this.gl.QUERY_RESULT);
//           resolve(timeElapsedNanos / 1000000);
//         };
//         const resolveWithWarning = function () {
//           console.warn(`Disjoint query timer never available.`);
//           resolve(- 1);
//         };
//         util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);
//       });
//     };
//     GPGPUContext.prototype.runQueryWebGL1 = function (benchmark) {
//       const _this = this;
//       const ext = webgl_util.getExtensionOrThrow(this.gl, `EXT_disjoint_timer_query`);
//       const query = ext.createQueryEXT();
//       ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
//       benchmark();
//       ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
//       return new Promise(function (resolve, reject) {
//         const queryGPU = function () {
//           const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
//           const disjoint = _this.gl.getParameter(ext.GPU_DISJOINT_EXT);
//           return available && !disjoint;
//         };
//         const getTimeElapsed = function () {
//           const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
//           resolve(timeElapsedNanos / 1000000);
//         };
//         const resolveWithWarning = function () {
//           console.warn(`Disjoint query timer never available.`);
//           resolve(- 1);
//         };
//         util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);
//       });
//     };
//     GPGPUContext.prototype.downloadMatrixDriverSetup = function (texture) {
//       this.throwIfDisposed();
//       webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
//       if (this.autoDebugValidate) {
//         webgl_util.validateFramebuffer(this.gl);
//       }
//     };
//     GPGPUContext.prototype.downloadMatrixDriverTeardown = function () {
//       if (this.outputTexture != null) {
//         webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
//         if (this.autoDebugValidate) {
//           webgl_util.validateFramebuffer(this.gl);
//         }
//       }
//       else {
//         webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
//       }
//     };
//     GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {
//       this.downloadMatrixDriverSetup(texture);
//       const result = downloadAndDecode();
//       this.downloadMatrixDriverTeardown();
//       return result;
//     };
//     GPGPUContext.prototype.downloadMatrixDriverAsync = function (texture, downloadAndDecode) {
//       return __awaiter(this, void 0, void 0, function () {
//         let result;
//         return __generator(this, function (_a) {
//           switch (_a.label) {
//           case 0:
//             this.downloadMatrixDriverSetup(texture);
//             return [4, downloadAndDecode()];
//           case 1:
//             result = _a.sent();
//             this.downloadMatrixDriverTeardown();
//             return [2, result];
//           }
//         });
//       });
//     };
//     GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {
//       this.throwIfDisposed();
//       const gl = this.gl;
//       webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
//       if (this.autoDebugValidate) {
//         webgl_util.validateFramebuffer(gl);
//       }
//       this.outputTexture = outputMatrixTextureMaybePacked;
//       webgl_util.callAndCheck(gl, function () { return gl.viewport(0, 0, width, height); });
//       webgl_util.callAndCheck(gl, function () { return gl.scissor(0, 0, width, height); });
//     };
//     GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {
//       const _this = this;
//       this.throwIfDisposed();
//       webgl_util.callAndCheck(this.gl, function () { return _this.gl.scissor(x, y, width, height); });
//     };
//     GPGPUContext.prototype.throwIfDisposed = function () {
//       if (this.disposed) {
//         throw new Error(`Attempted to use disposed GPGPUContext.`);
//       }
//     };
//     GPGPUContext.prototype.throwIfNoProgram = function () {
//       if (this.program == null) {
//         throw new Error(`No GPU program is currently set.`);
//       }
//     };
//     return GPGPUContext;
//   }());
//   exports.GPGPUContext = GPGPUContext;
//
// }, {"../../environment": 7, "../../util": 88, "./gpgpu_util": 70, "./tex_util": 81, "./webgl_util": 86}], 69: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const environment_1 = require(`../../environment`);
//   const util = require(`../../util`);
//   const shader_compiler = require(`./shader_compiler`);
//   const ATTRIBUTE_NAMES = [`uv`, `clipSpacePos`];
//   const NAN_UNIFORM_NAME = `NaN`;
//   function shouldUploadNaNUniform() {
//     return !environment_1.ENV.get(`WEBGL_FLOAT_TEXTURE_ENABLED`);
//   }
//   function compileProgram(gpgpu, program, inputs, output) {
//     const userCode = program.userCode;
//     const inputInfos = inputs.map(function (input, i) {
//       const shapeInfo = {
//         logicalShape: input.shape,
//         texShape: input.getTextureShapeRC(),
//         textureType: input.getData().textureType
//       };
//       return {name: program.variableNames[i], shapeInfo: shapeInfo};
//     });
//     const inShapeInfos = inputInfos.map(function (x) { return x.shapeInfo; });
//     const outShapeInfo = {
//       logicalShape: output.shape,
//       texShape: output.getTextureShapeRC(),
//       textureType: output.getData().textureType
//     };
//     const source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);
//     const webGLProgram = gpgpu.createProgram(source);
//     const uniformLocations = {};
//     for (let i = 0;i < program.variableNames.length;i ++) {
//       const uniformName = program.variableNames[i];
//       uniformLocations[uniformName] =
//             gpgpu.getUniformLocation(webGLProgram, uniformName);
//     }
//     const attributeLocations = {};
//     ATTRIBUTE_NAMES.forEach(function (attribute) {
//       attributeLocations[attribute] =
//             gpgpu.getAttributeLocation(webGLProgram, attribute);
//     });
//     if (shouldUploadNaNUniform()) {
//       uniformLocations[NAN_UNIFORM_NAME] =
//             gpgpu.getUniformLocation(webGLProgram, NAN_UNIFORM_NAME);
//     }
//     return {
//       program: program,
//       source: source,
//       webGLProgram: webGLProgram,
//       uniformLocations: uniformLocations,
//       attributeLocations: attributeLocations,
//       gpgpu: gpgpu,
//       inShapeInfos: inShapeInfos,
//       outShapeInfo: outShapeInfo
//     };
//   }
//   exports.compileProgram = compileProgram;
//   function validateBinaryAndProgram(shapeInfos, inputs) {
//     if (shapeInfos.length !== inputs.length) {
//       throw Error(`Binary was compiled with ${  shapeInfos.length  } inputs, but ` +
//             `was executed with ${  inputs.length  } inputs`);
//     }
//     shapeInfos.forEach(function (s, i) {
//       const shapeA = s.logicalShape;
//       const texShapeA = s.texShape;
//       const shapeB = inputs[i].shape;
//       const texShapeB = inputs[i].getTextureShapeRC();
//       if (!util.arraysEqual(shapeA, shapeB)) {
//         throw Error(`Binary was compiled with different shapes than ` +
//                 `the current args. Shapes ${  shapeA  } and ${  shapeB  } must match`);
//       }
//       if (!util.arraysEqual(texShapeA, texShapeB)) {
//         throw Error(`Binary was compiled with different texture shapes than the` +
//                 ` current args. Shape ${  texShapeA  } and ${  texShapeB  } must match`);
//       }
//     });
//   }
//   function runProgram(binary, inputs, output, customSetup) {
//     validateBinaryAndProgram(binary.inShapeInfos, inputs);
//     validateBinaryAndProgram([binary.outShapeInfo], [output]);
//     const outTex = output.getTexture();
//     const outTexShape = output.getTextureShapeRC();
//     const gpgpu = binary.gpgpu;
//     gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
//     gpgpu.setProgram(binary.webGLProgram);
//     inputs.forEach(function (input, i) {
//       const tex = input.getTexture();
//       const variableName = binary.program.variableNames[i];
//       const variableUniformLocation = binary.uniformLocations[variableName];
//       gpgpu.setInputMatrixTexture(tex, variableUniformLocation, i);
//     });
//     if (shouldUploadNaNUniform()) {
//       gpgpu.gl.uniform1f(binary.uniformLocations[NAN_UNIFORM_NAME], NaN);
//     }
//     if (customSetup != null) {
//       customSetup(gpgpu, binary.webGLProgram);
//     }
//     gpgpu.executeProgram(binary.attributeLocations);
//   }
//   exports.runProgram = runProgram;
//   function makeShaderKey(program, inputs, output) {
//     let keyInputs = ``;
//     inputs.concat(output).forEach(function (x) {
//       keyInputs += `${x.shape  }_${  x.getTextureShapeRC()}`;
//     });
//     const keyUserCode = program.userCode;
//     const keyBroadcast = (program.supportsBroadcasting === true).toString();
//     let key = program.constructor.name;
//     key += `_${  keyBroadcast  }_${  keyInputs  }_${  keyUserCode}`;
//     return key;
//   }
//   exports.makeShaderKey = makeShaderKey;
//
// }, {"../../environment": 7, "../../util": 88, "./shader_compiler": 79}], 70: [function(require, module, exports) {
//   "use strict";
//   const __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
//     return new (P || (P = Promise))(function (resolve, reject) {
//       function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
//       function rejected(value) { try { step(generator[`throw`](value)); } catch (e) { reject(e); } }
//       function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
//       step((generator = generator.apply(thisArg, _arguments || [])).next());
//     });
//   };
//   const __generator = (this && this.__generator) || function (thisArg, body) {
//     let _ = {label: 0, sent: function() { if (t[0] & 1) throw t[1];return t[1]; }, trys: [], ops: []}, f, y, t, g;
//     return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === `function` && (g[Symbol.iterator] = function() { return this; }), g;
//     function verb(n) { return function (v) { return step([n, v]); }; }
//     function step(op) {
//       if (f) throw new TypeError(`Generator is already executing.`);
//       while (_) try {
//         if (f = 1, y && (t = y[op[0] & 2 ? `return` : op[0] ? `throw` : `next`]) && !(t = t.call(y, op[1])).done) return t;
//         if (y = 0, t) op = [0, t.value];
//         switch (op[0]) {
//         case 0: case 1: t = op;break;
//         case 4: _.label++;return {value: op[1], done: false};
//         case 5: _.label++;y = op[1];op = [0];continue;
//         case 7: op = _.ops.pop();_.trys.pop();continue;
//         default:
//           if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0;continue; }
//           if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1];break; }
//           if (op[0] === 6 && _.label < t[1]) { _.label = t[1];t = op;break; }
//           if (t && _.label < t[2]) { _.label = t[2];_.ops.push(op);break; }
//           if (t[2]) _.ops.pop();
//           _.trys.pop();continue;
//         }
//         op = body.call(thisArg, _);
//       } catch (e) { op = [6, e];y = 0; } finally { f = t = 0; }
//       if (op[0] & 5) throw op[1];return {value: op[0] ? op[1] : void 0, done: true};
//     }
//   };
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const environment_1 = require(`../../environment`);
//   const tex_util = require(`./tex_util`);
//   const webgl_util = require(`./webgl_util`);
//   function getWebGLContextAttributes() {
//     return {
//       alpha: false,
//       antialias: false,
//       premultipliedAlpha: false,
//       preserveDrawingBuffer: false,
//       depth: false,
//       stencil: false,
//       failIfMajorPerformanceCaveat: true
//     };
//   }
//   exports.getWebGLContextAttributes = getWebGLContextAttributes;
//   function createWebGLContext(canvas) {
//     const attributes = getWebGLContextAttributes();
//     let gl;
//     if (canvas != null) {
//       gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes);
//     }
//     else {
//       gl = webgl_util.createWebGLRenderingContext(attributes);
//     }
//     webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DEPTH_TEST); });
//     webgl_util.callAndCheck(gl, function () { return gl.disable(gl.STENCIL_TEST); });
//     webgl_util.callAndCheck(gl, function () { return gl.disable(gl.BLEND); });
//     webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DITHER); });
//     webgl_util.callAndCheck(gl, function () { return gl.disable(gl.POLYGON_OFFSET_FILL); });
//     webgl_util.callAndCheck(gl, function () { return gl.disable(gl.SAMPLE_COVERAGE); });
//     webgl_util.callAndCheck(gl, function () { return gl.enable(gl.SCISSOR_TEST); });
//     webgl_util.callAndCheck(gl, function () { return gl.enable(gl.CULL_FACE); });
//     webgl_util.callAndCheck(gl, function () { return gl.cullFace(gl.BACK); });
//     return gl;
//   }
//   exports.createWebGLContext = createWebGLContext;
//   function createVertexShader(gl) {
//     const vertexShaderSource = `\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;
//     return webgl_util.createVertexShader(gl, vertexShaderSource);
//   }
//   exports.createVertexShader = createVertexShader;
//   function createVertexBuffer(gl) {
//     const vertexArray = new Float32Array([- 1, 1, 0, 0, 1, - 1, - 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, - 1, 0, 1, 0]);
//     return webgl_util.createStaticVertexBuffer(gl, vertexArray);
//   }
//   exports.createVertexBuffer = createVertexBuffer;
//   function createIndexBuffer(gl) {
//     const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
//     return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);
//   }
//   exports.createIndexBuffer = createIndexBuffer;
//   function getTextureInternalFormat(gl, numChannels) {
//     if (!environment_1.ENV.get(`WEBGL_FLOAT_TEXTURE_ENABLED`)) {
//       return gl.RGBA;
//     }
//     if (environment_1.ENV.get(`WEBGL_VERSION`) === 2) {
//       if (numChannels === 4) {
//         return gl.RGBA32F;
//       }
//       return gl.R32F;
//     }
//     return gl.RGBA;
//   }
//   function getTextureFormat(gl, numChannels) {
//     if (!environment_1.ENV.get(`WEBGL_FLOAT_TEXTURE_ENABLED`)) {
//       return gl.RGBA;
//     }
//     if (environment_1.ENV.get(`WEBGL_VERSION`) === 2) {
//       if (numChannels === 4) {
//         return gl.RGBA;
//       }
//       return gl.RED;
//     }
//     return gl.RGBA;
//   }
//   function getTextureType(gl) {
//     if (!environment_1.ENV.get(`WEBGL_FLOAT_TEXTURE_ENABLED`)) {
//       return gl.UNSIGNED_BYTE;
//     }
//     return gl.FLOAT;
//   }
//   function createAndConfigureTexture(gl, width, height, numChannels) {
//     webgl_util.validateTextureSize(gl, width, height);
//     const texture = webgl_util.createTexture(gl);
//     const tex2d = gl.TEXTURE_2D;
//     const internalFormat = getTextureInternalFormat(gl, numChannels);
//     const format = getTextureFormat(gl, numChannels);
//     webgl_util.callAndCheck(gl, function () { return gl.bindTexture(tex2d, texture); });
//     webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); });
//     webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); });
//     webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST); });
//     webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST); });
//     webgl_util.callAndCheck(gl, function () { return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, format, getTextureType(gl), null); });
//     webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
//     return texture;
//   }
//   function createMatrixTexture(gl, rows, columns) {
//     let _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
//     const numChannels = 1;
//     return createAndConfigureTexture(gl, width, height, numChannels);
//   }
//   exports.createMatrixTexture = createMatrixTexture;
//   function createColorMatrixTexture(gl, rows, columns) {
//     let _a = tex_util.getColorMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
//     const numChannels = 4;
//     return createAndConfigureTexture(gl, width, height, numChannels);
//   }
//   exports.createColorMatrixTexture = createColorMatrixTexture;
//   function createPackedMatrixTexture(gl, rows, columns) {
//     let _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
//     const numChannels = 4;
//     return createAndConfigureTexture(gl, width, height, numChannels);
//   }
//   exports.createPackedMatrixTexture = createPackedMatrixTexture;
//   function bindVertexProgramAttributeStreams(gl, program, vertexBuffer, attribLocations) {
//     const posOffset = 0;
//     const uvOffset = 3 * 4;
//     const stride = (3 * 4) + (2 * 4);
//     webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); });
//     webgl_util.bindVertexBufferToProgramAttribute(gl, program, `clipSpacePos`, vertexBuffer, 3, stride, posOffset, attribLocations);
//     webgl_util.bindVertexBufferToProgramAttribute(gl, program, `uv`, vertexBuffer, 2, stride, uvOffset, attribLocations);
//   }
//   exports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;
//   function uploadPixelDataToTexture(gl, texture, pixels) {
//     webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
//     webgl_util.callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels); });
//     webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
//   }
//   exports.uploadPixelDataToTexture = uploadPixelDataToTexture;
//   function uploadDataToTexture(gl, texture, width, height, data, numChannels) {
//     const textureFormat = getTextureFormat(gl, numChannels);
//     webgl_util.validateTextureSize(gl, width, height);
//     webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
//     webgl_util.callAndCheck(gl, function () { return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, getTextureType(gl), data); });
//     webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
//   }
//   function uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels) {
//     let _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
//     let unpackedArray;
//     if (environment_1.ENV.get(`WEBGL_FLOAT_TEXTURE_ENABLED`)) {
//       const channelsPerTexture = numChannels === 1 ? webgl_util.getChannelsPerTexture() : numChannels;
//       if (channelsPerTexture === 1) {
//         unpackedArray = matrix;
//       }
//       else {
//         unpackedArray =
//                 new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture));
//         tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture);
//       }
//     }
//     else {
//       unpackedArray = tex_util.encodeFloatArray(matrix);
//     }
//     uploadDataToTexture(gl, texture, w, h, unpackedArray, numChannels);
//   }
//   exports.uploadMatrixToTexture = uploadMatrixToTexture;
//   function uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix) {
//     let _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
//     const packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
//     tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);
//     const numChannels = 4;
//     uploadDataToTexture(gl, texture, w, h, packedRGBA, numChannels);
//   }
//   exports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;
//   function getDownloadTargetArrayBuffer(rows, columns, channelsPerTexture) {
//     const isFloatTexture = environment_1.ENV.get(`WEBGL_FLOAT_TEXTURE_ENABLED`);
//     let downloadTarget;
//     if (isFloatTexture) {
//       downloadTarget =
//             new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, channelsPerTexture));
//     }
//     else {
//       downloadTarget = new Uint8Array(rows * columns * channelsPerTexture);
//     }
//     return downloadTarget;
//   }
//   function decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel) {
//     const isFloatTexture = environment_1.ENV.get(`WEBGL_FLOAT_TEXTURE_ENABLED`);
//     if (isFloatTexture) {
//       const matrix = new Float32Array(rows * columns);
//       tex_util.decodeMatrixFromUnpackedArray(downloadTarget, matrix, channelsPerPixel);
//       return matrix;
//     }
//     else {
//       return tex_util.decodeToFloatArray(downloadTarget);
//     }
//   }
//   function downloadMatrixFromOutputTextureAsync(gl, getBufferSubDataAsyncExtension, rows, columns) {
//     return __awaiter(this, void 0, void 0, function () {
//       let gl2, channelsPerPixel, downloadTarget, bufferSizeBytes, buffer;
//       return __generator(this, function (_a) {
//         switch (_a.label) {
//         case 0:
//           gl2 = gl;
//           channelsPerPixel = 4;
//           downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
//           bufferSizeBytes = downloadTarget instanceof Float32Array ?
//                         downloadTarget.length * 4 :
//                         downloadTarget;
//           buffer = gl.createBuffer();
//           webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer); });
//           webgl_util.callAndCheck(gl, function () { return gl.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl.STATIC_DRAW); });
//           webgl_util.callAndCheck(gl, function () {
//             return gl2.readPixels(0, 0, columns, rows, gl.RGBA, getTextureType(gl), 0);
//           });
//           return [4, getBufferSubDataAsyncExtension.getBufferSubDataAsync(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget)];
//         case 1:
//           _a.sent();
//           return [2, decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel)];
//         }
//       });
//     });
//   }
//   exports.downloadMatrixFromOutputTextureAsync = downloadMatrixFromOutputTextureAsync;
//   function downloadMatrixFromOutputTexture(gl, rows, columns) {
//     let _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
//     const channelsPerPixel = 4;
//     const downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
//     webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), downloadTarget); });
//     return decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel);
//   }
//   exports.downloadMatrixFromOutputTexture = downloadMatrixFromOutputTexture;
//   function downloadMatrixFromRGBAColorTexture(gl, rows, columns, channels) {
//     const size = rows * columns * 4;
//     const downloadTarget = new Uint8Array(size);
//     webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, columns, rows, gl.RGBA, gl.UNSIGNED_BYTE, downloadTarget); });
//     const packedRGBA = new Float32Array(size);
//     for (let i = 0;i < downloadTarget.length;i ++) {
//       packedRGBA[i] = downloadTarget[i];
//     }
//     const matrix = new Float32Array(rows * columns * channels);
//     tex_util.decodeMatrixFromUnpackedColorRGBAArray(packedRGBA, matrix, channels);
//     return matrix;
//   }
//   exports.downloadMatrixFromRGBAColorTexture = downloadMatrixFromRGBAColorTexture;
//   function downloadMatrixFromPackedOutputTexture(gl, rows, columns) {
//     let _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
//     const packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
//     webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), packedRGBA); });
//     const matrix = new Float32Array(rows * columns);
//     return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix);
//   }
//   exports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture;
//
// }, {"../../environment": 7, "./tex_util": 81, "./webgl_util": 86}], 71: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const MaxPool2DBackpropProgram = (function () {
//     function MaxPool2DBackpropProgram(convInfo) {
//       this.variableNames = [`dy`, `maxPos`];
//       this.outputShape = convInfo.inShape;
//       const dyRows = convInfo.outShape[0];
//       const dyCols = convInfo.outShape[1];
//       const filterHeight = convInfo.filterHeight;
//       const filterWidth = convInfo.filterWidth;
//       const strideHeight = convInfo.strideHeight;
//       const strideWidth = convInfo.strideWidth;
//       const padTop = filterHeight - 1 - convInfo.padInfo.top;
//       const padLeft = filterWidth - 1 - convInfo.padInfo.left;
//       const lastIndex = filterHeight * filterWidth - 1;
//       this.userCode = `\n      const ivec2 pads = ivec2(${  padTop  }, ${  padLeft  });\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d = coords.z;\n\n        ivec2 dyRCCorner = coords.xy - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${  filterHeight  }; wR++) {\n          float dyR = float(dyRCorner + wR) / ${  strideHeight  }.0;\n\n          if (dyR < 0.0 || dyR >= ${  dyRows  }.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${  filterWidth  }; wC++) {\n            float dyC = float(dyCCorner + wC) / ${  strideWidth  }.0;\n\n            if (dyC < 0.0 || dyC >= ${  dyCols  }.0 || fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(idyR, idyC, d);\n            int maxPosValue = ${  lastIndex  } - int(getMaxPos(idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${  filterWidth  } + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;
//     }
//     return MaxPool2DBackpropProgram;
//   }());
//   exports.MaxPool2DBackpropProgram = MaxPool2DBackpropProgram;
//
// }, {}], 72: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const math_1 = require(`../math`);
//   const MatMulProgram = (function () {
//     function MatMulProgram(aShape, bShape, aOrient, bOrient) {
//       if (aOrient === void 0) { aOrient = math_1.MatrixOrientation.REGULAR; }
//       if (bOrient === void 0) { bOrient = math_1.MatrixOrientation.REGULAR; }
//       this.variableNames = [`matrixA`, `matrixB`];
//       const outerShapeA = (aOrient === math_1.MatrixOrientation.REGULAR) ? aShape[0] : aShape[1];
//       const outerShapeB = (bOrient === math_1.MatrixOrientation.REGULAR) ? bShape[1] : bShape[0];
//       this.outputShape = [outerShapeA, outerShapeB];
//       const sharedDim = (aOrient === math_1.MatrixOrientation.REGULAR ? aShape[1] : aShape[0]);
//       const aSnippetFromOffset = function (vec4Offset, indexVar) {
//         return (aOrient === math_1.MatrixOrientation.REGULAR) ?
//                 `aRow, ${  indexVar  } + ${  vec4Offset}` :
//                 `${indexVar  } + ${  vec4Offset  }, aRow`;
//       };
//       const bSnippetFromOffset = function (vec4Offset, indexVar) {
//         return (bOrient === math_1.MatrixOrientation.REGULAR) ?
//                 `${indexVar  } + ${  vec4Offset  }, bCol` :
//                 `bCol, ${  indexVar  } + ${  vec4Offset}`;
//       };
//       const sharedDimNearestVec4 = Math.floor(sharedDim / 4) * 4;
//       const sharedDimVec4Remainder = sharedDim % 4;
//       this.userCode = ` float dotARowBCol(int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < ${  sharedDimNearestVec4  }; i += 4) {\n        vec4 a = vec4(\n          getMatrixA(${  aSnippetFromOffset(0, `i`)  }),\n          getMatrixA(${  aSnippetFromOffset(1, `i`)  }),\n          getMatrixA(${  aSnippetFromOffset(2, `i`)  }),\n          getMatrixA(${  aSnippetFromOffset(3, `i`)  })\n        );\n        vec4 b = vec4(\n          getMatrixB(${  bSnippetFromOffset(0, `i`)  }),\n          getMatrixB(${  bSnippetFromOffset(1, `i`)  }),\n          getMatrixB(${  bSnippetFromOffset(2, `i`)  }),\n          getMatrixB(${  bSnippetFromOffset(3, `i`)  })\n        );\n\n        result += dot(a, b);\n      }\n\n      if (${  sharedDimVec4Remainder === 1  }) {\n        result += getMatrixA(${  aSnippetFromOffset(0, sharedDimNearestVec4)  }) *\n          getMatrixB(${  bSnippetFromOffset(0, sharedDimNearestVec4)  });\n      } else if (${  sharedDimVec4Remainder === 2  }) {\n        vec2 a = vec2(\n          getMatrixA(${  aSnippetFromOffset(0, sharedDimNearestVec4)  }),\n          getMatrixA(${  aSnippetFromOffset(1, sharedDimNearestVec4)  })\n        );\n        vec2 b = vec2(\n          getMatrixB(${  bSnippetFromOffset(0, sharedDimNearestVec4)  }),\n          getMatrixB(${  bSnippetFromOffset(1, sharedDimNearestVec4)  })\n        );\n        result += dot(a, b);\n      } else if (${  sharedDimVec4Remainder === 3  }) {\n        vec3 a = vec3(\n          getMatrixA(${  aSnippetFromOffset(0, sharedDimNearestVec4)  }),\n          getMatrixA(${  aSnippetFromOffset(1, sharedDimNearestVec4)  }),\n          getMatrixA(${  aSnippetFromOffset(2, sharedDimNearestVec4)  })\n        );\n        vec3 b = vec3(\n          getMatrixB(${  bSnippetFromOffset(0, sharedDimNearestVec4)  }),\n          getMatrixB(${  bSnippetFromOffset(1, sharedDimNearestVec4)  }),\n          getMatrixB(${  bSnippetFromOffset(2, sharedDimNearestVec4)  })\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec2 resRC = getOutputCoords();\n      setOutput(dotARowBCol(resRC.x, resRC.y));\n    }\n    `;
//     }
//     return MatMulProgram;
//   }());
//   exports.MatMulProgram = MatMulProgram;
//
// }, {"../math": 52}], 73: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const MultinomialProgram = (function () {
//     function MultinomialProgram(batchSize, numOutcomes, numSamples) {
//       this.variableNames = [`probs`];
//       this.outputShape = [batchSize, numSamples];
//       this.userCode = `\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${  numOutcomes - 1  }; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${  numOutcomes - 1  }));\n      }\n    `;
//     }
//     MultinomialProgram.prototype.getCustomSetupFunc = function (seed) {
//       const _this = this;
//       return function (gpgpu, webGLProgram) {
//         if (_this.seedLoc == null) {
//           _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, `seed`);
//         }
//         gpgpu.gl.uniform1f(_this.seedLoc, seed);
//       };
//     };
//     return MultinomialProgram;
//   }());
//   exports.MultinomialProgram = MultinomialProgram;
//
// }, {}], 74: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const OneHotProgram = (function () {
//     function OneHotProgram(numIndices, depth, onValue, offValue) {
//       this.variableNames = [`indices`];
//       this.outputShape = [numIndices, depth];
//       this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${  offValue  }), float(${  onValue  }),\n                      float(index == coords.y)));\n      }\n    `;
//     }
//     OneHotProgram.prototype.getCustomSetupFunc = function (seed) {
//       const _this = this;
//       return function (gpgpu, webGLProgram) {
//         if (_this.seedLoc == null) {
//           _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, `seed`);
//         }
//         gpgpu.gl.uniform1f(_this.seedLoc, seed);
//       };
//     };
//     return OneHotProgram;
//   }());
//   exports.OneHotProgram = OneHotProgram;
//
// }, {}], 75: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const Pool2DProgram = (function () {
//     function Pool2DProgram(convInfo, poolType, computePositions) {
//       this.variableNames = [`x`];
//       if (poolType === `avg` && computePositions) {
//         throw new Error(`Cannot compute positions for average pool.`);
//       }
//       const filterHeight = convInfo.filterHeight;
//       const filterWidth = convInfo.filterWidth;
//       const strideHeight = convInfo.strideHeight;
//       const strideWidth = convInfo.strideWidth;
//       const xNumRows = convInfo.inShape[0];
//       const xNumCols = convInfo.inShape[1];
//       const padTop = convInfo.padInfo.top;
//       const padLeft = convInfo.padInfo.left;
//       this.outputShape = convInfo.outShape;
//       const isAvgPool = poolType === `avg`;
//       let initializationValue = `0.0`;
//       if (!isAvgPool) {
//         if (poolType === `min`) {
//           initializationValue = `1.0 / 0.0`;
//         }
//         else {
//           initializationValue = `-1.0 / 0.0`;
//         }
//       }
//       if (computePositions) {
//         const compareOp_1 = poolType === `min` ? `<=` : `>=`;
//         this.userCode = `\n        const ivec2 strides = ivec2(${  strideHeight  }, ${  strideWidth  });\n        const ivec2 pads = ivec2(${  padTop  }, ${  padLeft  });\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n          int d = coords.z;\n\n          ivec2 xRCCorner = coords.xy * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${  filterHeight  }; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${  xNumRows  }) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${  filterWidth  }; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${  xNumCols  }) {\n                continue;\n              }\n\n              float value = getX(xR, xC, d);\n\n              if (isNaN(value)) {\n                setOutput(value);\n                return;\n              }\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${  compareOp_1  } currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * ${  filterWidth  } + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;
//         return;
//       }
//       const compareOp = poolType === `min` ? `min` : `max`;
//       let returnValue = `${poolType  }(${  poolType  }(${  poolType  }(` +
//             `minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
//       if (poolType === `avg`) {
//         returnValue = `avgValue / ${  filterHeight * filterWidth  }.0`;
//       }
//       const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
//       const filterWidthVec4Remainder = filterWidth % 4;
//       const updateSnippet = `\n      if (hasNaN(values)) {\n        setOutput(getNaN(values));\n        return;\n      }\n      if (${  isAvgPool  }) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${  compareOp  }(values, minMaxValue);\n      }\n    `;
//       this.userCode = `\n      const ivec2 strides = ivec2(${  strideHeight  }, ${  strideWidth  });\n      const ivec2 pads = ivec2(${  padTop  }, ${  padLeft  });\n      const float initializationValue = ${  initializationValue  };\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${  xNumCols  }) {\n          return initializationValue;\n        }\n        return getX(xR, xC, d);\n      }\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int d = coords.z;\n\n        ivec2 xRCCorner = coords.xy * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${  initializationValue  });\n        float avgValue = 0.0;\n\n        for (int wR = 0; wR < ${  filterHeight  }; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${  xNumRows  }) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${  filterWidthNearestVec4  }; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              getValue(xR, xC + 2, d),\n              getValue(xR, xC + 3, d)\n            );\n\n            ${  updateSnippet  }\n          }\n\n          int xC = xCCorner + ${  filterWidthNearestVec4  };\n          if (${  filterWidthVec4Remainder === 1  }) {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n            ${  updateSnippet  }\n          } else if (${  filterWidthVec4Remainder === 2  }) {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${  updateSnippet  }\n          } else if (${  filterWidthVec4Remainder === 3  }) {\n            vec4 values = vec4(\n              getValue(xR, xC, d),\n              getValue(xR, xC + 1, d),\n              getValue(xR, xC + 2, d),\n              initializationValue\n            );\n\n            ${  updateSnippet  }\n          }\n        }\n        setOutput(${  returnValue  });\n      }\n    `;
//     }
//     return Pool2DProgram;
//   }());
//   exports.Pool2DProgram = Pool2DProgram;
//
// }, {}], 76: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ReduceProgram = (function () {
//     function ReduceProgram(reduceInfo, reduceType) {
//       this.variableNames = [`x`];
//       const windowSize = reduceInfo.windowSize;
//       const batchSize = reduceInfo.batchSize;
//       const inSize = reduceInfo.inSize;
//       const outSize = Math.ceil(inSize / windowSize);
//       this.outputShape = [batchSize, outSize];
//       const isReduceSum = reduceType === `sum`;
//       let initializationValue = `0.0`;
//       if (!isReduceSum) {
//         if (reduceType === `min`) {
//           initializationValue = `1.0 / 0.0`;
//         }
//         else {
//           initializationValue = `-1.0 / 0.0`;
//         }
//       }
//       const compareOp = reduceType === `min` ? `min` : `max`;
//       let returnValue = `${reduceType  }(${  reduceType  }(${  reduceType  }(` +
//             `minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
//       if (reduceType === `sum`) {
//         returnValue = `sumValue`;
//       }
//       const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
//       const windowSizeVec4Remainder = windowSize % 4;
//       const updateSnippet = `\n      if (${  isReduceSum  }) {\n        sumValue += dot(values, ones);\n      } else {\n        if (hasNaN(values)) {\n          setOutput(getNaN(values));\n          return;\n        }\n        minMaxValue = ${  compareOp  }(values, minMaxValue);\n      }\n    `;
//       let checkOutOfBounds = ``;
//       if (inSize % windowSize > 0) {
//         checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${  inSize  }) {\n          return initializationValue;\n        }\n      `;
//       }
//       this.userCode = `\n      const float initializationValue = ${  initializationValue  };\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${  checkOutOfBounds  }\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${  windowSize  };\n\n        vec4 minMaxValue = vec4(${  initializationValue  });\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${  windowSizeNearestVec4  }; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${  updateSnippet  }\n        }\n\n        int inIdx = inOffset + ${  windowSizeNearestVec4  };\n        if (${  windowSizeVec4Remainder === 1  }) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n          ${  updateSnippet  }\n        } else if (${  windowSizeVec4Remainder === 2  }) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n          ${  updateSnippet  }\n        } else if (${  windowSizeVec4Remainder === 3  }) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n          ${  updateSnippet  }\n        }\n        setOutput(${  returnValue  });\n      }\n    `;
//     }
//     return ReduceProgram;
//   }());
//   exports.ReduceProgram = ReduceProgram;
//
// }, {}], 77: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const webgl_util = require(`./webgl_util`);
//   function getRenderRGBShader(gpgpu, destinationWidth) {
//     const fragmentShaderSource = `\n    precision highp float;\n    uniform sampler2D source;\n    varying vec2 resultUV;\n\n    const float destinationWidth = ${  destinationWidth  }.0;\n    const float a = 1.0;\n\n    void main() {\n      float xr = floor(resultUV.s * destinationWidth) * 3.0;\n      vec3 x = xr + vec3(0, 1, 2);\n\n      float sourceWidth = destinationWidth * 3.0;\n      vec3 u = (x + 0.5) / sourceWidth;\n      float v = 1.0 - resultUV.t;\n\n      float r = texture2D(source, vec2(u[0], v)).r;\n      float g = texture2D(source, vec2(u[1], v)).r;\n      float b = texture2D(source, vec2(u[2], v)).r;\n\n      gl_FragColor = vec4(r, g, b, a);\n    }`;
//     return gpgpu.createProgram(fragmentShaderSource);
//   }
//   exports.getRenderRGBShader = getRenderRGBShader;
//   function renderToCanvas(gpgpu, renderShader, sourceTex) {
//     webgl_util.bindCanvasToFramebuffer(gpgpu.gl);
//     renderToFramebuffer(gpgpu, renderShader, sourceTex);
//   }
//   exports.renderToCanvas = renderToCanvas;
//   function renderToFramebuffer(gpgpu, renderShader, sourceTex) {
//     gpgpu.setProgram(renderShader);
//     const sourceSamplerLocation = webgl_util.getProgramUniformLocationOrThrow(gpgpu.gl, renderShader, `source`);
//     gpgpu.setInputMatrixTexture(sourceTex, sourceSamplerLocation, 0);
//     gpgpu.executeProgram();
//   }
//   exports.renderToFramebuffer = renderToFramebuffer;
//
// }, {"./webgl_util": 86}], 78: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const ResizeBilinear3DProgram = (function () {
//     function ResizeBilinear3DProgram(inputShape, outputDimensionsRowCol, alignCorners) {
//       this.variableNames = [`A`];
//       this.outputShape = [];
//       const depth = inputShape[2];
//       this.outputShape =
//             [outputDimensionsRowCol[0], outputDimensionsRowCol[1], depth];
//       const effectiveInputShape = alignCorners ?
//             [inputShape[0] - 1, inputShape[1] - 1, depth] :
//             inputShape;
//       const effectiveOutputShape = alignCorners ?
//             [this.outputShape[0] - 1, this.outputShape[1] - 1, depth] :
//             this.outputShape;
//       this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${  effectiveInputShape[0] / effectiveOutputShape[0]  },\n          ${  effectiveInputShape[1] / effectiveOutputShape[1]  });\n      const vec2 inputShapeRC = vec2(${  inputShape[0]  }.0, ${  inputShape[1]  }.0);\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        ivec2 yRC = coords.xy;\n        int d = coords.z;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `;
//     }
//     return ResizeBilinear3DProgram;
//   }());
//   exports.ResizeBilinear3DProgram = ResizeBilinear3DProgram;
//
// }, {}], 79: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const environment_1 = require(`../../environment`);
//   const util = require(`../../util`);
//   const broadcast_util = require(`../broadcast_util`);
//   const tex_util = require(`./tex_util`);
//   const tex_util_1 = require(`./tex_util`);
//   function makeShader(inputsInfo, outputShape, userCode, broadcast) {
//     const sampleSnippet = getSampleSnippet();
//     const setOutputSnippet = getSetOutputSnippet();
//     const inputPrefixSnippet = inputsInfo.map(function (x) { return `uniform sampler2D ${  x.name  };`; }).join(`\n`);
//     const inputSamplingSnippet = inputsInfo.map(function (x) { return getInputSamplingSnippet(x, outputShape, broadcast); })
//         .join(`\n`);
//     const outTexShape = outputShape.texShape;
//     const outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
//     const source = [
//       SHADER_PREFIX, sampleSnippet, setOutputSnippet, inputPrefixSnippet,
//       outputSamplingSnippet, inputSamplingSnippet, userCode
//     ].join(`\n`);
//     return source;
//   }
//   exports.makeShader = makeShader;
//   function getSampleSnippet() {
//     return environment_1.ENV.get(`WEBGL_FLOAT_TEXTURE_ENABLED`) ?
//         FLOAT_TEXTURE_SAMPLE_SNIPPET :
//         UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET;
//   }
//   function getSetOutputSnippet() {
//     return environment_1.ENV.get(`WEBGL_FLOAT_TEXTURE_ENABLED`) ?
//         FLOAT_TEXTURE_SETOUTPUT_SNIPPET :
//         UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET;
//   }
//   function getSamplerFromInInfo(inInfo) {
//     const shape = inInfo.shapeInfo.logicalShape;
//     switch (shape.length) {
//     case 0:
//       return getSamplerScalar(inInfo);
//     case 1:
//       return getSampler1D(inInfo);
//     case 2:
//       return getSampler2D(inInfo);
//     case 3:
//       return getSampler3D(inInfo);
//     case 4:
//       return getSampler4D(inInfo);
//     default:
//       throw new Error(`${shape.length  }-D input sampling` +
//                 ` is not yet supported`);
//     }
//   }
//   function getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {
//     let res = getSamplerFlat(inInfo);
//     res += getSamplerFromInInfo(inInfo);
//     if (broadcast ||
//         util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {
//       res += getSamplerAtOutputCoords(inInfo, outShapeInfo, broadcast);
//     }
//     return res;
//   }
//   function getOutputSamplingSnippet(outShape, outTexShape) {
//     switch (outShape.length) {
//     case 0:
//       return getOutputScalarCoords();
//     case 1:
//       return getOutput1DCoords(outShape, outTexShape);
//     case 2:
//       return getOutput2DCoords(outShape, outTexShape);
//     case 3:
//       return getOutput3DCoords(outShape, outTexShape);
//     case 4:
//       return getOutput4DCoords(outShape, outTexShape);
//     default:
//       throw new Error(`${outShape.length  }-D output sampling is not yet supported`);
//     }
//   }
//   const SAMPLE_1D_SNIPPET = `\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;
//   const SAMPLE_2D_SNIPPET = `\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;
//   const SAMPLE_3D_SNIPPET = `\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;
//   const SAMPLE_4D_SNIPPET = `\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;
//   var UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET = `\n  uniform float NaN;\n\n  const vec4 floatDeltas = vec4(\n      1.0,\n      1.0 / 255.0,\n      1.0 / (255.0 * 255.0),\n      1.0 / (255.0 * 255.0 * 255.0)\n  );\n  const float minValue = ${  tex_util.FLOAT_MIN  }.0;\n  const float maxValue = ${  tex_util.FLOAT_MAX  }.0;\n  const float range = (maxValue - minValue) / 255.0;\n  const vec2 dotRange = vec2(1.0, range);\n\n  float sample(sampler2D texture, vec2 uv) {\n    vec4 sampleValue = texture2D(texture, uv);\n    if (all(equal(sampleValue, vec4(${  tex_util.BYTE_NAN_VALUE  })))) {\n      return NaN;\n    }\n\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\n    float decodedValue = dot(encValue, floatDeltas);\n    return dot(vec2(minValue, decodedValue), dotRange);\n  }\n`;
//   var UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET = `\n  const vec4 floatPowers = vec4(\n    1.0,\n    255.0,\n    255.0 * 255.0,\n    255.0 * 255.0 * 255.0\n  );\n  const vec2 recipRange = vec2(1.0/range);\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\n\n  void setOutput(float decodedValue) {\n    if (isNaN(decodedValue)) {\n      gl_FragColor = vec4(${  tex_util.BYTE_NAN_VALUE  });\n      return;\n    }\n\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\n    float b = fract(a) * 255.0;\n    float c = fract(b) * 255.0;\n    float d = fract(c) * 255.0;\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\n\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\n    // than the version below. Benchmark to determine if the accuracy is worth\n    // the cost.\n\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\n    // vec4 f = normValue * floatPowers;\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\n  }\n`;
//   var FLOAT_TEXTURE_SAMPLE_SNIPPET = `\n  float sample(sampler2D texture, vec2 uv) {\n    return texture2D(texture, uv).r;\n  }\n`;
//   var FLOAT_TEXTURE_SETOUTPUT_SNIPPET = `\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n`;
//   var SHADER_PREFIX = `\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  bool isNaN(float val) {\n    return val == val ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    return any(notEqual(values, values));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  const vec2 randomConst = vec2(\n    23.14069263277926, // e^pi (Gelfond's constant)\n     2.665144142690225 // 2^sqrt(2) (Gelfond\u2013Schneider constant)\n  );\n\n  float random(float seed) {\n      return fract(cos(dot(resultUV * seed, randomConst)) * 12345.6789);\n  }\n\n  float sampleUVAndDepth(sampler2D texture, vec2 uv, int depth) {\n    float value;\n    if (depth == 0) {\n      value = texture2D(texture, uv).r;\n    } else if (depth == 1) {\n      value = texture2D(texture, uv).g;\n    } else if (depth == 2) {\n      value = texture2D(texture, uv).b;\n    } else if (depth == 3) {\n      value = texture2D(texture, uv).a;\n    }\n    return floor(value * 255.0 + 0.5);\n  }\n\n  ${  SAMPLE_1D_SNIPPET  }\n  ${  SAMPLE_2D_SNIPPET  }\n  ${  SAMPLE_3D_SNIPPET  }\n  ${  SAMPLE_4D_SNIPPET  }\n`;
//   function getOutputScalarCoords() {
//     return `\n    int getOutputCoords() {\n      return 0;\n    }\n  `;
//   }
//   function getOutput1DCoords(shape, texShape) {
//     if (texShape[0] === 1) {
//       return `\n      int getOutputCoords() {\n        return int(resultUV.x * ${  texShape[1]  }.0);\n      }\n    `;
//     }
//     if (texShape[1] === 1) {
//       return `\n      int getOutputCoords() {\n        return int(resultUV.y * ${  texShape[0]  }.0);\n      }\n    `;
//     }
//     return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${  texShape[0]  }, ${  texShape[1]  }));\n      return resTexRC.x * ${  texShape[1]  } + resTexRC.y;\n    }\n  `;
//   }
//   function getOutput3DCoords(shape, texShape) {
//     const stride0 = shape[1] * shape[2];
//     const stride1 = shape[2];
//     return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${  texShape[0]  }, ${  texShape[1]  }));\n      int index = resTexRC.x * ${  texShape[1]  } + resTexRC.y;\n      int r = index / ${  stride0  };\n      index -= r * ${  stride0  };\n      int c = index / ${  stride1  };\n      int d = index - c * ${  stride1  };\n      return ivec3(r, c, d);\n    }\n  `;
//   }
//   function getOutput4DCoords(shape, texShape) {
//     const stride2 = shape[3];
//     const stride1 = shape[2] * stride2;
//     const stride0 = shape[1] * stride1;
//     return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${  texShape[0]  }, ${  texShape[1]  }));\n      int index = resTexRC.x * ${  texShape[1]  } + resTexRC.y;\n\n      int r = index / ${  stride0  };\n      index -= r * ${  stride0  };\n\n      int c = index / ${  stride1  };\n      index -= c * ${  stride1  };\n\n      int d = index / ${  stride2  };\n      int d2 = index - d * ${  stride2  };\n\n      return ivec4(r, c, d, d2);\n    }\n  `;
//   }
//   function getOutput2DCoords(shape, texShape) {
//     if (util.arraysEqual(shape, texShape)) {
//       return `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${  texShape[0]  }, ${  texShape[1]  }));\n      }\n    `;
//     }
//     if (shape[1] === 1) {
//       return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${  texShape[0]  }, ${  texShape[1]  }));\n        int index = resTexRC.x * ${  texShape[1]  } + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;
//     }
//     if (shape[0] === 1) {
//       return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${  texShape[0]  }, ${  texShape[1]  }));\n        int index = resTexRC.x * ${  texShape[1]  } + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;
//     }
//     return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${  texShape[0]  }, ${  texShape[1]  }));\n      int index = resTexRC.x * ${  texShape[1]  } + resTexRC.y;\n      int r = index / ${  shape[1]  };\n      int c = index - r * ${  shape[1]  };\n      return ivec2(r, c);\n    }\n  `;
//   }
//   function getSamplerScalar(inputInfo) {
//     const texName = inputInfo.name;
//     const funcName = `get${  texName.charAt(0).toUpperCase()  }${texName.slice(1)}`;
//     return `\n    float ${  funcName  }() {\n      return sample(${  texName  }, halfCR);\n    }\n  `;
//   }
//   function getSampler1D(inputInfo) {
//     const texName = inputInfo.name;
//     const funcName = `get${  texName.charAt(0).toUpperCase()  }${texName.slice(1)}`;
//     return `\n    float ${  funcName  }(int index) {\n      return ${  funcName  }Flat(index);\n    }\n  `;
//   }
//   function getSampler2D(inputInfo) {
//     const shape = inputInfo.shapeInfo.logicalShape;
//     const texShape = inputInfo.shapeInfo.texShape;
//     const texName = inputInfo.name;
//     const funcName = `get${  texName.charAt(0).toUpperCase()  }${texName.slice(1)}`;
//     const texNumR = texShape[0];
//     const texNumC = texShape[1];
//     if (util.arraysEqual(shape, texShape)) {
//       return `\n    float ${  funcName  }(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${  texNumC  }.0, ${  texNumR  }.0);\n      return sample(${  texName  }, uv);\n    }\n  `;
//     }
//     let _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
//     const squeezedShape = newShape;
//     if (squeezedShape.length < shape.length) {
//       const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
//       const params = [`row`, `col`];
//       return `\n      ${  getSamplerFromInInfo(newInputInfo)  }\n      float ${  funcName  }(int row, int col) {\n        return ${  funcName  }(${  getSqueezedParams(params, keptDims)  });\n      }\n    `;
//     }
//     if (texNumC === 1) {
//       return `\n    float ${  funcName  }(int row, int col) {\n      int index = row * ${  shape[1]  } + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / ${  texNumR  }.0);\n      return sample(${  texName  }, uv);\n    }\n  `;
//     }
//     if (texNumR === 1) {
//       return `\n    float ${  funcName  }(int row, int col) {\n      int index = row * ${  shape[1]  } + col;\n      vec2 uv = vec2((float(index) + 0.5) / ${  texNumC  }.0, 0.5);\n      return sample(${  texName  }, uv);\n    }\n  `;
//     }
//     return `\n  float ${  funcName  }(int row, int col) {\n    vec2 uv = UVfrom2D(${  texNumR  }, ${  texNumC  }, ${  shape[1]  }, row, col);\n    return sample(${  texName  }, uv);\n  }\n`;
//   }
//   function getSampler3D(inputInfo) {
//     const texShape = inputInfo.shapeInfo.texShape;
//     const shape = inputInfo.shapeInfo.logicalShape;
//     const texName = inputInfo.name;
//     const funcName = `get${  texName.charAt(0).toUpperCase()  }${texName.slice(1)}`;
//     const texNumR = texShape[0];
//     const texNumC = texShape[1];
//     const stride0 = shape[1] * shape[2];
//     const stride1 = shape[2];
//     const texType = inputInfo.shapeInfo.textureType;
//     if (texType === tex_util_1.TextureType.DEFAULT) {
//       let _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
//       const squeezedShape = newShape;
//       if (squeezedShape.length < shape.length) {
//         const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
//         const params = [`row`, `col`, `depth`];
//         return `\n        ${  getSamplerFromInInfo(newInputInfo)  }\n        float ${  funcName  }(int row, int col, int depth) {\n          return ${  funcName  }(${  getSqueezedParams(params, keptDims)  });\n        }\n      `;
//       }
//     }
//     if (texNumC === stride0) {
//       if (texType === tex_util_1.TextureType.DEFAULT) {
//         return `\n        float ${  funcName  }(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * ${  stride1  } + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${  texNumC  }.0, ${  texNumR  }.0);\n          return sample(${  texName  }, uv);\n        }\n      `;
//       }
//       else if (texType === tex_util_1.TextureType.RGBA_COLOR) {
//         return `\n        float ${  funcName  }(int row, int col, int depth) {\n          vec2 uv = (vec2(col, row) + halfCR) /\n                     vec2(${  texNumC  }.0, ${  texNumR  }.0);\n          return sampleUVAndDepth(${  texName  }, uv, depth);\n        }\n      `;
//       }
//       else {
//         throw new Error(`Unknown TextureType ${  texType  }.`);
//       }
//     }
//     if (texNumC === stride1 && texType === tex_util_1.TextureType.DEFAULT) {
//       return `\n    float ${  funcName  }(int row, int col, int depth) {\n      int texR = row * ${  shape[1]  } + col;\n      int texC = depth;\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${  texNumC  }.0, ${  texNumR  }.0);\n      return sample(${  texName  }, uv);\n    }\n  `;
//     }
//     if (texType === tex_util_1.TextureType.DEFAULT) {
//       return `\n      float ${  funcName  }(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            ${  texNumR  }, ${  texNumC  }, ${  stride0  }, ${  stride1  }, row, col, depth);\n        return sample(${  texName  }, uv);\n      }\n  `;
//     }
//     else if (texType === tex_util_1.TextureType.RGBA_COLOR) {
//       return `\n      float ${  funcName  }(int row, int col, int depth) {\n        vec2 uv = UVfrom2D(${  texNumR  }, ${  texNumC  }, ${  shape[1]  }, row, col);\n        return sampleUVAndDepth(${  texName  }, uv, depth);\n      }\n    `;
//     }
//     else {
//       throw new Error(`Unknown TextureType ${  texType  }.`);
//     }
//   }
//   function getSampler4D(inputInfo) {
//     const shape = inputInfo.shapeInfo.logicalShape;
//     const texShape = inputInfo.shapeInfo.texShape;
//     const texName = inputInfo.name;
//     const funcName = `get${  texName.charAt(0).toUpperCase()  }${texName.slice(1)}`;
//     const texNumR = texShape[0];
//     const texNumC = texShape[1];
//     const stride2 = shape[3];
//     const stride1 = shape[2] * stride2;
//     const stride0 = shape[1] * stride1;
//     let _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
//     if (newShape.length < shape.length) {
//       const newInputInfo = squeezeInputInfo(inputInfo, newShape);
//       const params = [`row`, `col`, `depth`, `depth2`];
//       return `\n      ${  getSamplerFromInInfo(newInputInfo)  }\n      float ${  funcName  }(int row, int col, int depth, int depth2) {\n        return ${  funcName  }(${  getSqueezedParams(params, keptDims)  });\n      }\n    `;
//     }
//     if (texNumC === stride0) {
//       return `\n      float ${  funcName  }(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * ${  stride1  } + depth * ${  stride2  } + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${  texNumC  }.0, ${  texNumR  }.0);\n        return sample(${  texName  }, uv);\n      }\n    `;
//     }
//     if (texNumC === stride2) {
//       return `\n      float ${  funcName  }(int row, int col, int depth, int depth2) {\n        int texR = row * ${  shape[1] * shape[2]  } + col * ${  shape[2]  } + depth;\n        int texC = depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${  texNumC  }.0, ${  texNumR  }.0);\n        return sample(${  texName  }, uv);\n      }\n    `;
//     }
//     return `\n    float ${  funcName  }(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D(${  texNumR  }, ${  texNumC  }, ${  stride0  }, ${  stride1  },\n          ${  stride2  }, row, col, depth, depth2);\n      return sample(${  texName  }, uv);\n    }\n  `;
//   }
//   function getSamplerFlat(inputInfo) {
//     const texName = inputInfo.name;
//     const texShape = inputInfo.shapeInfo.texShape;
//     const funcName = `get${  texName.charAt(0).toUpperCase()  }${texName.slice(1)  }Flat`;
//     const tNumR = texShape[0];
//     const tNumC = texShape[1];
//     if (tNumC === 1 && tNumR === 1) {
//       return `\n      float ${  funcName  }(int index) {\n        return sample(${  texName  }, halfCR);\n      }\n    `;
//     }
//     if (tNumC === 1) {
//       return `\n      float ${  funcName  }(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / ${  tNumR  }.0);\n        return sample(${  texName  }, uv);\n      }\n    `;
//     }
//     if (tNumR === 1) {
//       return `\n      float ${  funcName  }(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / ${  tNumC  }.0, 0.5);\n        return sample(${  texName  }, uv);\n      }\n    `;
//     }
//     return `\n    float ${  funcName  }(int index) {\n      vec2 uv = UVfrom1D(${  tNumR  }, ${  tNumC  }, index);\n      return sample(${  texName  }, uv);\n    }\n  `;
//   }
//   function getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName) {
//     const inRank = inputInfo.shapeInfo.logicalShape.length;
//     const outRank = outShapeInfo.logicalShape.length;
//     let type = `int`;
//     if (outRank === 2) {
//       type = `ivec2`;
//     }
//     else if (outRank === 3) {
//       type = `ivec3`;
//     }
//     else if (outRank === 4) {
//       type = `ivec4`;
//     }
//     const broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
//     const rankDiff = outRank - inRank;
//     let coordsSnippet;
//     if (inRank === 0) {
//       coordsSnippet = ``;
//     }
//     else if (outRank < 2 && broadcastDims.length >= 1) {
//       coordsSnippet = `coords = 0;`;
//     }
//     else {
//       coordsSnippet =
//             broadcastDims.map(function (d) { return `coords[${  d + rankDiff  }] = 0;`; }).join(`\n`);
//     }
//     let unpackedCoordsSnippet = ``;
//     if (outRank < 2 && inRank > 0) {
//       unpackedCoordsSnippet = `coords`;
//     }
//     else {
//       unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape
//             .map(function (s, i) { return `coords[${  i + rankDiff  }]`; })
//             .join(`, `);
//     }
//     return `\n    float ${  funcName  }() {\n      ${  type  } coords = getOutputCoords();\n      ${  coordsSnippet  }\n      return get${  texFuncSnippet  }(${  unpackedCoordsSnippet  });\n    }\n  `;
//   }
//   function getSamplerAtOutputCoords(inputInfo, outShapeInfo, supportsBroadcasting) {
//     const inTexShape = inputInfo.shapeInfo.texShape;
//     const texName = inputInfo.name;
//     const isRGBAColorTexture = inputInfo.shapeInfo.textureType === tex_util_1.TextureType.RGBA_COLOR;
//     const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
//     const funcName = `get${  texFuncSnippet  }AtOutCoords`;
//     const broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
//     const inRank = inputInfo.shapeInfo.logicalShape.length;
//     const outRank = outShapeInfo.logicalShape.length;
//     const doBroadcast = supportsBroadcasting && ((outRank > inRank) || broadcastDims.length > 0);
//     const broadcastOverOuter = broadcast_util.broadcastDimsAreOuter(broadcastDims);
//     if (doBroadcast && !broadcastOverOuter) {
//       return getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName);
//     }
//     const outTexShape = outShapeInfo.texShape;
//     if (util.arraysEqual(inTexShape, outTexShape) && !isRGBAColorTexture) {
//       return `\n      float ${  funcName  }() {\n        return sample(${  texName  }, resultUV);\n      }\n    `;
//     }
//     const inTexExpandedShape = isRGBAColorTexture ?
//         [inTexShape[0], inTexShape[1] * inputInfo.shapeInfo.logicalShape[2]] :
//         inTexShape;
//     let sampleSnippet = `return sample(${  texName  }, uv);`;
//     let rgbaColorSnippet = ``;
//     if (isRGBAColorTexture) {
//       rgbaColorSnippet = `\n      int col = texC / ${  inputInfo.shapeInfo.logicalShape[2]  };\n      int texD = texC - col * ${  inputInfo.shapeInfo.logicalShape[2]  };\n      texC = col;\n    `;
//       sampleSnippet = `return sampleUVAndDepth(${  texName  }, uv, texD);`;
//     }
//     const inSize = util.sizeFromShape(inTexExpandedShape);
//     let broadcastSnippet = ``;
//     if (doBroadcast && broadcastOverOuter) {
//       broadcastSnippet = `\n        int mainPart = index / ${  inSize  };\n        index -= mainPart * ${  inSize  };\n      `;
//     }
//     return `\n    float ${  funcName  }() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${  outTexShape[0]  }, ${  outTexShape[1]  }));\n      int index = resTexRC.x * ${  outTexShape[1]  } + resTexRC.y;\n      ${  broadcastSnippet  }\n      int texR = index / ${  inTexExpandedShape[1]  };\n      int texC = index - texR * ${  inTexExpandedShape[1]  };\n\n      ${  rgbaColorSnippet  }\n\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(${  inTexShape[1]  }.0, ${  inTexShape[0]  }.0);\n\n      ${  sampleSnippet  }\n    }\n  `;
//   }
//   function getCoordsDataType(rank) {
//     if (rank === 1) {
//       return `int`;
//     }
//     else if (rank === 2) {
//       return `ivec2`;
//     }
//     else if (rank === 3) {
//       return `ivec3`;
//     }
//     else if (rank === 4) {
//       return `ivec4`;
//     }
//     else {
//       throw Error(`GPU for rank ${  rank  } is not yet supported`);
//     }
//   }
//   exports.getCoordsDataType = getCoordsDataType;
//   function squeezeInputInfo(inInfo, squeezedShape) {
//     const newInputInfo = JSON.parse(JSON.stringify(inInfo));
//     newInputInfo.shapeInfo.logicalShape = squeezedShape;
//     return newInputInfo;
//   }
//   function getSqueezedParams(params, keptDims) {
//     return keptDims.map(function (d) { return params[d]; }).join(`, `);
//   }
//
// }, {"../../environment": 7, "../../util": 88, "../broadcast_util": 47, "./tex_util": 81}], 80: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const shader_compiler_1 = require(`./shader_compiler`);
//   const SliceProgram = (function () {
//     function SliceProgram(destSize) {
//       this.variableNames = [`source`];
//       this.outputShape = destSize;
//       this.rank = destSize.length;
//       const dtype = shader_compiler_1.getCoordsDataType(this.rank);
//       const sourceCoords = getCoords(this.rank);
//       this.userCode = `\n      uniform ${  dtype  } start;\n\n      void main() {\n        ${  dtype  } sourceLoc = start + getOutputCoords();\n        setOutput(getSource(${  sourceCoords  }));\n      }\n    `;
//     }
//     SliceProgram.prototype.getCustomSetupFunc = function (start) {
//       const _this = this;
//       if (start.length !== this.rank) {
//         throw Error(`The rank (${  this.rank  }) of the program must match the ` +
//                 `length of start (${  start.length  })`);
//       }
//       return function (gpgpu, webGLProgram) {
//         if (_this.startLoc == null) {
//           _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, `start`);
//           if (_this.startLoc == null) {
//             return;
//           }
//         }
//         if (_this.rank === 1) {
//           gpgpu.gl.uniform1i(_this.startLoc, start[0]);
//         }
//         else if (_this.rank === 2) {
//           gpgpu.gl.uniform2i(_this.startLoc, start[0], start[1]);
//         }
//         else if (_this.rank === 3) {
//           gpgpu.gl.uniform3i(_this.startLoc, start[0], start[1], start[2]);
//         }
//         else if (_this.rank === 4) {
//           gpgpu.gl.uniform4i(_this.startLoc, start[0], start[1], start[2], start[3]);
//         }
//         else {
//           throw Error(`Slicing for rank ${  _this.rank  } is not yet supported`);
//         }
//       };
//     };
//     return SliceProgram;
//   }());
//   exports.SliceProgram = SliceProgram;
//   function getCoords(rank) {
//     if (rank === 1) {
//       return `sourceLoc`;
//     }
//     else if (rank === 2) {
//       return `sourceLoc.x, sourceLoc.y`;
//     }
//     else if (rank === 3) {
//       return `sourceLoc.x, sourceLoc.y, sourceLoc.z`;
//     }
//     else if (rank === 4) {
//       return `sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w`;
//     }
//     else {
//       throw Error(`Slicing for rank ${  rank  } is not yet supported`);
//     }
//   }
//
// }, {"./shader_compiler": 79}], 81: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   let TextureType;
//   (function (TextureType) {
//     TextureType[TextureType[`DEFAULT`] = 0] = `DEFAULT`;
//     TextureType[TextureType[`RGBA_COLOR`] = 1] = `RGBA_COLOR`;
//   })(TextureType = exports.TextureType || (exports.TextureType = {}));
//   function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
//     return [columns, rows];
//   }
//   exports.getUnpackedMatrixTextureShapeWidthHeight = getUnpackedMatrixTextureShapeWidthHeight;
//   function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
//     return matrixSize * channelsPerTexture;
//   }
//   exports.getUnpackedArraySizeFromMatrixSize = getUnpackedArraySizeFromMatrixSize;
//   function getColorMatrixTextureShapeWidthHeight(rows, columns) {
//     return [columns * 4, rows];
//   }
//   exports.getColorMatrixTextureShapeWidthHeight = getColorMatrixTextureShapeWidthHeight;
//   function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
//     if (unpackedSize % channelsPerTexture !== 0) {
//       throw new Error(`unpackedSize (${  unpackedSize  }) must be a multiple of ` +
//             `${  channelsPerTexture}`);
//     }
//     return unpackedSize / channelsPerTexture;
//   }
//   exports.getMatrixSizeFromUnpackedArraySize = getMatrixSizeFromUnpackedArraySize;
//   function encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture) {
//     const requiredSize = getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture);
//     if (unpackedArray.length < requiredSize) {
//       throw new Error(`unpackedArray length (${  unpackedArray.length  }) must be >= ` +
//             `${  requiredSize}`);
//     }
//     let dst = 0;
//     for (let src = 0;src < matrix.length;++ src) {
//       unpackedArray[dst] = matrix[src];
//       dst += channelsPerTexture;
//     }
//   }
//   exports.encodeMatrixToUnpackedArray = encodeMatrixToUnpackedArray;
//   exports.FLOAT_MAX = 20000;
//   exports.FLOAT_MIN = - exports.FLOAT_MAX;
//   const FLOAT_RANGE = (exports.FLOAT_MAX - exports.FLOAT_MIN) / 255;
//   const FLOAT_DELTAS = [1, 1 / 255, 1 / (255 * 255), 1 / (255 * 255 * 255)];
//   const FLOAT_POWERS = [1, 255, 255 * 255];
//   exports.BYTE_NAN_VALUE = 0;
//   function encodeFloatArray(floatArray) {
//     const uintArray = new Uint8Array(floatArray.length * 4);
//     const _loop_1 = function (i) {
//       const value = floatArray[i / 4];
//       if (isNaN(value)) {
//         uintArray[i] = exports.BYTE_NAN_VALUE;
//         uintArray[i + 1] = exports.BYTE_NAN_VALUE;
//         uintArray[i + 2] = exports.BYTE_NAN_VALUE;
//         uintArray[i + 3] = exports.BYTE_NAN_VALUE;
//         return `continue`;
//       }
//       const normalizedValue = (value - exports.FLOAT_MIN) / FLOAT_RANGE;
//       const enc = FLOAT_POWERS.map(function (pow) { return pow * normalizedValue; });
//       const buckets = enc.map(function (value) { return Math.floor((value % 1) * 255); });
//       uintArray[i] = Math.floor(normalizedValue);
//       uintArray[i + 1] = buckets[0];
//       uintArray[i + 2] = buckets[1];
//       uintArray[i + 3] = buckets[2];
//     };
//     for (let i = 0;i < uintArray.length;i += 4) {
//       _loop_1(i);
//     }
//     return uintArray;
//   }
//   exports.encodeFloatArray = encodeFloatArray;
//   function decodeToFloatArray(uintArray) {
//     const floatArray = new Float32Array(uintArray.length / 4);
//     const _loop_2 = function (i) {
//       if (uintArray[i] === exports.BYTE_NAN_VALUE &&
//             uintArray[i + 1] === exports.BYTE_NAN_VALUE &&
//             uintArray[i + 2] === exports.BYTE_NAN_VALUE &&
//             uintArray[i + 3] === exports.BYTE_NAN_VALUE) {
//         floatArray[i / 4] = NaN;
//         return `continue`;
//       }
//       let dot = 0;
//       FLOAT_DELTAS.forEach(function (delta, j) {
//         dot += delta * uintArray[i + j];
//       });
//       const value = dot * FLOAT_RANGE + exports.FLOAT_MIN;
//       floatArray[i / 4] = value;
//     };
//     for (let i = 0;i < uintArray.length;i += 4) {
//       _loop_2(i);
//     }
//     return floatArray;
//   }
//   exports.decodeToFloatArray = decodeToFloatArray;
//   function decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture) {
//     const requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);
//     if (matrix.length < requiredSize) {
//       throw new Error(`matrix length (${  matrix.length  }) must be >= ${  requiredSize}`);
//     }
//     let dst = 0;
//     for (let src = 0;src < unpackedArray.length;src += channelsPerTexture) {
//       matrix[dst ++] = unpackedArray[src];
//     }
//   }
//   exports.decodeMatrixFromUnpackedArray = decodeMatrixFromUnpackedArray;
//   function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {
//     const requiredSize = unpackedArray.length * channels / 4;
//     if (matrix.length < requiredSize) {
//       throw new Error(`matrix length (${  matrix.length  }) must be >= ${  requiredSize}`);
//     }
//     let dst = 0;
//     for (let src = 0;src < unpackedArray.length;src += 4) {
//       for (let c = 0;c < channels;c ++) {
//         matrix[dst ++] = unpackedArray[src + c];
//       }
//     }
//   }
//   exports.decodeMatrixFromUnpackedColorRGBAArray = decodeMatrixFromUnpackedColorRGBAArray;
//   function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
//     return [Math.ceil(columns / 2), Math.ceil(rows / 2)];
//   }
//   exports.getPackedMatrixTextureShapeWidthHeight = getPackedMatrixTextureShapeWidthHeight;
//   function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
//     let _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
//     return w * h * 4;
//   }
//   exports.getPackedRGBAArraySizeFromMatrixShape = getPackedRGBAArraySizeFromMatrixShape;
//   function encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA) {
//     const requiredSize = getPackedRGBAArraySizeFromMatrixShape(rows, columns);
//     if (packedRGBA.length < requiredSize) {
//       throw new Error(`packedRGBA length (${  packedRGBA.length  }) must be >= ${  requiredSize}`);
//     }
//     let _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
//     const oddWidth = (columns % 2) === 1;
//     const oddHeight = (rows % 2) === 1;
//     const widthInFullBlocks = Math.floor(columns / 2);
//     const heightInFullBlocks = Math.floor(rows / 2);
//     {
//       var dstStride = (oddWidth ? 4 : 0);
//       const oneRow = columns;
//       var dst = 0;
//       for (var blockY = 0;blockY < heightInFullBlocks;++ blockY) {
//         const matrixSrcRow = (blockY * 2 * columns);
//         for (var blockX = 0;blockX < widthInFullBlocks;++ blockX) {
//           const matrixSrcCol = blockX * 2;
//           var src = matrixSrcRow + matrixSrcCol;
//           packedRGBA[dst] = matrix[src];
//           packedRGBA[dst + 1] = matrix[src + 1];
//           packedRGBA[dst + 2] = matrix[src + oneRow];
//           packedRGBA[dst + 3] = matrix[src + oneRow + 1];
//           dst += 4;
//         }
//         dst += dstStride;
//       }
//     }
//     if (oddWidth) {
//       var src = columns - 1;
//       var dst = (textureWidth - 1) * 4;
//       const srcStride = 2 * columns;
//       var dstStride = textureWidth * 4;
//       for (var blockY = 0;blockY < heightInFullBlocks;++ blockY) {
//         packedRGBA[dst] = matrix[src];
//         packedRGBA[dst + 2] = matrix[src + columns];
//         src += srcStride;
//         dst += dstStride;
//       }
//     }
//     if (oddHeight) {
//       var src = (rows - 1) * columns;
//       var dst = (textureHeight - 1) * textureWidth * 4;
//       for (var blockX = 0;blockX < widthInFullBlocks;++ blockX) {
//         packedRGBA[dst ++] = matrix[src ++];
//         packedRGBA[dst ++] = matrix[src ++];
//         dst += 2;
//       }
//     }
//     if (oddWidth && oddHeight) {
//       packedRGBA[packedRGBA.length - 4] = matrix[matrix.length - 1];
//     }
//     return packedRGBA;
//   }
//   exports.encodeMatrixToPackedRGBA = encodeMatrixToPackedRGBA;
//   function decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix) {
//     const requiredSize = rows * columns;
//     if (requiredSize < matrix.length) {
//       throw new Error(`matrix length (${  matrix.length  }) must be >= ${  requiredSize}`);
//     }
//     const oddWidth = (columns % 2) === 1;
//     const oddHeight = (rows % 2) === 1;
//     const widthInFullBlocks = Math.floor(columns / 2);
//     const heightInFullBlocks = Math.floor(rows / 2);
//     let _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
//     {
//       var srcStride = oddWidth ? 4 : 0;
//       var dstStride = columns + (oddWidth ? 1 : 0);
//       var src = 0;
//       let dstRow1 = 0;
//       let dstRow2 = columns;
//       for (var blockY = 0;blockY < heightInFullBlocks;++ blockY) {
//         for (var blockX = 0;blockX < widthInFullBlocks;++ blockX) {
//           matrix[dstRow1 ++] = packedRGBA[src ++];
//           matrix[dstRow1 ++] = packedRGBA[src ++];
//           matrix[dstRow2 ++] = packedRGBA[src ++];
//           matrix[dstRow2 ++] = packedRGBA[src ++];
//         }
//         src += srcStride;
//         dstRow1 += dstStride;
//         dstRow2 += dstStride;
//       }
//     }
//     if (oddWidth) {
//       var src = (textureWidth - 1) * 4;
//       var dst = columns - 1;
//       var srcStride = textureWidth * 4;
//       var dstStride = 2 * columns;
//       for (var blockY = 0;blockY < heightInFullBlocks;++ blockY) {
//         matrix[dst] = packedRGBA[src];
//         matrix[dst + columns] = packedRGBA[src + 2];
//         src += srcStride;
//         dst += dstStride;
//       }
//     }
//     if (oddHeight) {
//       var src = (textureHeight - 1) * textureWidth * 4;
//       var dst = (rows - 1) * columns;
//       for (var blockX = 0;blockX < widthInFullBlocks;++ blockX) {
//         matrix[dst ++] = packedRGBA[src ++];
//         matrix[dst ++] = packedRGBA[src ++];
//         src += 2;
//       }
//     }
//     if (oddWidth && oddHeight) {
//       matrix[matrix.length - 1] = packedRGBA[packedRGBA.length - 4];
//     }
//     return matrix;
//   }
//   exports.decodeMatrixFromPackedRGBA = decodeMatrixFromPackedRGBA;
//
// }, {}], 82: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const TextureManager = (function () {
//     function TextureManager(gpgpu) {
//       this.gpgpu = gpgpu;
//       this.numUsedTextures = 0;
//       this.numFreeTextures = 0;
//       this.freeTextures = {};
//       this.logEnabled = false;
//       this.usedTextureCount = {};
//     }
//     TextureManager.prototype.acquireTexture = function (shapeRC) {
//       const shapeKey = getKeyFromTextureShape(shapeRC);
//       if (!(shapeKey in this.freeTextures)) {
//         this.freeTextures[shapeKey] = [];
//       }
//       if (!(shapeKey in this.usedTextureCount)) {
//         this.usedTextureCount[shapeKey] = 0;
//       }
//       this.usedTextureCount[shapeKey]++;
//       if (this.freeTextures[shapeKey].length > 0) {
//         this.numFreeTextures--;
//         this.numUsedTextures++;
//         this.log();
//         return this.freeTextures[shapeKey].shift();
//       }
//       this.numUsedTextures++;
//       this.log();
//       return this.gpgpu.createMatrixTexture(shapeRC[0], shapeRC[1]);
//     };
//     TextureManager.prototype.releaseTexture = function (texture, shape) {
//       const shapeKey = getKeyFromTextureShape(shape);
//       if (!(shapeKey in this.freeTextures)) {
//         this.freeTextures[shapeKey] = [];
//       }
//       this.freeTextures[shapeKey].push(texture);
//       this.numFreeTextures++;
//       this.numUsedTextures--;
//       this.usedTextureCount[shapeKey]--;
//       this.log();
//     };
//     TextureManager.prototype.log = function () {
//       if (!this.logEnabled) {
//         return;
//       }
//       const total = this.numFreeTextures + this.numUsedTextures;
//       console.log(`Free/Used`, `${this.numFreeTextures  } / ${  this.numUsedTextures}`, `(${  total  })`);
//     };
//     TextureManager.prototype.getNumUsedTextures = function () {
//       return this.numUsedTextures;
//     };
//     TextureManager.prototype.getNumFreeTextures = function () {
//       return this.numFreeTextures;
//     };
//     TextureManager.prototype.dispose = function () {
//       for (const shape in this.freeTextures) {
//         if (this.freeTextures.hasOwnProperty(shape)) {
//           for (let i = 0;i < this.freeTextures[shape].length;i ++) {
//             this.gpgpu.deleteMatrixTexture(this.freeTextures[shape][i]);
//           }
//         }
//       }
//     };
//     return TextureManager;
//   }());
//   exports.TextureManager = TextureManager;
//   function getKeyFromTextureShape(shapeRowsCol) {
//     return `${shapeRowsCol[0]  }_${  shapeRowsCol[1]}`;
//   }
//
// }, {}], 83: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const shader_compiler_1 = require(`./shader_compiler`);
//   const TileProgram = (function () {
//     function TileProgram(aShape, reps) {
//       this.variableNames = [`A`];
//       const outputShape = new Array(aShape.length);
//       for (let i = 0;i < outputShape.length;i ++) {
//         outputShape[i] = aShape[i] * reps[i];
//       }
//       this.outputShape = outputShape;
//       this.rank = outputShape.length;
//       const dtype = shader_compiler_1.getCoordsDataType(this.rank);
//       const sourceCoords = getSourceCoords(aShape);
//       this.userCode = `\n      void main() {\n        ${  dtype  } resRC = getOutputCoords();\n        setOutput(getA(${  sourceCoords  }));\n      }\n    `;
//     }
//     return TileProgram;
//   }());
//   exports.TileProgram = TileProgram;
//   function getSourceCoords(aShape) {
//     const rank = aShape.length;
//     if (rank > 4) {
//       throw Error(`Tile for rank ${  rank  } is not yet supported`);
//     }
//     if (rank === 1) {
//       return `imod(resRC, ${  aShape[0]  })`;
//     }
//     const currentCoords = [`resRC.x`, `resRC.y`, `resRC.z`, `resRC.w`];
//     const sourceCoords = [];
//     for (let i = 0;i < aShape.length;i ++) {
//       sourceCoords.push(`imod(${  currentCoords[i]  }, ${  aShape[i]  })`);
//     }
//     return sourceCoords.join();
//   }
//
// }, {"./shader_compiler": 79}], 84: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const shader_compiler_1 = require(`./shader_compiler`);
//   const TransposeProgram = (function () {
//     function TransposeProgram(aShape, newDim) {
//       this.variableNames = [`A`];
//       const outputShape = new Array(aShape.length);
//       for (let i = 0;i < outputShape.length;i ++) {
//         outputShape[i] = aShape[newDim[i]];
//       }
//       this.outputShape = outputShape;
//       this.rank = outputShape.length;
//       const dtype = shader_compiler_1.getCoordsDataType(this.rank);
//       const switched = getSwitchedCoords(newDim);
//       this.userCode = `\n    void main() {\n      ${  dtype  } resRC = getOutputCoords();\n      setOutput(getA(${  switched  }));\n    }\n    `;
//     }
//     return TransposeProgram;
//   }());
//   exports.TransposeProgram = TransposeProgram;
//   function getSwitchedCoords(newDim) {
//     const rank = newDim.length;
//     if (rank > 4) {
//       throw Error(`Transpose for rank ${  rank  } is not yet supported`);
//     }
//     const originalOrder = [`resRC.x`, `resRC.y`, `resRC.z`, `resRC.w`];
//     const switchedCoords = new Array(rank);
//     for (let i = 0;i < newDim.length;i ++) {
//       switchedCoords[newDim[i]] = originalOrder[i];
//     }
//     return switchedCoords.join();
//   }
//
// }, {"./shader_compiler": 79}], 85: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const UnaryOpProgram = (function () {
//     function UnaryOpProgram(aShape, opSnippet) {
//       this.variableNames = [`A`];
//       this.outputShape = aShape;
//       this.userCode = `\n      float unaryOperation(float x) {\n        ${  opSnippet  }\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;
//     }
//     return UnaryOpProgram;
//   }());
//   exports.UnaryOpProgram = UnaryOpProgram;
//   exports.CHECK_NAN_SNIPPET = `\n  if (isNaN(x)) {\n    return x;\n  }\n`;
//   exports.ABS = `\n  return abs(x);\n`;
//   exports.RELU = `\n  return (x < 0.0) ? 0.0 : x;\n`;
//   exports.ELU = `\n  return (x >= 0.0) ? x : (exp(x) - 1.0);\n`;
//   function LEAKY_RELU(alpha) {
//     return `\n    return (x >= 0.0) ? x : ${  alpha  } * x;\n  `;
//   }
//   exports.LEAKY_RELU = LEAKY_RELU;
//   function STEP(alpha) {
//     if (alpha === void 0) { alpha = 0.0; }
//     return `\n    return (x == x) ? (x > 0.0 ? 1.0 : float(${  alpha  })) : x;\n  `;
//   }
//   exports.STEP = STEP;
//   exports.NEG = `\n  return -x;\n`;
//   exports.CEIL = `\n  return ceil(x);\n`;
//   exports.FLOOR = `\n  return floor(x);\n`;
//   exports.EXP = `\n  return exp(x);\n`;
//   exports.LOG = `\n  return log(x);\n`;
//   exports.SQRT = `${exports.CHECK_NAN_SNIPPET  }\n  return sqrt(x);\n`;
//   exports.SIGMOID = `\n  return 1.0 / (1.0 + exp(-1.0 * x));\n`;
//   exports.SIN = `${exports.CHECK_NAN_SNIPPET  }\n  return sin(x);\n`;
//   exports.COS = `${exports.CHECK_NAN_SNIPPET  }\n  return cos(x);\n`;
//   exports.TAN = `\n  return tan(x);\n`;
//   exports.ASIN = `${exports.CHECK_NAN_SNIPPET  }\n  return asin(x);\n`;
//   exports.ACOS = `${exports.CHECK_NAN_SNIPPET  }\n  return acos(x);\n`;
//   exports.ATAN = `${exports.CHECK_NAN_SNIPPET  }\n  return atan(x);\n`;
//   exports.SINH = `\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n`;
//   exports.COSH = `\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n`;
//   exports.TANH = `\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n`;
//   exports.SQUARE = `\n  return x * x;\n`;
//
// }, {}], 86: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   let MAX_TEXTURE_SIZE = null;
//   const util = require(`../../util`);
//   const environment_1 = require(`../../environment`);
//   function createWebGLRenderingContext(attributes) {
//     const canvas = document.createElement(`canvas`);
//     canvas.width = 1;
//     canvas.height = 1;
//     return createWebGLRenderingContextFromCanvas(canvas, attributes);
//   }
//   exports.createWebGLRenderingContext = createWebGLRenderingContext;
//   function createWebGLRenderingContextFromCanvas(canvas, attributes) {
//     let gl;
//     const webglVersion = environment_1.ENV.get(`WEBGL_VERSION`);
//     if (webglVersion === 2) {
//       gl = canvas.getContext(`webgl2`, attributes);
//     }
//     else if (webglVersion === 1) {
//       gl = (canvas.getContext(`webgl`, attributes) ||
//             canvas.getContext(`experimental-webgl`, attributes));
//     }
//     if (webglVersion === 0 || gl == null) {
//       throw new Error(`This browser does not support WebGL.`);
//     }
//     return gl;
//   }
//   exports.createWebGLRenderingContextFromCanvas = createWebGLRenderingContextFromCanvas;
//   function callAndCheck(gl, func) {
//     const returnValue = func();
//     checkWebGLError(gl);
//     return returnValue;
//   }
//   exports.callAndCheck = callAndCheck;
//   let webGLDebugErrorCheckingEnabled = false;
//   function enableDebugWebGLErrorChecking(enabled) {
//     webGLDebugErrorCheckingEnabled = enabled;
//   }
//   exports.enableDebugWebGLErrorChecking = enableDebugWebGLErrorChecking;
//   function checkWebGLError(gl) {
//     if (webGLDebugErrorCheckingEnabled) {
//       const error = gl.getError();
//       if (error !== gl.NO_ERROR) {
//         throw new Error(`WebGL Error: ${  getWebGLErrorMessage(gl, error)}`);
//       }
//     }
//   }
//   exports.checkWebGLError = checkWebGLError;
//   function getWebGLErrorMessage(gl, status) {
//     switch (status) {
//     case gl.NO_ERROR:
//       return `NO_ERROR`;
//     case gl.INVALID_ENUM:
//       return `INVALID_ENUM`;
//     case gl.INVALID_VALUE:
//       return `INVALID_VALUE`;
//     case gl.INVALID_OPERATION:
//       return `INVALID_OPERATION`;
//     case gl.INVALID_FRAMEBUFFER_OPERATION:
//       return `INVALID_FRAMEBUFFER_OPERATION`;
//     case gl.OUT_OF_MEMORY:
//       return `OUT_OF_MEMORY`;
//     case gl.CONTEXT_LOST_WEBGL:
//       return `CONTEXT_LOST_WEBGL`;
//     default:
//       return `Unknown error code ${  status}`;
//     }
//   }
//   exports.getWebGLErrorMessage = getWebGLErrorMessage;
//   function getExtensionOrThrow(gl, extensionName) {
//     return throwIfNull(gl, function () { return gl.getExtension(extensionName); }, `Extension "${  extensionName  }" not supported on this browser.`);
//   }
//   exports.getExtensionOrThrow = getExtensionOrThrow;
//   function createVertexShader(gl, vertexShaderSource) {
//     const vertexShader = throwIfNull(gl, function () { return gl.createShader(gl.VERTEX_SHADER); }, `Unable to create vertex WebGLShader.`);
//     callAndCheck(gl, function () { return gl.shaderSource(vertexShader, vertexShaderSource); });
//     callAndCheck(gl, function () { return gl.compileShader(vertexShader); });
//     if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
//       console.log(gl.getShaderInfoLog(vertexShader));
//       throw new Error(`Failed to compile vertex shader.`);
//     }
//     return vertexShader;
//   }
//   exports.createVertexShader = createVertexShader;
//   function createFragmentShader(gl, fragmentShaderSource) {
//     const fragmentShader = throwIfNull(gl, function () { return gl.createShader(gl.FRAGMENT_SHADER); }, `Unable to create fragment WebGLShader.`);
//     callAndCheck(gl, function () { return gl.shaderSource(fragmentShader, fragmentShaderSource); });
//     callAndCheck(gl, function () { return gl.compileShader(fragmentShader); });
//     if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
//       logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
//       throw new Error(`Failed to compile fragment shader.`);
//     }
//     return fragmentShader;
//   }
//   exports.createFragmentShader = createFragmentShader;
//   const lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
//   function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
//     const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
//     if (lineNumberRegexResult == null) {
//       console.log(`Couldn't parse line number in error: ${  shaderInfoLog}`);
//       console.log(shaderSource);
//       return;
//     }
//     const lineNumber = + lineNumberRegexResult[1];
//     const shaderLines = shaderSource.split(`\n`);
//     const pad = shaderLines.length.toString().length + 2;
//     const linesWithLineNumbers = shaderLines.map(function (line, lineNumber) {
//       return util.rightPad((lineNumber + 1).toString(), pad) + line;
//     });
//     let maxLineLength = 0;
//     for (let i = 0;i < linesWithLineNumbers.length;i ++) {
//       maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
//     }
//     const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
//     const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
//     const afterErrorLines = linesWithLineNumbers.slice(lineNumber);
//     console.log(beforeErrorLines.join(`\n`));
//     console.log(shaderInfoLog.split(`\n`)[0]);
//     console.log(`%c ${  util.rightPad(errorLine[0], maxLineLength)}`, `border:1px solid red; background-color:#e3d2d2; color:#a61717`);
//     console.log(afterErrorLines.join(`\n`));
//   }
//   function createProgram(gl) {
//     return throwIfNull(gl, function () { return gl.createProgram(); }, `Unable to create WebGLProgram.`);
//   }
//   exports.createProgram = createProgram;
//   function linkProgram(gl, program) {
//     callAndCheck(gl, function () { return gl.linkProgram(program); });
//     if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
//       console.log(gl.getProgramInfoLog(program));
//       throw new Error(`Failed to link vertex and fragment shaders.`);
//     }
//   }
//   exports.linkProgram = linkProgram;
//   function validateProgram(gl, program) {
//     callAndCheck(gl, function () { return gl.validateProgram(program); });
//     if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
//       console.log(gl.getProgramInfoLog(program));
//       throw new Error(`Shader program validation failed.`);
//     }
//   }
//   exports.validateProgram = validateProgram;
//   function createStaticVertexBuffer(gl, data) {
//     const buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, `Unable to create WebGLBuffer`);
//     callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
//     callAndCheck(gl, function () { return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); });
//     return buffer;
//   }
//   exports.createStaticVertexBuffer = createStaticVertexBuffer;
//   function createStaticIndexBuffer(gl, data) {
//     const buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, `Unable to create WebGLBuffer`);
//     callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); });
//     callAndCheck(gl, function () { return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); });
//     return buffer;
//   }
//   exports.createStaticIndexBuffer = createStaticIndexBuffer;
//   function queryMaxTextureSize(gl) {
//     if (MAX_TEXTURE_SIZE != null) {
//       return MAX_TEXTURE_SIZE;
//     }
//     MAX_TEXTURE_SIZE =
//         callAndCheck(gl, function () { return gl.getParameter(gl.MAX_TEXTURE_SIZE); });
//     return MAX_TEXTURE_SIZE;
//   }
//   exports.queryMaxTextureSize = queryMaxTextureSize;
//   function getChannelsPerTexture() {
//     if (!environment_1.ENV.get(`WEBGL_FLOAT_TEXTURE_ENABLED`)) {
//       return 4;
//     }
//     if (environment_1.ENV.get(`WEBGL_VERSION`) === 2) {
//       return 1;
//     }
//     return 4;
//   }
//   exports.getChannelsPerTexture = getChannelsPerTexture;
//   function createTexture(gl) {
//     return throwIfNull(gl, function () { return gl.createTexture(); }, `Unable to create WebGLTexture.`);
//   }
//   exports.createTexture = createTexture;
//   function validateTextureSize(gl, width, height) {
//     const maxTextureSize = queryMaxTextureSize(gl);
//     if ((width <= 0) || (height <= 0)) {
//       var requested = `[${  width  }x${  height  }]`;
//       throw new Error(`Requested texture size ${  requested  } is invalid.`);
//     }
//     if ((width > maxTextureSize) || (height > maxTextureSize)) {
//       var requested = `[${  width  }x${  height  }]`;
//       const max = `[${  maxTextureSize  }x${  maxTextureSize  }]`;
//       throw new Error(`Requested texture size ${  requested
//             } greater than WebGL maximum on this browser / GPU ${  max  }.`);
//     }
//   }
//   exports.validateTextureSize = validateTextureSize;
//   function createFramebuffer(gl) {
//     return throwIfNull(gl, function () { return gl.createFramebuffer(); }, `Unable to create WebGLFramebuffer.`);
//   }
//   exports.createFramebuffer = createFramebuffer;
//   function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes, attribLocations) {
//     let loc = - 1;
//     if ((attribLocations != null) && (attribute in attribLocations)) {
//       loc = attribLocations[attribute];
//     }
//     else {
//       loc = gl.getAttribLocation(program, attribute);
//     }
//     if (loc === - 1) {
//       return;
//     }
//     callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
//     callAndCheck(gl, function () { return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes); });
//     callAndCheck(gl, function () { return gl.enableVertexAttribArray(loc); });
//   }
//   exports.bindVertexBufferToProgramAttribute = bindVertexBufferToProgramAttribute;
//   function bindTextureUnit(gl, texture, textureUnit) {
//     validateTextureUnit(gl, textureUnit);
//     callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
//     callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
//   }
//   exports.bindTextureUnit = bindTextureUnit;
//   function unbindTextureUnit(gl, textureUnit) {
//     validateTextureUnit(gl, textureUnit);
//     callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
//     callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
//   }
//   exports.unbindTextureUnit = unbindTextureUnit;
//   function getProgramUniformLocationOrThrow(gl, program, uniformName) {
//     return throwIfNull(gl, function () { return gl.getUniformLocation(program, uniformName); }, `uniform "${  uniformName  }" not present in program.`);
//   }
//   exports.getProgramUniformLocationOrThrow = getProgramUniformLocationOrThrow;
//   function bindTextureToProgramUniformSampler(gl, program, texture, uniformSamplerLocation, textureUnit) {
//     callAndCheck(gl, function () { return bindTextureUnit(gl, texture, textureUnit); });
//     callAndCheck(gl, function () { return gl.uniform1i(uniformSamplerLocation, textureUnit); });
//   }
//   exports.bindTextureToProgramUniformSampler = bindTextureToProgramUniformSampler;
//   function bindCanvasToFramebuffer(gl) {
//     callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
//     callAndCheck(gl, function () { return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); });
//     callAndCheck(gl, function () { return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height); });
//   }
//   exports.bindCanvasToFramebuffer = bindCanvasToFramebuffer;
//   function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
//     callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
//     callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); });
//   }
//   exports.bindColorTextureToFramebuffer = bindColorTextureToFramebuffer;
//   function unbindColorTextureFromFramebuffer(gl, framebuffer) {
//     callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
//     callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0); });
//   }
//   exports.unbindColorTextureFromFramebuffer = unbindColorTextureFromFramebuffer;
//   function validateFramebuffer(gl) {
//     const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
//     if (status !== gl.FRAMEBUFFER_COMPLETE) {
//       throw new Error(`Error binding framebuffer: ${  getFramebufferErrorMessage(gl, status)}`);
//     }
//   }
//   exports.validateFramebuffer = validateFramebuffer;
//   function getFramebufferErrorMessage(gl, status) {
//     switch (status) {
//     case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
//       return `FRAMEBUFFER_INCOMPLETE_ATTACHMENT`;
//     case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
//       return `FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT`;
//     case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
//       return `FRAMEBUFFER_INCOMPLETE_DIMENSIONS`;
//     case gl.FRAMEBUFFER_UNSUPPORTED:
//       return `FRAMEBUFFER_UNSUPPORTED`;
//     default:
//       return `unknown error ${  status}`;
//     }
//   }
//   exports.getFramebufferErrorMessage = getFramebufferErrorMessage;
//   function throwIfNull(gl, returnTOrNull, failureMessage) {
//     const tOrNull = callAndCheck(gl, function () { return returnTOrNull(); });
//     if (tOrNull == null) {
//       throw new Error(failureMessage);
//     }
//     return tOrNull;
//   }
//   function validateTextureUnit(gl, textureUnit) {
//     const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
//     const glTextureUnit = textureUnit + gl.TEXTURE0;
//     if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
//       const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${  maxTextureUnit  }]`;
//       throw new Error(`textureUnit must be in ${  textureUnitRange  }.`);
//     }
//   }
//   function getTextureShapeFromLogicalShape(gl, logShape) {
//     if (logShape.length !== 2) {
//       const squeezeResult = util.squeezeShape(logShape);
//       logShape = squeezeResult.newShape;
//     }
//     const maxTexSize = queryMaxTextureSize(gl);
//     const size = util.sizeFromShape(logShape);
//     if (logShape.length <= 1 && size <= maxTexSize) {
//       return [size, 1];
//     }
//     else if (logShape.length === 2 && logShape[0] <= maxTexSize &&
//         logShape[1] <= maxTexSize) {
//       return logShape;
//     }
//     else if (logShape.length === 3 && logShape[0] <= maxTexSize &&
//         logShape[1] * logShape[2] <= maxTexSize) {
//       return [logShape[0], logShape[1] * logShape[2]];
//     }
//     else if (logShape.length === 4 && logShape[0] <= maxTexSize &&
//         logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
//       return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
//     }
//     else {
//       return util.sizeToSquarishShape(size);
//     }
//   }
//   exports.getTextureShapeFromLogicalShape = getTextureShapeFromLogicalShape;
//
// }, {"../../environment": 7, "../../util": 88}], 87: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const environment = require(`./environment`);
//   const environment_1 = require(`./environment`);
//   const math_cpu_1 = require(`./math/math_cpu`);
//   const math_gpu_1 = require(`./math/math_gpu`);
//   const util = require(`./util`);
//   exports.TEST_EPSILON = 1e-2;
//   function mean(values) {
//     let sum = 0;
//     for (let i = 0;i < values.length;i ++) {
//       sum += values[i];
//     }
//     return sum / values.length;
//   }
//   exports.mean = mean;
//   function standardDeviation(values, mean) {
//     let squareDiffSum = 0;
//     for (let i = 0;i < values.length;i ++) {
//       const diff = values[i] - mean;
//       squareDiffSum += diff * diff;
//     }
//     return Math.sqrt(squareDiffSum / values.length);
//   }
//   exports.standardDeviation = standardDeviation;
//   function kurtosis(values) {
//     const valuesMean = mean(values);
//     const n = values.length;
//     let sum2 = 0;
//     let sum4 = 0;
//     for (let i = 0;i < n;i ++) {
//       const v = values[i] - valuesMean;
//       sum2 += Math.pow(v, 2);
//       sum4 += Math.pow(v, 4);
//     }
//     return (1 / n) * sum4 / Math.pow((1 / n) * sum2, 2) - 3;
//   }
//   exports.kurtosis = kurtosis;
//   function skewness(values) {
//     const valuesMean = mean(values);
//     const n = values.length;
//     let sum2 = 0;
//     let sum3 = 0;
//     let i = - 1;
//     while (++ i < n) {
//       const v = values[i] - valuesMean;
//       sum2 += Math.pow(v, 2);
//       sum3 += Math.pow(v, 3);
//     }
//     return (1 / n) * sum3 / Math.pow((1 / (n - 1)) * sum2, 3 / 2);
//   }
//   exports.skewness = skewness;
//   function jarqueBeraNormalityTest(values) {
//     const s = skewness(values);
//     const k = kurtosis(values);
//     const jb = values.length * ((Math.pow(s, 2) / 6) + (Math.pow(k, 2) / 24));
//     const CHI_SQUARE_2DEG = 5.991;
//     if (jb > CHI_SQUARE_2DEG) {
//       throw new Error(`Invalid p-value for JB: ${  jb}`);
//     }
//   }
//   exports.jarqueBeraNormalityTest = jarqueBeraNormalityTest;
//   function expectArrayInMeanStdRange(actual, expectedMean, expectedStdDev, epsilon) {
//     if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
//     const actualMean = mean(actual);
//     expectNumbersClose(actualMean, expectedMean, epsilon);
//     expectNumbersClose(standardDeviation(actual, actualMean), expectedStdDev, epsilon);
//   }
//   exports.expectArrayInMeanStdRange = expectArrayInMeanStdRange;
//   function expectArraysClose(actual, expected, epsilon) {
//     if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
//     const aType = actual.constructor.name;
//     const bType = expected.constructor.name;
//     if (aType !== bType) {
//       throw new Error(`Arrays are of different type ${  aType  } vs ${  bType}`);
//     }
//     if (actual.length !== expected.length) {
//       throw new Error(`Matrices have different lengths (${  actual.length  } vs ${
//             expected.length  }).`);
//     }
//     for (let i = 0;i < expected.length;++ i) {
//       const a = actual[i];
//       const e = expected[i];
//       if (!areClose(a, e, epsilon)) {
//         const actualStr = `actual[${  i  }] === ${  a}`;
//         const expectedStr = `expected[${  i  }] === ${  e}`;
//         throw new Error(`Arrays differ: ${  actualStr  }, ${  expectedStr}`);
//       }
//     }
//   }
//   exports.expectArraysClose = expectArraysClose;
//   function expectNumbersClose(a, e, epsilon) {
//     if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
//     if (!areClose(a, e, epsilon)) {
//       throw new Error(`Numbers differ: actual === ${  a  }, expected === ${  e}`);
//     }
//   }
//   exports.expectNumbersClose = expectNumbersClose;
//   function areClose(a, e, epsilon) {
//     if (isNaN(a) && isNaN(e)) {
//       return true;
//     }
//     if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
//       return false;
//     }
//     return true;
//   }
//   function expectValuesInRange(actual, low, high) {
//     for (let i = 0;i < actual.length;i ++) {
//       if (actual[i] < low || actual[i] > high) {
//         throw new Error(`Value out of range:${  actual[i]  } low: ${  low  }, high: ${  high}`);
//       }
//     }
//   }
//   exports.expectValuesInRange = expectValuesInRange;
//   function randomArrayInRange(n, minValue, maxValue) {
//     const v = new Float32Array(n);
//     const range = maxValue - minValue;
//     for (let i = 0;i < n;++ i) {
//       v[i] = (Math.random() * range) + minValue;
//     }
//     return v;
//   }
//   exports.randomArrayInRange = randomArrayInRange;
//   function makeIdentity(n) {
//     const i = new Float32Array(n * n);
//     for (let j = 0;j < n;++ j) {
//       i[(j * n) + j] = 1;
//     }
//     return i;
//   }
//   exports.makeIdentity = makeIdentity;
//   function cpuMultiplyMatrix(a, aRow, aCol, b, bRow, bCol) {
//     const result = new Float32Array(aRow * bCol);
//     for (let r = 0;r < aRow;++ r) {
//       const aOffset = (r * aCol);
//       const cOffset = (r * bCol);
//       for (let c = 0;c < bCol;++ c) {
//         let d = 0;
//         for (let k = 0;k < aCol;++ k) {
//           d += a[aOffset + k] * b[(k * bCol) + c];
//         }
//         result[cOffset + c] = d;
//       }
//     }
//     return result;
//   }
//   exports.cpuMultiplyMatrix = cpuMultiplyMatrix;
//   function cpuDotProduct(a, b) {
//     if (a.length !== b.length) {
//       throw new Error(`cpuDotProduct: incompatible vectors.`);
//     }
//     let d = 0;
//     for (let i = 0;i < a.length;++ i) {
//       d += a[i] * b[i];
//     }
//     return d;
//   }
//   exports.cpuDotProduct = cpuDotProduct;
//   function describeMathCPU(name, tests, featuresList) {
//     const testNameBase = `math_cpu.${  name}`;
//     describeWithFeaturesAndExecutor(testNameBase, tests, function (testName, tests, features) { return executeMathTests(testName, tests, function () { return new math_cpu_1.NDArrayMathCPU(); }, features); }, featuresList);
//   }
//   exports.describeMathCPU = describeMathCPU;
//   function describeMathGPU(name, tests, featuresList) {
//     const testNameBase = `math_gpu.${  name}`;
//     describeWithFeaturesAndExecutor(testNameBase, tests, function (testName, tests, features) { return executeMathTests(testName, tests, function () { return new math_gpu_1.NDArrayMathGPU(); }, features); }, featuresList);
//   }
//   exports.describeMathGPU = describeMathGPU;
//   function describeCustom(name, tests, featuresList, customBeforeEach, customAfterEach) {
//     describeWithFeaturesAndExecutor(name, [tests], function (testName, tests, features) { return executeTests(testName, tests, features, customBeforeEach, customAfterEach); }, featuresList);
//   }
//   exports.describeCustom = describeCustom;
//   function describeWithFeaturesAndExecutor(testNameBase, tests, executor, featuresList) {
//     if (featuresList != null) {
//       featuresList.forEach(function (features) {
//         const testName = `${testNameBase  } ${  JSON.stringify(features)}`;
//         executor(testName, tests, features);
//       });
//     }
//     else {
//       executor(testNameBase, tests);
//     }
//   }
//   const PROMISE_IT = function (name, testFunc) {
//     it(name, function (done) {
//       const result = testFunc();
//       if (result instanceof Promise) {
//         result.then(done, function (e) {
//           fail(e);
//           done();
//         });
//       }
//       else {
//         done();
//       }
//     });
//   };
//   function executeMathTests(testName, tests, mathFactory, features) {
//     let math;
//     const customBeforeEach = function () {
//       math = mathFactory();
//       math.startScope();
//     };
//     const customAfterEach = function () {
//       math.endScope(null);
//       math.dispose();
//     };
//     const customIt = function (name, testFunc) {
//       PROMISE_IT(name, function () { return testFunc(math); });
//     };
//     executeTests(testName, tests, features, customBeforeEach, customAfterEach, customIt);
//   }
//   exports.executeMathTests = executeMathTests;
//   function executeTests(testName, tests, features, customBeforeEach, customAfterEach, customIt) {
//     if (customIt === void 0) { customIt = PROMISE_IT; }
//     describe(testName, function () {
//       beforeEach(function () {
//         if (features != null) {
//           environment.setEnvironment(new environment_1.Environment(features));
//         }
//         if (customBeforeEach != null) {
//           customBeforeEach();
//         }
//       });
//       afterEach(function () {
//         if (customAfterEach != null) {
//           customAfterEach();
//         }
//         if (features != null) {
//           environment.setEnvironment(new environment_1.Environment());
//         }
//       });
//       tests.forEach(function (test) { return test(customIt); });
//     });
//   }
//   exports.executeTests = executeTests;
//   function assertIsNan(val, dtype) {
//     if (!util.isValNaN(val, dtype)) {
//       throw new Error(`Value ${  val  } does not represent NaN for dtype ${  dtype}`);
//     }
//   }
//   exports.assertIsNan = assertIsNan;
//
// }, {"./environment": 7, "./math/math_cpu": 53, "./math/math_gpu": 54, "./util": 88}], 88: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   function shuffle(array) {
//     let counter = array.length;
//     let temp = 0;
//     let index = 0;
//     while (counter > 0) {
//       index = (Math.random() * counter) | 0;
//       counter --;
//       temp = array[counter];
//       array[counter] = array[index];
//       array[index] = temp;
//     }
//   }
//   exports.shuffle = shuffle;
//   function clamp(min, x, max) {
//     return Math.max(min, Math.min(x, max));
//   }
//   exports.clamp = clamp;
//   function randUniform(a, b) {
//     return Math.random() * (b - a) + a;
//   }
//   exports.randUniform = randUniform;
//   function randGauss(mean, stdDev, truncated) {
//     if (mean === void 0) { mean = 0; }
//     if (stdDev === void 0) { stdDev = 1; }
//     if (truncated === void 0) { truncated = false; }
//     let v1, v2, s;
//     do {
//       v1 = 2 * Math.random() - 1;
//       v2 = 2 * Math.random() - 1;
//       s = v1 * v1 + v2 * v2;
//     } while (s > 1);
//     const result = Math.sqrt(- 2 * Math.log(s) / s) * v1;
//     if (truncated && Math.abs(result) > 2) {
//       return randGauss(mean, stdDev, true);
//     }
//     return mean + stdDev * result;
//   }
//   exports.randGauss = randGauss;
//   function distSquared(a, b) {
//     let result = 0;
//     for (let i = 0;i < a.length;i ++) {
//       const diff = Number(a[i]) - Number(b[i]);
//       result += diff * diff;
//     }
//     return result;
//   }
//   exports.distSquared = distSquared;
//   function assert(expr, msg) {
//     if (!expr) {
//       throw new Error(msg);
//     }
//   }
//   exports.assert = assert;
//   function assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {
//     if (errorMessagePrefix === void 0) { errorMessagePrefix = ``; }
//     assert(arraysEqual(shapeA, shapeB), `${errorMessagePrefix  }Shapes ${  shapeA  } and ${  shapeB  } must match`);
//   }
//   exports.assertShapesMatch = assertShapesMatch;
//   function flatten(arr, ret) {
//     if (ret === void 0) { ret = []; }
//     if (Array.isArray(arr)) {
//       for (let i = 0;i < arr.length;++ i) {
//         flatten(arr[i], ret);
//       }
//     }
//     else {
//       ret.push(arr);
//     }
//     return ret;
//   }
//   exports.flatten = flatten;
//   function inferShape(arr) {
//     const shape = [];
//     while (arr instanceof Array) {
//       shape.push(arr.length);
//       arr = arr[0];
//     }
//     return shape;
//   }
//   exports.inferShape = inferShape;
//   function sizeFromShape(shape) {
//     if (shape.length === 0) {
//       return 1;
//     }
//     let size = shape[0];
//     for (let i = 1;i < shape.length;i ++) {
//       size *= shape[i];
//     }
//     return size;
//   }
//   exports.sizeFromShape = sizeFromShape;
//   function isScalarShape(shape) {
//     return shape.length === 0;
//   }
//   exports.isScalarShape = isScalarShape;
//   function arraysEqual(n1, n2) {
//     if (n1.length !== n2.length) {
//       return false;
//     }
//     for (let i = 0;i < n1.length;i ++) {
//       if (n1[i] !== n2[i]) {
//         return false;
//       }
//     }
//     return true;
//   }
//   exports.arraysEqual = arraysEqual;
//   function isInt(a) {
//     return a % 1 === 0;
//   }
//   exports.isInt = isInt;
//   function tanh(x) {
//     if (Math.tanh != null) {
//       return Math.tanh(x);
//     }
//     if (x === Infinity) {
//       return 1;
//     }
//     else if (x === - Infinity) {
//       return - 1;
//     }
//     else {
//       const e2x = Math.exp(2 * x);
//       return (e2x - 1) / (e2x + 1);
//     }
//   }
//   exports.tanh = tanh;
//   function sizeToSquarishShape(size) {
//     for (let a = Math.floor(Math.sqrt(size));a > 1;-- a) {
//       if (size % a === 0) {
//         return [a, size / a];
//       }
//     }
//     return [1, size];
//   }
//   exports.sizeToSquarishShape = sizeToSquarishShape;
//   function createShuffledIndices(n) {
//     const shuffledIndices = new Uint32Array(n);
//     for (let i = 0;i < n;++ i) {
//       shuffledIndices[i] = i;
//     }
//     shuffle(shuffledIndices);
//     return shuffledIndices;
//   }
//   exports.createShuffledIndices = createShuffledIndices;
//   function rightPad(a, size) {
//     if (size <= a.length) {
//       return a;
//     }
//     return a + ` `.repeat(size - a.length);
//   }
//   exports.rightPad = rightPad;
//   function repeatedTry(checkFn, delayFn, maxCounter) {
//     if (delayFn === void 0) { delayFn = function (counter) { return 0; }; }
//     return new Promise(function (resolve, reject) {
//       let tryCount = 0;
//       var tryFn = function () {
//         if (checkFn()) {
//           resolve();
//           return;
//         }
//         tryCount ++;
//         const nextBackoff = delayFn(tryCount);
//         if (maxCounter != null && tryCount >= maxCounter) {
//           reject();
//           return;
//         }
//         setTimeout(tryFn, nextBackoff);
//       };
//       setTimeout(tryFn, 0);
//     });
//   }
//   exports.repeatedTry = repeatedTry;
//   function getQueryParams(queryString) {
//     const params = {};
//     queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (s) {
//       const t = [];
//       for (let _i = 1;_i < arguments.length;_i ++) {
//         t[_i - 1] = arguments[_i];
//       }
//       decodeParam(params, t[0], t[1]);
//       return t.join(`=`);
//     });
//     return params;
//   }
//   exports.getQueryParams = getQueryParams;
//   function decodeParam(params, name, value) {
//     params[decodeURIComponent(name)] = decodeURIComponent(value || ``);
//   }
//   function inferFromImplicitShape(shape, size) {
//     let shapeProd = 1;
//     let implicitIdx = - 1;
//     for (let i = 0;i < shape.length;++ i) {
//       if (shape[i] > 0) {
//         shapeProd *= shape[i];
//       }
//       else if (shape[i] === - 1) {
//         if (implicitIdx !== - 1) {
//           throw Error(`Shapes can only have 1 implicit size. ` +
//                     `Found -1 at dim ${  implicitIdx  } and dim ${  i}`);
//         }
//         implicitIdx = i;
//       }
//       else if (shape[i] <= 0) {
//         throw Error(`Shapes can not be <= 0. Found ${  shape[i]  } at dim ${  i}`);
//       }
//     }
//     if (implicitIdx === - 1) {
//       if (size > 0 && size !== shapeProd) {
//         throw Error(`Size (${  size  }) must match the product of shape ${  shape}`);
//       }
//       return shape;
//     }
//     if (size % shapeProd !== 0) {
//       throw Error(`The implicit shape can't be a fractional number. ` +
//             `Got ${  size  } / ${  shapeProd}`);
//     }
//     const newShape = shape.slice();
//     newShape[implicitIdx] = size / shapeProd;
//     return newShape;
//   }
//   exports.inferFromImplicitShape = inferFromImplicitShape;
//   exports.NAN_INT32 = 1 << 31;
//   exports.NAN_BOOL = 255;
//   exports.NAN_FLOAT32 = NaN;
//   function getNaN(dtype) {
//     if (dtype === `float32`) {
//       return exports.NAN_FLOAT32;
//     }
//     else if (dtype === `int32`) {
//       return exports.NAN_INT32;
//     }
//     else if (dtype === `bool`) {
//       return exports.NAN_BOOL;
//     }
//     else {
//       throw new Error(`Unknown dtype ${  dtype}`);
//     }
//   }
//   exports.getNaN = getNaN;
//   function isValNaN(val, dtype) {
//     if (dtype === `float32`) {
//       return isNaN(val);
//     }
//     else if (dtype === `int32`) {
//       return val === exports.NAN_INT32;
//     }
//     else if (dtype === `bool`) {
//       return val === exports.NAN_BOOL;
//     }
//     else {
//       throw new Error(`Unknown dtype ${  dtype}`);
//     }
//   }
//   exports.isValNaN = isValNaN;
//   function squeezeShape(shape) {
//     const newShape = [];
//     const keptDims = [];
//     for (let i = 0;i < shape.length;++ i) {
//       if (shape[i] > 1) {
//         newShape.push(shape[i]);
//         keptDims.push(i);
//       }
//     }
//     return {newShape: newShape, keptDims: keptDims};
//   }
//   exports.squeezeShape = squeezeShape;
//
// }, {}], 89: [function(require, module, exports) {
//   "use strict";
//   Object.defineProperty(exports, `__esModule`, {value: true});
//   const version = `0.3.11`;
//   exports.version = version;
//
// }, {}], 90: [function(require, module, exports) {
// // A library of seedable RNGs implemented in Javascript.
// //
// // Usage:
// //
// // var seedrandom = require('seedrandom');
// // var random = seedrandom(1); // or any seed.
// // var x = random();       // 0 <= x < 1.  Every bit is random.
// // var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.
//
// // alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// // Period: ~2^116
// // Reported to pass all BigCrush tests.
//   const alea = require(`./lib/alea`);
//
// // xor128, a pure xor-shift generator by George Marsaglia.
// // Period: 2^128-1.
// // Reported to fail: MatrixRank and LinearComp.
//   const xor128 = require(`./lib/xor128`);
//
// // xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// // Period: 2^192-2^32
// // Reported to fail: CollisionOver, SimpPoker, and LinearComp.
//   const xorwow = require(`./lib/xorwow`);
//
// // xorshift7, by François Panneton and Pierre L'ecuyer, takes
// // a different approach: it adds robustness by allowing more shifts
// // than Marsaglia's original three.  It is a 7-shift generator
// // with 256 bits, that passes BigCrush with no systmatic failures.
// // Period 2^256-1.
// // No systematic BigCrush failures reported.
//   const xorshift7 = require(`./lib/xorshift7`);
//
// // xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// // very long period that also adds a Weyl generator. It also passes
// // BigCrush with no systematic failures.  Its long period may
// // be useful if you have many generators and need to avoid
// // collisions.
// // Period: 2^4128-2^32.
// // No systematic BigCrush failures reported.
//   const xor4096 = require(`./lib/xor4096`);
//
// // Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// // number generator derived from ChaCha, a modern stream cipher.
// // https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// // Period: ~2^127
// // No systematic BigCrush failures reported.
//   const tychei = require(`./lib/tychei`);
//
// // The original ARC4-based prng included in this library.
// // Period: ~2^1600
//   const sr = require(`./seedrandom`);
//
//   sr.alea = alea;
//   sr.xor128 = xor128;
//   sr.xorwow = xorwow;
//   sr.xorshift7 = xorshift7;
//   sr.xor4096 = xor4096;
//   sr.tychei = tychei;
//
//   module.exports = sr;
//
// }, {"./lib/alea": 91, "./lib/tychei": 92, "./lib/xor128": 93, "./lib/xor4096": 94, "./lib/xorshift7": 95, "./lib/xorwow": 96, "./seedrandom": 97}], 91: [function(require, module, exports) {
// // A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// // http://baagoe.com/en/RandomMusings/javascript/
// // https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// // Original work is under MIT license -
//
// // Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
// //
// // Permission is hereby granted, free of charge, to any person obtaining a copy
// // of this software and associated documentation files (the "Software"), to deal
// // in the Software without restriction, including without limitation the rights
// // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// // copies of the Software, and to permit persons to whom the Software is
// // furnished to do so, subject to the following conditions:
// //
// // The above copyright notice and this permission notice shall be included in
// // all copies or substantial portions of the Software.
// //
// // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// // THE SOFTWARE.
//
//
//
//   (function(global, module, define) {
//
//     function Alea(seed) {
//       let me = this, mash = Mash();
//
//       me.next = function() {
//         const t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
//         me.s0 = me.s1;
//         me.s1 = me.s2;
//         return me.s2 = t - (me.c = t | 0);
//       };
//
//   // Apply the seeding algorithm from Baagoe.
//       me.c = 1;
//       me.s0 = mash(` `);
//       me.s1 = mash(` `);
//       me.s2 = mash(` `);
//       me.s0 -= mash(seed);
//       if (me.s0 < 0) { me.s0 += 1; }
//       me.s1 -= mash(seed);
//       if (me.s1 < 0) { me.s1 += 1; }
//       me.s2 -= mash(seed);
//       if (me.s2 < 0) { me.s2 += 1; }
//       mash = null;
//     }
//
//     function copy(f, t) {
//       t.c = f.c;
//       t.s0 = f.s0;
//       t.s1 = f.s1;
//       t.s2 = f.s2;
//       return t;
//     }
//
//     function impl(seed, opts) {
//       let xg = new Alea(seed),
//         state = opts && opts.state,
//         prng = xg.next;
//       prng.int32 = function() { return (xg.next() * 0x100000000) | 0; };
//       prng.double = function() {
//         return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
//       };
//       prng.quick = prng;
//       if (state) {
//         if (typeof (state) == `object`) copy(state, xg);
//         prng.state = function() { return copy(xg, {}); };
//       }
//       return prng;
//     }
//
//     function Mash() {
//       let n = 0xefc8249d;
//
//       const mash = function(data) {
//         data = data.toString();
//         for (let i = 0;i < data.length;i ++) {
//           n += data.charCodeAt(i);
//           let h = 0.02519603282416938 * n;
//           n = h >>> 0;
//           h -= n;
//           h *= n;
//           n = h >>> 0;
//           h -= n;
//           n += h * 0x100000000; // 2^32
//         }
//         return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
//       };
//
//       return mash;
//     }
//
//
//     if (module && module.exports) {
//       module.exports = impl;
//     } else if (define && define.amd) {
//       define(function() { return impl; });
//     } else {
//       this.alea = impl;
//     }
//
//   })(
//   this,
//   (typeof module) == `object` && module,    // present in node.js
//   (typeof define) == `function` && define   // present with an AMD loader
// );
//
//
//
// }, {}], 92: [function(require, module, exports) {
// // A Javascript implementaion of the "Tyche-i" prng algorithm by
// // Samuel Neves and Filipe Araujo.
// // See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
//
//   (function(global, module, define) {
//
//     function XorGen(seed) {
//       let me = this, strseed = ``;
//
//   // Set up generator function.
//       me.next = function() {
//         let b = me.b, c = me.c, d = me.d, a = me.a;
//         b = (b << 25) ^ (b >>> 7) ^ c;
//         c = (c - d) | 0;
//         d = (d << 24) ^ (d >>> 8) ^ a;
//         a = (a - b) | 0;
//         me.b = b = (b << 20) ^ (b >>> 12) ^ c;
//         me.c = c = (c - d) | 0;
//         me.d = (d << 16) ^ (c >>> 16) ^ a;
//         return me.a = (a - b) | 0;
//       };
//
//   /* The following is non-inverted tyche, which has better internal
//    * bit diffusion, but which is about 25% slower than tyche-i in JS.
//   me.next = function() {
//     var a = me.a, b = me.b, c = me.c, d = me.d;
//     a = (me.a + me.b | 0) >>> 0;
//     d = me.d ^ a; d = d << 16 ^ d >>> 16;
//     c = me.c + d | 0;
//     b = me.b ^ c; b = b << 12 ^ d >>> 20;
//     me.a = a = a + b | 0;
//     d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
//     me.c = c = c + d | 0;
//     b = b ^ c;
//     return me.b = (b << 7 ^ b >>> 25);
//   }
//   */
//
//       me.a = 0;
//       me.b = 0;
//       me.c = 2654435769 | 0;
//       me.d = 1367130551;
//
//       if (seed === Math.floor(seed)) {
//     // Integer seed.
//         me.a = (seed / 0x100000000) | 0;
//         me.b = seed | 0;
//       } else {
//     // String seed.
//         strseed += seed;
//       }
//
//   // Mix in string seed, then discard an initial batch of 64 values.
//       for (let k = 0;k < strseed.length + 20;k ++) {
//         me.b ^= strseed.charCodeAt(k) | 0;
//         me.next();
//       }
//     }
//
//     function copy(f, t) {
//       t.a = f.a;
//       t.b = f.b;
//       t.c = f.c;
//       t.d = f.d;
//       return t;
//     }
//
//     function impl(seed, opts) {
//       let xg = new XorGen(seed),
//         state = opts && opts.state,
//         prng = function() { return (xg.next() >>> 0) / 0x100000000; };
//       prng.double = function() {
//         do {
//           var top = xg.next() >>> 11,
//             bot = (xg.next() >>> 0) / 0x100000000,
//             result = (top + bot) / (1 << 21);
//         } while (result === 0);
//         return result;
//       };
//       prng.int32 = xg.next;
//       prng.quick = prng;
//       if (state) {
//         if (typeof (state) == `object`) copy(state, xg);
//         prng.state = function() { return copy(xg, {}); };
//       }
//       return prng;
//     }
//
//     if (module && module.exports) {
//       module.exports = impl;
//     } else if (define && define.amd) {
//       define(function() { return impl; });
//     } else {
//       this.tychei = impl;
//     }
//
//   })(
//   this,
//   (typeof module) == `object` && module,    // present in node.js
//   (typeof define) == `function` && define   // present with an AMD loader
// );
//
//
//
// }, {}], 93: [function(require, module, exports) {
// // A Javascript implementaion of the "xor128" prng algorithm by
// // George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper
//
//   (function(global, module, define) {
//
//     function XorGen(seed) {
//       let me = this, strseed = ``;
//
//       me.x = 0;
//       me.y = 0;
//       me.z = 0;
//       me.w = 0;
//
//   // Set up generator function.
//       me.next = function() {
//         const t = me.x ^ (me.x << 11);
//         me.x = me.y;
//         me.y = me.z;
//         me.z = me.w;
//         return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
//       };
//
//       if (seed === (seed | 0)) {
//     // Integer seed.
//         me.x = seed;
//       } else {
//     // String seed.
//         strseed += seed;
//       }
//
//   // Mix in string seed, then discard an initial batch of 64 values.
//       for (let k = 0;k < strseed.length + 64;k ++) {
//         me.x ^= strseed.charCodeAt(k) | 0;
//         me.next();
//       }
//     }
//
//     function copy(f, t) {
//       t.x = f.x;
//       t.y = f.y;
//       t.z = f.z;
//       t.w = f.w;
//       return t;
//     }
//
//     function impl(seed, opts) {
//       let xg = new XorGen(seed),
//         state = opts && opts.state,
//         prng = function() { return (xg.next() >>> 0) / 0x100000000; };
//       prng.double = function() {
//         do {
//           var top = xg.next() >>> 11,
//             bot = (xg.next() >>> 0) / 0x100000000,
//             result = (top + bot) / (1 << 21);
//         } while (result === 0);
//         return result;
//       };
//       prng.int32 = xg.next;
//       prng.quick = prng;
//       if (state) {
//         if (typeof (state) == `object`) copy(state, xg);
//         prng.state = function() { return copy(xg, {}); };
//       }
//       return prng;
//     }
//
//     if (module && module.exports) {
//       module.exports = impl;
//     } else if (define && define.amd) {
//       define(function() { return impl; });
//     } else {
//       this.xor128 = impl;
//     }
//
//   })(
//   this,
//   (typeof module) == `object` && module,    // present in node.js
//   (typeof define) == `function` && define   // present with an AMD loader
// );
//
//
//
// }, {}], 94: [function(require, module, exports) {
// // A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
// //
// // This fast non-cryptographic random number generator is designed for
// // use in Monte-Carlo algorithms. It combines a long-period xorshift
// // generator with a Weyl generator, and it passes all common batteries
// // of stasticial tests for randomness while consuming only a few nanoseconds
// // for each prng generated.  For background on the generator, see Brent's
// // paper: "Some long-period random number generators using shifts and xors."
// // http://arxiv.org/pdf/1004.3115v1.pdf
// //
// // Usage:
// //
// // var xor4096 = require('xor4096');
// // random = xor4096(1);                        // Seed with int32 or string.
// // assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// // assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
// //
// // For nonzero numeric keys, this impelementation provides a sequence
// // identical to that by Brent's xorgens 3 implementaion in C.  This
// // implementation also provides for initalizing the generator with
// // string seeds, or for saving and restoring the state of the generator.
// //
// // On Chrome, this prng benchmarks about 2.1 times slower than
// // Javascript's built-in Math.random().
//
//   (function(global, module, define) {
//
//     function XorGen(seed) {
//       const me = this;
//
//   // Set up generator function.
//       me.next = function() {
//         let w = me.w,
//           X = me.X, i = me.i, t, v;
//     // Update Weyl generator.
//         me.w = w = (w + 0x61c88647) | 0;
//     // Update xor generator.
//         v = X[(i + 34) & 127];
//         t = X[i = ((i + 1) & 127)];
//         v ^= v << 13;
//         t ^= t << 17;
//         v ^= v >>> 15;
//         t ^= t >>> 12;
//     // Update Xor generator array state.
//         v = X[i] = v ^ t;
//         me.i = i;
//     // Result is the combination.
//         return (v + (w ^ (w >>> 16))) | 0;
//       };
//
//       function init(me, seed) {
//         let t, v, i, j, w, X = [], limit = 128;
//         if (seed === (seed | 0)) {
//       // Numeric seeds initialize v, which is used to generates X.
//           v = seed;
//           seed = null;
//         } else {
//       // String seeds are mixed into v and X one character at a time.
//           seed = `${seed  }\0`;
//           v = 0;
//           limit = Math.max(limit, seed.length);
//         }
//     // Initialize circular array and weyl value.
//         for (i = 0, j = - 32;j < limit;++ j) {
//       // Put the unicode characters into the array, and shuffle them.
//           if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
//       // After 32 shuffles, take v as the starting w value.
//           if (j === 0) w = v;
//           v ^= v << 10;
//           v ^= v >>> 15;
//           v ^= v << 4;
//           v ^= v >>> 13;
//           if (j >= 0) {
//             w = (w + 0x61c88647) | 0;     // Weyl.
//             t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
//             i = (0 == t) ? i + 1 : 0;     // Count zeroes.
//           }
//         }
//     // We have detected all zeroes; make the key nonzero.
//         if (i >= 128) {
//           X[(seed && seed.length || 0) & 127] = - 1;
//         }
//     // Run the generator 512 times to further mix the state before using it.
//     // Factoring this as a function slows the main generator, so it is just
//     // unrolled here.  The weyl generator is not advanced while warming up.
//         i = 127;
//         for (j = 4 * 128;j > 0;-- j) {
//           v = X[(i + 34) & 127];
//           t = X[i = ((i + 1) & 127)];
//           v ^= v << 13;
//           t ^= t << 17;
//           v ^= v >>> 15;
//           t ^= t >>> 12;
//           X[i] = v ^ t;
//         }
//     // Storing state as object members is faster than using closure variables.
//         me.w = w;
//         me.X = X;
//         me.i = i;
//       }
//
//       init(me, seed);
//     }
//
//     function copy(f, t) {
//       t.i = f.i;
//       t.w = f.w;
//       t.X = f.X.slice();
//       return t;
//     }
//
//     function impl(seed, opts) {
//       if (seed == null) seed = + (new Date);
//       let xg = new XorGen(seed),
//         state = opts && opts.state,
//         prng = function() { return (xg.next() >>> 0) / 0x100000000; };
//       prng.double = function() {
//         do {
//           var top = xg.next() >>> 11,
//             bot = (xg.next() >>> 0) / 0x100000000,
//             result = (top + bot) / (1 << 21);
//         } while (result === 0);
//         return result;
//       };
//       prng.int32 = xg.next;
//       prng.quick = prng;
//       if (state) {
//         if (state.X) copy(state, xg);
//         prng.state = function() { return copy(xg, {}); };
//       }
//       return prng;
//     }
//
//     if (module && module.exports) {
//       module.exports = impl;
//     } else if (define && define.amd) {
//       define(function() { return impl; });
//     } else {
//       this.xor4096 = impl;
//     }
//
//   })(
//   this,                                     // window object or global
//   (typeof module) == `object` && module,    // present in node.js
//   (typeof define) == `function` && define   // present with an AMD loader
// );
//
// }, {}], 95: [function(require, module, exports) {
// // A Javascript implementaion of the "xorshift7" algorithm by
// // François Panneton and Pierre L'ecuyer:
// // "On the Xorgshift Random Number Generators"
// // http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf
//
//   (function(global, module, define) {
//
//     function XorGen(seed) {
//       const me = this;
//
//   // Set up generator function.
//       me.next = function() {
//     // Update xor generator.
//         let X = me.x, i = me.i, t, v, w;
//         t = X[i];t ^= (t >>> 7);v = t ^ (t << 24);
//         t = X[(i + 1) & 7];v ^= t ^ (t >>> 10);
//         t = X[(i + 3) & 7];v ^= t ^ (t >>> 3);
//         t = X[(i + 4) & 7];v ^= t ^ (t << 7);
//         t = X[(i + 7) & 7];t = t ^ (t << 13);v ^= t ^ (t << 9);
//         X[i] = v;
//         me.i = (i + 1) & 7;
//         return v;
//       };
//
//       function init(me, seed) {
//         let j, w, X = [];
//
//         if (seed === (seed | 0)) {
//       // Seed state array using a 32-bit integer.
//           w = X[0] = seed;
//         } else {
//       // Seed state using a string.
//           seed = `${  seed}`;
//           for (j = 0;j < seed.length;++ j) {
//             X[j & 7] = (X[j & 7] << 15) ^
//             (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
//           }
//         }
//     // Enforce an array length of 8, not all zeroes.
//         while (X.length < 8) X.push(0);
//         for (j = 0;j < 8 && X[j] === 0;++ j);
//         if (j == 8) w = X[7] = - 1;else w = X[j];
//
//         me.x = X;
//         me.i = 0;
//
//     // Discard an initial 256 values.
//         for (j = 256;j > 0;-- j) {
//           me.next();
//         }
//       }
//
//       init(me, seed);
//     }
//
//     function copy(f, t) {
//       t.x = f.x.slice();
//       t.i = f.i;
//       return t;
//     }
//
//     function impl(seed, opts) {
//       if (seed == null) seed = + (new Date);
//       let xg = new XorGen(seed),
//         state = opts && opts.state,
//         prng = function() { return (xg.next() >>> 0) / 0x100000000; };
//       prng.double = function() {
//         do {
//           var top = xg.next() >>> 11,
//             bot = (xg.next() >>> 0) / 0x100000000,
//             result = (top + bot) / (1 << 21);
//         } while (result === 0);
//         return result;
//       };
//       prng.int32 = xg.next;
//       prng.quick = prng;
//       if (state) {
//         if (state.x) copy(state, xg);
//         prng.state = function() { return copy(xg, {}); };
//       }
//       return prng;
//     }
//
//     if (module && module.exports) {
//       module.exports = impl;
//     } else if (define && define.amd) {
//       define(function() { return impl; });
//     } else {
//       this.xorshift7 = impl;
//     }
//
//   })(
//   this,
//   (typeof module) == `object` && module,    // present in node.js
//   (typeof define) == `function` && define   // present with an AMD loader
// );
//
//
// }, {}], 96: [function(require, module, exports) {
// // A Javascript implementaion of the "xorwow" prng algorithm by
// // George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper
//
//   (function(global, module, define) {
//
//     function XorGen(seed) {
//       let me = this, strseed = ``;
//
//   // Set up generator function.
//       me.next = function() {
//         const t = (me.x ^ (me.x >>> 2));
//         me.x = me.y;me.y = me.z;me.z = me.w;me.w = me.v;
//         return (me.d = (me.d + 362437 | 0)) +
//        (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
//       };
//
//       me.x = 0;
//       me.y = 0;
//       me.z = 0;
//       me.w = 0;
//       me.v = 0;
//
//       if (seed === (seed | 0)) {
//     // Integer seed.
//         me.x = seed;
//       } else {
//     // String seed.
//         strseed += seed;
//       }
//
//   // Mix in string seed, then discard an initial batch of 64 values.
//       for (let k = 0;k < strseed.length + 64;k ++) {
//         me.x ^= strseed.charCodeAt(k) | 0;
//         if (k == strseed.length) {
//           me.d = me.x << 10 ^ me.x >>> 4;
//         }
//         me.next();
//       }
//     }
//
//     function copy(f, t) {
//       t.x = f.x;
//       t.y = f.y;
//       t.z = f.z;
//       t.w = f.w;
//       t.v = f.v;
//       t.d = f.d;
//       return t;
//     }
//
//     function impl(seed, opts) {
//       let xg = new XorGen(seed),
//         state = opts && opts.state,
//         prng = function() { return (xg.next() >>> 0) / 0x100000000; };
//       prng.double = function() {
//         do {
//           var top = xg.next() >>> 11,
//             bot = (xg.next() >>> 0) / 0x100000000,
//             result = (top + bot) / (1 << 21);
//         } while (result === 0);
//         return result;
//       };
//       prng.int32 = xg.next;
//       prng.quick = prng;
//       if (state) {
//         if (typeof (state) == `object`) copy(state, xg);
//         prng.state = function() { return copy(xg, {}); };
//       }
//       return prng;
//     }
//
//     if (module && module.exports) {
//       module.exports = impl;
//     } else if (define && define.amd) {
//       define(function() { return impl; });
//     } else {
//       this.xorwow = impl;
//     }
//
//   })(
//   this,
//   (typeof module) == `object` && module,    // present in node.js
//   (typeof define) == `function` && define   // present with an AMD loader
// );
//
//
//
// }, {}], 97: [function(require, module, exports) {
// /*
// Copyright 2014 David Bau.
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// */
//
//   (function (pool, math) {
// //
// // The following constants are related to IEEE 754 limits.
// //
//     let global = this,
//       width = 256,        // each RC4 output is 0 <= x < 256
//       chunks = 6,         // at least six RC4 outputs for each double
//       digits = 52,        // there are 52 significant digits in a double
//       rngname = `random`, // rngname: name for Math.random and Math.seedrandom
//       startdenom = math.pow(width, chunks),
//       significance = math.pow(2, digits),
//       overflow = significance * 2,
//       mask = width - 1,
//       nodecrypto;         // node.js crypto module, initialized at the bottom.
//
// //
// // seedrandom()
// // This is the seedrandom function described above.
// //
//     function seedrandom(seed, options, callback) {
//       const key = [];
//       options = (options == true) ? {entropy: true} : (options || {});
//
//   // Flatten the seed string or build one from local entropy if needed.
//       const shortseed = mixkey(flatten(
//     options.entropy ? [seed, tostring(pool)] :
//     (seed == null) ? autoseed() : seed, 3), key);
//
//   // Use the seed to initialize an ARC4 generator.
//       const arc4 = new ARC4(key);
//
//   // This function returns a random double in [0, 1) that contains
//   // randomness in every bit of the mantissa of the IEEE 754 value.
//       const prng = function() {
//         let n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
//           d = startdenom,                 //   and denominator d = 2 ^ 48.
//           x = 0;                          //   and no 'extra last byte'.
//         while (n < significance) {          // Fill up all significant digits by
//           n = (n + x) * width;              //   shifting numerator and
//           d *= width;                       //   denominator and generating a
//           x = arc4.g(1);                    //   new least-significant-byte.
//         }
//         while (n >= overflow) {             // To avoid rounding up, before adding
//           n /= 2;                           //   last byte, shift everything
//           d /= 2;                           //   right using integer math until
//           x >>>= 1;                         //   we have exactly the desired bits.
//         }
//         return (n + x) / d;                 // Form the number within [0, 1).
//       };
//
//       prng.int32 = function() { return arc4.g(4) | 0; };
//       prng.quick = function() { return arc4.g(4) / 0x100000000; };
//       prng.double = prng;
//
//   // Mix the randomness into accumulated entropy.
//       mixkey(tostring(arc4.S), pool);
//
//   // Calling convention: what to return as a function of prng, seed, is_math.
//       return (options.pass || callback ||
//       function(prng, seed, is_math_call, state) {
//         if (state) {
//           // Load the arc4 state from the given state if it has an S array.
//           if (state.S) { copy(state, arc4); }
//           // Only provide the .state method if requested via options.state.
//           prng.state = function() { return copy(arc4, {}); };
//         }
//
//         // If called as a method of Math (Math.seedrandom()), mutate
//         // Math.random because that is how seedrandom.js has worked since v1.0.
//         if (is_math_call) { math[rngname] = prng;return seed; }
//
//         // Otherwise, it is a newer calling convention, so return the
//         // prng directly.
//         else return prng;
//       })(
//   prng,
//   shortseed,
//   `global` in options ? options.global : (this == math),
//   options.state);
//     }
//     math[`seed${  rngname}`] = seedrandom;
//
// //
// // ARC4
// //
// // An ARC4 implementation.  The constructor takes a key in the form of
// // an array of at most (width) integers that should be 0 <= x < (width).
// //
// // The g(count) method returns a pseudorandom integer that concatenates
// // the next (count) outputs from ARC4.  Its return value is a number x
// // that is in the range 0 <= x < (width ^ count).
// //
//     function ARC4(key) {
//       let t, keylen = key.length,
//         me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
//
//   // The empty key [] is treated as [0].
//       if (!keylen) { key = [keylen ++]; }
//
//   // Set up S using the standard key scheduling algorithm.
//       while (i < width) {
//         s[i] = i ++;
//       }
//       for (i = 0;i < width;i ++) {
//         s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
//         s[j] = t;
//       }
//
//   // The "g" method returns the next (count) outputs as one number.
//       (me.g = function(count) {
//     // Using instance members instead of closure state nearly doubles speed.
//         let t, r = 0,
//           i = me.i, j = me.j, s = me.S;
//         while (count --) {
//           t = s[i = mask & (i + 1)];
//           r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
//         }
//         me.i = i;me.j = j;
//         return r;
//     // For robust unpredictability, the function call below automatically
//     // discards an initial batch of values.  This is called RC4-drop[256].
//     // See http://google.com/search?q=rsa+fluhrer+response&btnI
//       })(width);
//     }
//
// //
// // copy()
// // Copies internal state of ARC4 to or from a plain object.
// //
//     function copy(f, t) {
//       t.i = f.i;
//       t.j = f.j;
//       t.S = f.S.slice();
//       return t;
//     }
//
// //
// // flatten()
// // Converts an object tree to nested arrays of strings.
// //
//     function flatten(obj, depth) {
//       let result = [], typ = (typeof obj), prop;
//       if (depth && typ == `object`) {
//         for (prop in obj) {
//           try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
//         }
//       }
//       return (result.length ? result : typ == `string` ? obj : `${obj  }\0`);
//     }
//
// //
// // mixkey()
// // Mixes a string seed into a key that is an array of integers, and
// // returns a shortened string seed that is equivalent to the result key.
// //
//     function mixkey(seed, key) {
//       let stringseed = `${seed  }`, smear, j = 0;
//       while (j < stringseed.length) {
//         key[mask & j] =
//       mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j ++));
//       }
//       return tostring(key);
//     }
//
// //
// // autoseed()
// // Returns an object for autoseeding, using window.crypto and Node crypto
// // module if available.
// //
//     function autoseed() {
//       try {
//         let out;
//         if (nodecrypto && (out = nodecrypto.randomBytes)) {
//       // The use of 'out' to remember randomBytes makes tight minified code.
//           out = out(width);
//         } else {
//           out = new Uint8Array(width);
//           (global.crypto || global.msCrypto).getRandomValues(out);
//         }
//         return tostring(out);
//       } catch (e) {
//         let browser = global.navigator,
//           plugins = browser && browser.plugins;
//         return [+ new Date, global, plugins, global.screen, tostring(pool)];
//       }
//     }
//
// //
// // tostring()
// // Converts an array of charcodes to a string
// //
//     function tostring(a) {
//       return String.fromCharCode.apply(0, a);
//     }
//
// //
// // When seedrandom.js is loaded, we immediately mix a few bits
// // from the built-in RNG into the entropy pool.  Because we do
// // not want to interfere with deterministic PRNG state later,
// // seedrandom will not call math.random on its own again after
// // initialization.
// //
//     mixkey(math.random(), pool);
//
// //
// // Nodejs and AMD support: export the implementation as a module using
// // either convention.
// //
//     if ((typeof module) == `object` && module.exports) {
//       module.exports = seedrandom;
//   // When in node.js, try using crypto package for autoseeding.
//       try {
//         nodecrypto = require(`crypto`);
//       } catch (ex) {}
//     } else if ((typeof define) == `function` && define.amd) {
//       define(function() { return seedrandom; });
//     }
//
// // End anonymous scope, and pass initial values.
//   })(
//   [],     // pool: entropy pool starts empty
//   Math    // math: package containing random, pow, and seedrandom
// );
//
// }, {crypto: 1}], 98: [function(require, module, exports) {
//   "use strict";
//   const __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
//     return new (P || (P = Promise))(function (resolve, reject) {
//       function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
//       function rejected(value) { try { step(generator[`throw`](value)); } catch (e) { reject(e); } }
//       function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
//       step((generator = generator.apply(thisArg, _arguments || [])).next());
//     });
//   };
//   const __generator = (this && this.__generator) || function (thisArg, body) {
//     let _ = {label: 0, sent: function() { if (t[0] & 1) throw t[1];return t[1]; }, trys: [], ops: []}, f, y, t, g;
//     return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === `function` && (g[Symbol.iterator] = function() { return this; }), g;
//     function verb(n) { return function (v) { return step([n, v]); }; }
//     function step(op) {
//       if (f) throw new TypeError(`Generator is already executing.`);
//       while (_) try {
//         if (f = 1, y && (t = y[op[0] & 2 ? `return` : op[0] ? `throw` : `next`]) && !(t = t.call(y, op[1])).done) return t;
//         if (y = 0, t) op = [0, t.value];
//         switch (op[0]) {
//         case 0: case 1: t = op;break;
//         case 4: _.label++;return {value: op[1], done: false};
//         case 5: _.label++;y = op[1];op = [0];continue;
//         case 7: op = _.ops.pop();_.trys.pop();continue;
//         default:
//           if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0;continue; }
//           if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1];break; }
//           if (op[0] === 6 && _.label < t[1]) { _.label = t[1];t = op;break; }
//           if (t && _.label < t[2]) { _.label = t[2];_.ops.push(op);break; }
//           if (t[2]) _.ops.pop();
//           _.trys.pop();continue;
//         }
//         op = body.call(thisArg, _);
//       } catch (e) { op = [6, e];y = 0; } finally { f = t = 0; }
//       if (op[0] & 5) throw op[1];return {value: op[0] ? op[1] : void 0, done: true};
//     }
//   };
//   exports.__esModule = true;
//   const deeplearn_1 = require(`deeplearn`);
//   const GOOGLE_CLOUD_STORAGE_DIR =
// //  'https://storage.googleapis.com/learnjs-data/checkpoint_zoo/transformnet/';
// `${document.URL.substr(0, document.URL.lastIndexOf(`/`))  }/js/ckpts/`;
//   const TransformNet = (function () {
//     function TransformNet(math, style) {
//       this.math = math;
//       this.style = style;
//       this.variableDictionary = {};
//       this.timesScalar = deeplearn_1.Scalar[`new`](150);
//       this.plusScalar = deeplearn_1.Scalar[`new`](255. / 2);
//       this.epsilonScalar = deeplearn_1.Scalar[`new`](1e-3);
//     }
//     TransformNet.prototype.setStyle = function (style) {
//       this.style = style;
//     };
//     /**
//      * Loads necessary variables for SqueezeNet. Resolves the promise when the
//      * variables have all been loaded.
//      */
//     TransformNet.prototype.load = function () {
//       return __awaiter(this, void 0, void 0, function () {
//         let checkpointLoader, _a, _b;
//         return __generator(this, function (_c) {
//           switch (_c.label) {
//           case 0:
//             if (!(this.variableDictionary[this.style] == null)) return [3 /*break*/, 2];
//             checkpointLoader = new deeplearn_1.CheckpointLoader(`${GOOGLE_CLOUD_STORAGE_DIR + this.style  }/`);
//             _a = this.variableDictionary;
//             _b = this.style;
//             return [4 /*yield*/, checkpointLoader.getAllVariables()];
//           case 1:
//             _a[_b] =
//                             _c.sent();
//             _c.label = 2;
//           case 2:
//             this.variables = this.variableDictionary[this.style];
//             return [2 /*return*/];
//           }
//         });
//       });
//     };
//     /**
//      * Infer through TransformNet, assumes variables have been loaded.
//      * Original Tensorflow version of model can be found at
//      * https://github.com/lengstrom/fast-style-transfer
//      *
//      * @param preprocessedInput preprocessed input Array.
//      * @return Array3D containing pixels of output img
//      */
//     TransformNet.prototype.predict = function (preprocessedInput) {
//       return __awaiter(this, void 0, void 0, function () {
//         const _this = this;
//         let img;
//         return __generator(this, function (_a) {
//           img = this.math.scope(function (keep, track) {
//             const conv1 = _this.convLayer(preprocessedInput, 1, true, 0);
//             const conv2 = _this.convLayer(conv1, 2, true, 3);
//             const conv3 = _this.convLayer(conv2, 2, true, 6);
//             const resid1 = _this.residualBlock(conv3, 9);
//             const resid2 = _this.residualBlock(resid1, 15);
//             const resid3 = _this.residualBlock(resid2, 21);
//             const resid4 = _this.residualBlock(resid3, 27);
//             const resid5 = _this.residualBlock(resid4, 33);
//             const convT1 = _this.convTransposeLayer(resid5, 64, 2, 39);
//             const convT2 = _this.convTransposeLayer(convT1, 32, 2, 42);
//             const convT3 = _this.convLayer(convT2, 1, false, 45);
//             const outTanh = _this.math.tanh(convT3);
//             const scaled = _this.math.scalarTimesArray(_this.timesScalar, outTanh);
//             const shifted = _this.math.scalarPlusArray(_this.plusScalar, scaled);
//             const clamped = _this.math.clip(shifted, 0, 255);
//             const normalized = _this.math.divide(clamped, deeplearn_1.Scalar[`new`](255.));
//             return normalized;
//           });
//           return [2 /*return*/, img];
//         });
//       });
//     };
//     TransformNet.prototype.convLayer = function (input, strides, relu, varId) {
//       const y = this.math.conv2d(input, this.variables[this.varName(varId)], null, [strides, strides], `same`);
//       const y2 = this.instanceNorm(y, varId + 1);
//       if (relu) {
//         return this.math.relu(y2);
//       }
//       return y2;
//     };
//     TransformNet.prototype.convTransposeLayer = function (input, numFilters, strides, varId) {
//       let _a = input.shape, height = _a[0], width = _a[1];
//       const newRows = height * strides;
//       const newCols = width * strides;
//       const newShape = [newRows, newCols, numFilters];
//       const y = this.math.conv2dTranspose(input, this.variables[this.varName(varId)], newShape, [strides, strides], `same`);
//       const y2 = this.instanceNorm(y, varId + 1);
//       const y3 = this.math.relu(y2);
//       return y3;
//     };
//     TransformNet.prototype.residualBlock = function (input, varId) {
//       const conv1 = this.convLayer(input, 1, true, varId);
//       const conv2 = this.convLayer(conv1, 1, false, varId + 3);
//       return this.math.addStrict(conv2, input);
//     };
//     TransformNet.prototype.instanceNorm = function (input, varId) {
//       let _a = input.shape, height = _a[0], width = _a[1], inDepth = _a[2];
//       const moments = this.math.moments(input, [0, 1]);
//       const mu = moments.mean;
//       const sigmaSq = moments.variance;
//       const shift = this.variables[this.varName(varId)];
//       const scale = this.variables[this.varName(varId + 1)];
//       const epsilon = this.epsilonScalar;
//       const normalized = this.math.divide(this.math.sub(input, mu), this.math.sqrt(this.math.add(sigmaSq, epsilon)));
//       const shifted = this.math.add(this.math.multiply(scale, normalized), shift);
//       return shifted.as3D(height, width, inDepth);
//     };
//     TransformNet.prototype.varName = function (varId) {
//       if (varId === 0) {
//         return `Variable`;
//       }
//       else {
//         return `Variable_${  varId.toString()}`;
//       }
//     };
//     TransformNet.prototype.dispose = function () {
//       for (const styleName in this.variableDictionary) {
//         for (const varName in this.variableDictionary[styleName]) {
//           this.variableDictionary[styleName][varName].dispose();
//         }
//       }
//     };
//     return TransformNet;
//   }());
//   exports.TransformNet = TransformNet;
//
// }, {deeplearn: 43}], 99: [function(require, module, exports) {
//   "use strict";
// /**
//  * @license
//  * Copyright 2017 Google Inc. All Rights Reserved.
//  * Licensed under the Apache License, Version 2.0 (the "License");
//  * you may not use this file except in compliance with the License.
//  * You may obtain a copy of the License at
//  *
//  * http://www.apache.org/licenses/LICENSE-2.0
//  *
//  * Unless required by applicable law or agreed to in writing, software
//  * distributed under the License is distributed on an "AS IS" BASIS,
//  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  * See the License for the specific language governing permissions and
//  * limitations under the License.
//  * =============================================================================
//  */
//   exports.__esModule = true;
//   function PolymerElement(spec) {
//     // tslint:disable-next-line:no-any
//     return Polymer.Class(spec);
//   }
//   exports.PolymerElement = PolymerElement;
//
// }, {}], 100: [function(require, module, exports) {
// // // // // "use strict";
//   const __extends = (this && this.__extends) || (function () {
//     const extendStatics = Object.setPrototypeOf ||
//         ({__proto__: []} instanceof Array && function (d, b) { d.__proto__ = b; }) ||
//         function (d, b) { for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
//     return function (d, b) {
//       extendStatics(d, b);
//       function __() { this.constructor = d; }
//       d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
//     };
//   })();
//   const __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
//     return new (P || (P = Promise))(function (resolve, reject) {
//       function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
//       function rejected(value) { try { step(generator[`throw`](value)); } catch (e) { reject(e); } }
//       function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
//       step((generator = generator.apply(thisArg, _arguments || [])).next());
//     });
//   };
//   const __generator = (this && this.__generator) || function (thisArg, body) {
//     let _ = {label: 0, sent: function() { if (t[0] & 1) throw t[1];return t[1]; }, trys: [], ops: []}, f, y, t, g;
//     return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === `function` && (g[Symbol.iterator] = function() { return this; }), g;
//     function verb(n) { return function (v) { return step([n, v]); }; }
//     function step(op) {
//       if (f) throw new TypeError(`Generator is already executing.`);
//       while (_) try {
//         if (f = 1, y && (t = y[op[0] & 2 ? `return` : op[0] ? `throw` : `next`]) && !(t = t.call(y, op[1])).done) return t;
//         if (y = 0, t) op = [0, t.value];
//         switch (op[0]) {
//         case 0: case 1: t = op;break;
//         case 4: _.label++;return {value: op[1], done: false};
//         case 5: _.label++;y = op[1];op = [0];continue;
//         case 7: op = _.ops.pop();_.trys.pop();continue;
//         default:
//           if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0;continue; }
//           if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1];break; }
//           if (op[0] === 6 && _.label < t[1]) { _.label = t[1];t = op;break; }
//           if (t && _.label < t[2]) { _.label = t[2];_.ops.push(op);break; }
//           if (t[2]) _.ops.pop();
//           _.trys.pop();continue;
//         }
//         op = body.call(thisArg, _);
//       } catch (e) { op = [6, e];y = 0; } finally { f = t = 0; }
//       if (op[0] & 5) throw op[1];return {value: op[0] ? op[1] : void 0, done: true};
//     }
//   };
//   exports.__esModule = true;
// // tslint:disable-next-line:max-line-length
//   const deeplearn_1 = require(`deeplearn`);
// // import * as imagenet_util from '../models/imagenet_util';
//   const net_1 = require(`./net`);
//   const polymer_spec_1 = require(`./polymer-spec`);
// // tslint:disable-next-line:variable-name
//   exports.StyleTransferDemoPolymer = polymer_spec_1.PolymerElement({
//     is: `styletransfer-demo`,
//     properties: {
//       contentNames: String,
//       selectedContentName: String,
//       styleNames: Array,
//       selectedStyleName: String
//     }
//   });
//   let ApplicationState;
//   (function (ApplicationState) {
//     ApplicationState[ApplicationState[`IDLE`] = 1] = `IDLE`;
//     ApplicationState[ApplicationState[`TRAINING`] = 2] = `TRAINING`;
//   })(ApplicationState = exports.ApplicationState || (exports.ApplicationState = {}));
//   const CONTENT_NAMES = `Upload from file`;
//   const STYLE_MAPPINGS = {
//     'Udnie, Francis Picabia': `udnie`,
//     'The Scream, Edvard Munch': `scream`,
//     'La Muse, Pablo Picasso': `la_muse`,
//     'Rain Princess, Leonid Afremov': `rain_princess`,
//     'The Wave, Katsushika Hokusai': `wave`,
//     'The Wreck of the Minotaur, J.M.W. Turner': `wreck`
//   };
//   const STYLE_NAMES = Object.keys(STYLE_MAPPINGS);
//   const StyleTransferDemo = (function (_super) {
//     __extends(StyleTransferDemo, _super);
//     function StyleTransferDemo() {
//       return _super !== null && _super.apply(this, arguments) || this;
//     }
//     StyleTransferDemo.prototype.ready = function () {
//       const _this = this;
//         // Initialize deeplearn.js stuff
//       this.canvas = this.querySelector(`#imageCanvas`);
//       this.gl = deeplearn_1.gpgpu_util.createWebGLContext(this.canvas);
//       this.gpgpu = new deeplearn_1.GPGPUContext(this.gl);
//       this.math = new deeplearn_1.NDArrayMathGPU(this.gpgpu);
//       this.mathCPU = new deeplearn_1.NDArrayMathCPU();
//         // Initialize polymer properties
//       this.applicationState = ApplicationState.IDLE;
//       this.status = ``;
//         // Retrieve DOM for images - HTML element waar hij imgs inplaatst
//       this.contentImgElement =
//             this.querySelector(`#contentImg`);
//       this.styleImgElement =
//             this.querySelector(`#styleImg`);
//         // Render DOM for images
//         // linkerafbeelding - jouw foto, eerste foto die erop staat
//       this.contentNames = CONTENT_NAMES;
//       this.selectedContentName = `stata`;
//       this.contentImgElement.src = `images/stata.jpg`;
//       this.contentImgElement.height = 250;
//         // rechterafbeelding - style (eerste stijlafbeelding)
//       this.styleNames = STYLE_NAMES;
//       this.selectedStyleName = `Udnie, Francis Picabia`;
//       this.styleImgElement.src = `images/udnie.jpg`;
//       this.styleImgElement.height = 250;
//       this.transformNet = new net_1.TransformNet(this.math, STYLE_MAPPINGS[this.selectedStyleName]);
//         //this.initWebcamVariables();
//         // SLIDER VOOR DE GROOTTE VAN DE IMG AAN TE PASSEN
//         // // tslint:disable-next-line:no-any
//         // this.sizeSlider = this.querySelector('#sizeSlider') as any;
//         // this.sizeSlider.addEventListener('immediate-value-change',
//         // // tslint:disable-next-line:no-any
//         //   (event: any) => {
//         //   this.styleImgElement.height = this.sizeSlider.immediateValue;
//         //   this.contentImgElement.height = this.sizeSlider.immediateValue;
//         // });
//         // tslint:disable-next-line:no-any
//         // this.sizeSlider.addEventListener('change', (event: any) => {
//         //   this.styleImgElement.height = this.sizeSlider.immediateValue;
//         //   this.contentImgElement.height = this.sizeSlider.immediateValue;
//         // });
//         //HET SELECTEREN EN UPLOADEN VAN DE IMAGE
//       this.fileSelect = this.querySelector(`#fileSelect`);
//         // tslint:disable-next-line:no-any
//       this.fileSelect.addEventListener(`change`, function (event) {
//         const f = event.target.files[0];
//         const fileReader = new FileReader();
//         fileReader.onload = (function (e) {
//           const target = e.target;
//           _this.contentImgElement.src = target.result;
//         });
//         fileReader.readAsDataURL(f);
//         _this.fileSelect.value = ``;
//       });
//         // Add listener to drop downs
//         // const contentDropdown = this.querySelector('#content-dropdown');
//         // // tslint:disable-next-line:no-any
//         // contentDropdown.addEventListener('iron-activate', (event: any) => {
//         //   const selected: string = event.detail.selected as string;
//         //   // if (selected === 'Use webcam') {
//         //   //   this.openWebcamModal();
//         //   // }
//         //   if (selected === 'Upload from file') {
//         //     this.fileSelect.click();
//         //   }
//         //   else {
//         //     this.contentImgElement.src = 'images/' + selected + '.jpg';
//         //   }
//         // });
//       const fileSelectButton = this.querySelector(`#file-upload`);
//       fileSelectButton.addEventListener(`click`, function (event) {
//         _this.fileSelect.click();
//       });
//       const styleDropdown = this.querySelector(`#style-dropdown`);
//         // tslint:disable-next-line:no-any
//       styleDropdown.addEventListener(`iron-activate`, function (event) {
//         _this.styleImgElement.src =
//                 `images/${  STYLE_MAPPINGS[event.detail.selected]  }.jpg`;
//       });
//         // Add listener to start
//       this.startButton = this.querySelector(`#start`);
//       this.startButton.addEventListener(`click`, function () {
//         console.log(`click`);
//         _this.querySelector(`#load-error-message`).style.display =
//                 `none`;
//         _this.startButton.textContent =
//                 `Starting style transfer.. Downloading + running model`;
//         _this.startButton.disabled = true;
//         _this.transformNet.setStyle(STYLE_MAPPINGS[_this.selectedStyleName]);
//         _this.transformNet.load()
//                 .then(function () {
//                   _this.startButton.textContent = `Processing image`;
//                   _this.runInference();
//                   _this.startButton.textContent = `Start Style Transfer`;
//                   _this.startButton.disabled = false;
//                 })[`catch`](function (error) {
//                   console.log(error);
//                   _this.startButton.textContent = `Start Style Transfer`;
//                   _this.startButton.disabled = false;
//                   const errMessage = _this.querySelector(`#load-error-message`);
//                   errMessage.textContent = error;
//                   errMessage.style.display = `block`;
//                 });
//       });
//     };
//     // private initWebcamVariables() {
//     //   this.camDialog = this.querySelector('#webcam-dialog');
//     //   this.webcamVideoElement =
//     //       this.querySelector('#webcamVideo') as HTMLVideoElement;
//     //   this.takePicButton =
//     //       this.querySelector('#takePicButton') as HTMLButtonElement;
//     //   this.closeModal = this.querySelector('#closeModal') as HTMLButtonElement;
//     //
//     //   // Check if webcam is even available
//     //   // tslint:disable-next-line:no-any
//     //   const navigatorAny = navigator as any;
//     //   navigator.getUserMedia = navigator.getUserMedia ||
//     //       navigatorAny.webkitGetUserMedia || navigatorAny.mozGetUserMedia ||
//     //       navigatorAny.msGetUserMedia;
//     //   if (navigator.getUserMedia) {
//     //     const contentNames = CONTENT_NAMES.slice();
//     //     contentNames.unshift('Use webcam');
//     //     this.contentNames = contentNames;
//     //   }
//     //
//     //   this.closeModal.addEventListener('click', () => {
//     //     this.stream.getTracks()[0].stop();
//     //   });
//     //
//     //   this.takePicButton.addEventListener('click', () => {
//     //     const hiddenCanvas: HTMLCanvasElement =
//     //       this.querySelector('#hiddenCanvas') as HTMLCanvasElement;
//     //     const hiddenContext: CanvasRenderingContext2D =
//     //       hiddenCanvas.getContext('2d');
//     //     hiddenCanvas.width = this.webcamVideoElement.width;
//     //     hiddenCanvas.height = this.webcamVideoElement.height;
//     //     hiddenContext.drawImage(this.webcamVideoElement, 0, 0,
//     //       hiddenCanvas.width, hiddenCanvas.height);
//     //     const imageDataURL = hiddenCanvas.toDataURL('image/jpg');
//     //     this.contentImgElement.src = imageDataURL;
//     //     this.stream.getTracks()[0].stop();
//     //   });
//     // }
//     // private openWebcamModal() {
//     //   this.camDialog.open();
//     //   navigator.getUserMedia(
//     //     {
//     //       video: true
//     //     },
//     //     (stream) => {
//     //       this.stream = stream;
//     //       this.webcamVideoElement.src = window.URL.createObjectURL(stream);
//     //       this.webcamVideoElement.play();
//     //     },
//     //     (err) => {
//     //       console.error(err);
//     //     }
//     //   );
//     // }
//     StyleTransferDemo.prototype.runInference = function () {
//       return __awaiter(this, void 0, void 0, function () {
//         const _this = this;
//         return __generator(this, function (_a) {
//           switch (_a.label) {
//           case 0: return [4 /*yield*/, this.math.scope(function (keep, track) { return __awaiter(_this, void 0, void 0, function () {
//             let preprocessed, inferenceResult;
//             return __generator(this, function (_a) {
//               switch (_a.label) {
//               case 0:
//                 preprocessed = track(deeplearn_1.Array3D.fromPixels(this.contentImgElement));
//                 return [4 /*yield*/, this.transformNet.predict(preprocessed)];
//               case 1:
//                 inferenceResult = _a.sent();
//                 this.setCanvasShape(inferenceResult.shape);
//                 this.renderShader = deeplearn_1.render_ndarray_gpu_util.getRenderRGBShader(this.gpgpu, inferenceResult.shape[1]);
//                 deeplearn_1.render_ndarray_gpu_util.renderToCanvas(this.gpgpu, this.renderShader, inferenceResult.getTexture());
//                 return [2 /*return*/];
//               }
//             });
//           }); })];
//           case 1:
//             _a.sent();
//             return [2 /*return*/];
//           }
//         });
//       });
//     };
//     //Het resultaat van de image wordt getoond
//     StyleTransferDemo.prototype.setCanvasShape = function (shape) {
//       this.canvas.width = shape[1];
//       this.canvas.height = shape[0];
//       if (shape[1] > shape[0]) {
//         this.canvas.style.width = `500px`;
//         this.canvas.style.height = `${(shape[0] / shape[1] * 500).toString()  }px`;
//       }
//       else {
//         this.canvas.style.height = `500px`;
//         this.canvas.style.width = `${(shape[1] / shape[0] * 500).toString()  }px`;
//       }
//     };
//     return StyleTransferDemo;
//   }(exports.StyleTransferDemoPolymer));
//   exports.StyleTransferDemo = StyleTransferDemo;
//   document.registerElement(StyleTransferDemo.prototype.is, StyleTransferDemo);
//
// }, {"./net": 98, "./polymer-spec": 99, deeplearn: 43}]}, {}, [100]);
// //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9kYXRhL2NoZWNrcG9pbnRfbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9kYXRhL2RhdGFzZXQuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2RhdGEvaW5wdXRfcHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2RhdGEveGhyLWRhdGFzZXQuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2RldmljZV91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9lbnZpcm9ubWVudC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvZ3JhcGguanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL2dyYXBoX3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wZXJhdGlvbl9lbWl0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvYWRkLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvYXJnbWF4LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvYXJnbWF4ZXF1YWxzLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvY29uY2F0M2QuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9jb252b2x1dGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL2RpdmlkZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL2VsZW1lbnRfd2lzZV9hY3RpdmF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvZWxlbWVudF93aXNlX2Nvc3QuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9leHAuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9saW5lYXJfY29tYmluYXRpb24uanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9sb2cuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9tYXRtdWwuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9tYXhfcG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL211bHRpcGx5LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvb3AuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9yZWR1Y2Vfc3VtLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvcmVzaGFwZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL3NvZnRtYXguanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9zdWJ0cmFjdC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3B0aW1pemVycy9hZGFkZWx0YV9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvYWRhZ3JhZF9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvYWRhbV9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvYWRhbWF4X29wdGltaXplci5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3B0aW1pemVycy9tb21lbnR1bV9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvb3B0aW1pemVyLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHRpbWl6ZXJzL3Jtc3Byb3Bfb3B0aW1pemVyLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHRpbWl6ZXJzL3NnZF9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL3ByaW9yaXR5X3F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9zZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9zZXNzaW9uX3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL3RlbnNvcl9hcnJheV9tYXAuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoX3J1bm5lci5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2luaXRpYWxpemVycy5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC9hY3RpdmF0aW9uX2Z1bmN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC9heGlzX3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvYnJvYWRjYXN0X3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvY29uY2F0X3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvY29udl91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL2NvcHkyZF91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL2Nvc3RfZnVuY3Rpb25zLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL21hdGguanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvbWF0aF9jcHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvbWF0aF9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvbmRhcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC9yZWR1Y2VfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC9zbGljZV91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2FkZHNjYWxlZG1hdF9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvYXJnbWlubWF4X2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9iYXRjaG5vcm1fZ3B1LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2JpbmFyeW9wX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9jbGlwX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9jb25jYXRfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2NvbnZfYmFja3Byb3BfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2NvbnZfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2NvbnZfZ3B1X2RlcHRod2lzZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9jb3B5X2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9ncGdwdV9jb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2dwZ3B1X21hdGguanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvZ3BncHVfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9tYXhfcG9vbF9iYWNrcHJvcF9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvbXVsbWF0X2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9tdWx0aW5vbWlhbF9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvb25laG90X2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9wb29sX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9yZWR1Y2VfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL3JlbmRlcl9uZGFycmF5X2dwdV91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL3Jlc2l6ZV9iaWxpbmVhcl9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvc2hhZGVyX2NvbXBpbGVyLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL3NsaWNlX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC90ZXhfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC90ZXh0dXJlX21hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvdGlsZV9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvdHJhbnNwb3NlX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC91bmFyeW9wX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC93ZWJnbF91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy90ZXN0X3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi9hbGVhLmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3R5Y2hlaS5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3IxMjguanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yNDA5Ni5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3JzaGlmdDcuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yd293LmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vc2VlZHJhbmRvbS5qcyIsInNyYy9uZXQuanMiLCJzcmMvcG9seW1lci1zcGVjLmpzIiwic3JjL3N0eWxldHJhbnNmZXItZGVtby5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbDVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9tYXRoL25kYXJyYXlcIik7XG52YXIgTUFOSUZFU1RfRklMRSA9ICdtYW5pZmVzdC5qc29uJztcbnZhciBDaGVja3BvaW50TG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGVja3BvaW50TG9hZGVyKHVybFBhdGgpIHtcbiAgICAgICAgdGhpcy51cmxQYXRoID0gdXJsUGF0aDtcbiAgICAgICAgaWYgKHRoaXMudXJsUGF0aC5jaGFyQXQodGhpcy51cmxQYXRoLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgICAgICAgIHRoaXMudXJsUGF0aCArPSAnLyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2hlY2twb2ludExvYWRlci5wcm90b3R5cGUubG9hZE1hbmlmZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIF90aGlzLnVybFBhdGggKyBNQU5JRkVTVF9GSUxFKTtcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hlY2twb2ludE1hbmlmZXN0ID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTUFOSUZFU1RfRklMRSArIFwiIG5vdCBmb3VuZCBhdCBcIiArIF90aGlzLnVybFBhdGggKyBcIi4gXCIgKyBlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGVja3BvaW50TG9hZGVyLnByb3RvdHlwZS5nZXRDaGVja3BvaW50TWFuaWZlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvYWRNYW5pZmVzdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy5jaGVja3BvaW50TWFuaWZlc3QpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoZWNrcG9pbnRMb2FkZXIucHJvdG90eXBlLmdldEFsbFZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy52YXJpYWJsZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLmdldENoZWNrcG9pbnRNYW5pZmVzdCgpLnRoZW4oZnVuY3Rpb24gKGNoZWNrcG9pbnREZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlTmFtZXMgPSBPYmplY3Qua2V5cyhfdGhpcy5jaGVja3BvaW50TWFuaWZlc3QpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZVByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJpYWJsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlUHJvbWlzZXMucHVzaChfdGhpcy5nZXRWYXJpYWJsZSh2YXJpYWJsZU5hbWVzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHZhcmlhYmxlUHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YXJpYWJsZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJpYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlc1t2YXJpYWJsZU5hbWVzW2ldXSA9IHZhcmlhYmxlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzLnZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGVja3BvaW50TG9hZGVyLnByb3RvdHlwZS5nZXRWYXJpYWJsZSA9IGZ1bmN0aW9uICh2YXJOYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghKHZhck5hbWUgaW4gdGhpcy5jaGVja3BvaW50TWFuaWZlc3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBsb2FkIG5vbi1leGlzdGFudCB2YXJpYWJsZSAnICsgdmFyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhcmlhYmxlUmVxdWVzdFByb21pc2VNZXRob2QgPSBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIHZhciBmbmFtZSA9IF90aGlzLmNoZWNrcG9pbnRNYW5pZmVzdFt2YXJOYW1lXS5maWxlbmFtZTtcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBfdGhpcy51cmxQYXRoICsgZm5hbWUpO1xuICAgICAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHZhciBuZGFycmF5ID0gbmRhcnJheV8xLk5EQXJyYXkubWFrZShfdGhpcy5jaGVja3BvaW50TWFuaWZlc3RbdmFyTmFtZV0uc2hhcGUsIHsgdmFsdWVzOiB2YWx1ZXMgfSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShuZGFycmF5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmZXRjaCB2YXJpYWJsZSBcIiArIHZhck5hbWUgKyBcIjogXCIgKyBlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2twb2ludE1hbmlmZXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9hZE1hbmlmZXN0KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKHZhcmlhYmxlUmVxdWVzdFByb21pc2VNZXRob2QpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UodmFyaWFibGVSZXF1ZXN0UHJvbWlzZU1ldGhvZCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hlY2twb2ludExvYWRlcjtcbn0oKSk7XG5leHBvcnRzLkNoZWNrcG9pbnRMb2FkZXIgPSBDaGVja3BvaW50TG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2twb2ludF9sb2FkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgU1RBVFNfU0FNUExFX1BFUkNFTlRBR0UgPSAwLjE7XG52YXIgSW5NZW1vcnlEYXRhc2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbk1lbW9yeURhdGFzZXQoZGF0YVNoYXBlcykge1xuICAgICAgICB0aGlzLmRhdGFTaGFwZXMgPSBkYXRhU2hhcGVzO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvID0ge307XG4gICAgfVxuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUuZ2V0RGF0YVNoYXBlID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2hhcGVzW2RhdGFJbmRleF07XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFzZXQ7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kYXRhc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBpcyBudWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFzZXQubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy5nZXRTdGF0c0ZvckRhdGEoZCk7IH0pO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5nZXRTdGF0c0ZvckRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgaW5wdXRNaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHZhciBpbnB1dE1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgdmFyIGV4YW1wbGVJbmRpY2VzID0gZGF0YS5tYXAoZnVuY3Rpb24gKGV4YW1wbGUsIGkpIHsgcmV0dXJuIGk7IH0pO1xuICAgICAgICB1dGlsLnNodWZmbGUoZXhhbXBsZUluZGljZXMpO1xuICAgICAgICBleGFtcGxlSW5kaWNlcyA9XG4gICAgICAgICAgICBleGFtcGxlSW5kaWNlcy5zbGljZShleGFtcGxlSW5kaWNlcy5sZW5ndGggKiBTVEFUU19TQU1QTEVfUEVSQ0VOVEFHRSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhhbXBsZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFZhbHVlcyA9IGRhdGFbZXhhbXBsZUluZGljZXNbaV1dLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnB1dFZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlucHV0TWluID0gTWF0aC5taW4oaW5wdXRNaW4sIGlucHV0VmFsdWVzW2pdKTtcbiAgICAgICAgICAgICAgICBpbnB1dE1heCA9IE1hdGgubWF4KGlucHV0TWF4LCBpbnB1dFZhbHVlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0TWluOiBpbnB1dE1pbixcbiAgICAgICAgICAgIGlucHV0TWF4OiBpbnB1dE1heCxcbiAgICAgICAgICAgIGV4YW1wbGVDb3VudDogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICBzaGFwZTogZGF0YVswXS5zaGFwZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUubm9ybWFsaXplRXhhbXBsZXNUb1JhbmdlID0gZnVuY3Rpb24gKGV4YW1wbGVzLCBjdXJMb3dlckJvdW5kcywgY3VyVXBwZXJCb3VuZHMsIG5ld0xvd2VyQm91bmRzLCBuZXdVcHBlckJvdW5kcykge1xuICAgICAgICB2YXIgY3VyQm91bmRzSXNQZXJEaW1lbnNpb24gPSAoY3VyVXBwZXJCb3VuZHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgJiZcbiAgICAgICAgICAgIGN1ckxvd2VyQm91bmRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KTtcbiAgICAgICAgdmFyIG5ld0JvdW5kc0lzUGVyRGltZW5zaW9uID0gKG5ld0xvd2VyQm91bmRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICYmXG4gICAgICAgICAgICBuZXdVcHBlckJvdW5kcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSk7XG4gICAgICAgIHZhciBpbnB1dFNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoZXhhbXBsZXNbMF0uc2hhcGUpO1xuICAgICAgICB2YXIgbmV3RXhhbXBsZXMgPSBbXTtcbiAgICAgICAgZXhhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoZXhhbXBsZSkge1xuICAgICAgICAgICAgdmFyIGlucHV0VmFsdWVzID0gZXhhbXBsZS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShpbnB1dFNpemUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnB1dFNpemU7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJMb3dlckJvdW5kID0gY3VyQm91bmRzSXNQZXJEaW1lbnNpb24gP1xuICAgICAgICAgICAgICAgICAgICBjdXJMb3dlckJvdW5kc1tqXSA6XG4gICAgICAgICAgICAgICAgICAgIGN1ckxvd2VyQm91bmRzO1xuICAgICAgICAgICAgICAgIHZhciBjdXJVcHBlckJvdW5kID0gY3VyQm91bmRzSXNQZXJEaW1lbnNpb24gP1xuICAgICAgICAgICAgICAgICAgICBjdXJVcHBlckJvdW5kc1tqXSA6XG4gICAgICAgICAgICAgICAgICAgIGN1clVwcGVyQm91bmRzO1xuICAgICAgICAgICAgICAgIHZhciBjdXJSYW5nZSA9IGN1clVwcGVyQm91bmQgLSBjdXJMb3dlckJvdW5kO1xuICAgICAgICAgICAgICAgIHZhciBuZXdMb3dlckJvdW5kID0gbmV3Qm91bmRzSXNQZXJEaW1lbnNpb24gP1xuICAgICAgICAgICAgICAgICAgICBuZXdMb3dlckJvdW5kc1tqXSA6XG4gICAgICAgICAgICAgICAgICAgIG5ld0xvd2VyQm91bmRzO1xuICAgICAgICAgICAgICAgIHZhciBuZXdVcHBlckJvdW5kID0gbmV3Qm91bmRzSXNQZXJEaW1lbnNpb24gP1xuICAgICAgICAgICAgICAgICAgICBuZXdVcHBlckJvdW5kc1tqXSA6XG4gICAgICAgICAgICAgICAgICAgIG5ld1VwcGVyQm91bmRzO1xuICAgICAgICAgICAgICAgIHZhciBuZXdSYW5nZSA9IG5ld1VwcGVyQm91bmQgLSBuZXdMb3dlckJvdW5kO1xuICAgICAgICAgICAgICAgIGlmIChjdXJSYW5nZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWVzW2pdID0gbmV3TG93ZXJCb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbal0gPSBuZXdMb3dlckJvdW5kICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JhbmdlICogKGlucHV0VmFsdWVzW2pdIC0gY3VyTG93ZXJCb3VuZCkgLyBjdXJSYW5nZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdFeGFtcGxlcy5wdXNoKG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoZXhhbXBsZS5zaGFwZSwgeyB2YWx1ZXM6IG5vcm1hbGl6ZWRWYWx1ZXMgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld0V4YW1wbGVzO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5jb21wdXRlQm91bmRzID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kYXRhc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBpcyBudWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdWzBdLnNoYXBlKTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdID0ge1xuICAgICAgICAgICAgaXNOb3JtYWxpemVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1pblZhbHVlczogbmV3IEZsb2F0MzJBcnJheShzaXplKSxcbiAgICAgICAgICAgIG1heFZhbHVlczogbmV3IEZsb2F0MzJBcnJheShzaXplKVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlc1tpXSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5tYXhWYWx1ZXNbaV0gPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhc2V0W2RhdGFJbmRleF0uZm9yRWFjaChmdW5jdGlvbiAoZXhhbXBsZSkge1xuICAgICAgICAgICAgdmFyIGlucHV0VmFsdWVzID0gZXhhbXBsZS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2l6ZTsgaysrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5taW5WYWx1ZXNba10gPSBNYXRoLm1pbihfdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlc1trXSwgaW5wdXRWYWx1ZXNba10pO1xuICAgICAgICAgICAgICAgIF90aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzW2tdID0gTWF0aC5tYXgoX3RoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5tYXhWYWx1ZXNba10sIGlucHV0VmFsdWVzW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLm5vcm1hbGl6ZVdpdGhpbkJvdW5kcyA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgaXMgbnVsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YUluZGV4ID49IHRoaXMuZGF0YXNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YUluZGV4IG91dCBvZiBib3VuZHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZHMoZGF0YUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyTG93ZXJCb3VuZHM7XG4gICAgICAgIHZhciBjdXJVcHBlckJvdW5kcztcbiAgICAgICAgaWYgKHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5pc05vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgIGN1ckxvd2VyQm91bmRzID0gdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmxvd2VyQm91bmQ7XG4gICAgICAgICAgICBjdXJVcHBlckJvdW5kcyA9IHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS51cHBlckJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VyTG93ZXJCb3VuZHMgPSB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzO1xuICAgICAgICAgICAgY3VyVXBwZXJCb3VuZHMgPSB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdID0gdGhpcy5ub3JtYWxpemVFeGFtcGxlc1RvUmFuZ2UodGhpcy5kYXRhc2V0W2RhdGFJbmRleF0sIGN1ckxvd2VyQm91bmRzLCBjdXJVcHBlckJvdW5kcywgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCk7XG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5pc05vcm1hbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubG93ZXJCb3VuZCA9IGxvd2VyQm91bmQ7XG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS51cHBlckJvdW5kID0gdXBwZXJCb3VuZDtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUuaXNOb3JtYWxpemVkID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemF0aW9uSW5mbyAhPSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0uaXNOb3JtYWxpemVkO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5yZW1vdmVOb3JtYWxpemF0aW9uID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhaW5pbmcgb3IgdGVzdCBkYXRhIGlzIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzTm9ybWFsaXplZChkYXRhSW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhc2V0W2RhdGFJbmRleF0gPSB0aGlzLm5vcm1hbGl6ZUV4YW1wbGVzVG9SYW5nZSh0aGlzLmRhdGFzZXRbZGF0YUluZGV4XSwgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmxvd2VyQm91bmQsIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS51cHBlckJvdW5kLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzKTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmlzTm9ybWFsaXplZCA9IGZhbHNlO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS51bm5vcm1hbGl6ZUV4YW1wbGVzID0gZnVuY3Rpb24gKGV4YW1wbGVzLCBkYXRhSW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTm9ybWFsaXplZChkYXRhSW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhhbXBsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplRXhhbXBsZXNUb1JhbmdlKGV4YW1wbGVzLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubG93ZXJCb3VuZCwgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLnVwcGVyQm91bmQsIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5taW5WYWx1ZXMsIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5tYXhWYWx1ZXMpO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YXNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmRhdGFzZXRbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFzZXRbaV1bal0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YXNldCA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIEluTWVtb3J5RGF0YXNldDtcbn0oKSk7XG5leHBvcnRzLkluTWVtb3J5RGF0YXNldCA9IEluTWVtb3J5RGF0YXNldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGFzZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcihpbnB1dHMpIHtcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRoaXMuaWR4ID0gMDtcbiAgICAgICAgdGhpcy5pbnB1dENvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLmVwb2NoID0gMDtcbiAgICAgICAgdGhpcy5zaHVmZmxlZEluZGljZXMgPSB1dGlsLmNyZWF0ZVNodWZmbGVkSW5kaWNlcyhpbnB1dHNbMF0ubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5udW1JbnB1dHMgPSBpbnB1dHMubGVuZ3RoO1xuICAgICAgICB2YXIgbnVtRXhhbXBsZXMgPSB0aGlzLmlucHV0c1swXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5udW1JbnB1dHM7IGkrKykge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5pbnB1dHNbaV0ubGVuZ3RoID09PSBudW1FeGFtcGxlcywgJ051bWJlciBvZiBleGFtcGxlcyBtdXN0IG1hdGNoIGFjcm9zcyBkaWZmZXJlbnQgaW5wdXRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5udW1JbnB1dHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlucHV0U2hhcGUgPSB0aGlzLmlucHV0c1tpXVswXS5zaGFwZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5pbnB1dHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGlucHV0U2hhcGUsIHRoaXMuaW5wdXRzW2ldW2pdLnNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIucHJvdG90eXBlLmdldEN1cnJlbnRFeGFtcGxlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXR1cm5JZHggPSB0aGlzLmlkeDtcbiAgICAgICAgdGhpcy5pbnB1dENvdW50ZXIrKztcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRDb3VudGVyID49IHRoaXMubnVtSW5wdXRzKSB7XG4gICAgICAgICAgICB0aGlzLmlkeCsrO1xuICAgICAgICAgICAgdGhpcy5pbnB1dENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuaWR4ID49IHRoaXMuaW5wdXRzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaWR4ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmVwb2NoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVybklkeDtcbiAgICB9O1xuICAgIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUuZ2V0TmV4dElucHV0ID0gZnVuY3Rpb24gKGlucHV0SWQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRFeGFtcGxlSW5kZXggPSB0aGlzLmdldEN1cnJlbnRFeGFtcGxlSW5kZXgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRzW2lucHV0SWRdW3RoaXMuc2h1ZmZsZWRJbmRpY2VzW2N1cnJlbnRFeGFtcGxlSW5kZXhdXTtcbiAgICB9O1xuICAgIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUuZ2V0RXBvY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVwb2NoO1xuICAgIH07XG4gICAgSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS5nZXRJbnB1dFByb3ZpZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0UHJvdmlkZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5udW1JbnB1dHM7IGkrKykge1xuICAgICAgICAgICAgaW5wdXRQcm92aWRlcnMucHVzaCh0aGlzLmdldElucHV0UHJvdmlkZXIoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dFByb3ZpZGVycztcbiAgICB9O1xuICAgIHJldHVybiBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG59KCkpO1xuZXhwb3J0cy5Jbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG52YXIgSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIucHJvdG90eXBlLmdldElucHV0UHJvdmlkZXIgPSBmdW5jdGlvbiAoaW5wdXRJZCkge1xuICAgICAgICB2YXIgc2h1ZmZsZWRJbnB1dFByb3ZpZGVyID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldE5leHRDb3B5OiBmdW5jdGlvbiAobWF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5saWtlKHNodWZmbGVkSW5wdXRQcm92aWRlci5nZXROZXh0SW5wdXQoaW5wdXRJZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc3Bvc2VDb3B5OiBmdW5jdGlvbiAobWF0aCwgY29weSkge1xuICAgICAgICAgICAgICAgIGNvcHkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbn0oSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyKSk7XG5leHBvcnRzLkluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciA9IEluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbnZhciBJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUuZ2V0SW5wdXRQcm92aWRlciA9IGZ1bmN0aW9uIChpbnB1dElkKSB7XG4gICAgICAgIHZhciBzaHVmZmxlZElucHV0UHJvdmlkZXIgPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0TmV4dENvcHk6IGZ1bmN0aW9uIChtYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGguY2xvbmUoc2h1ZmZsZWRJbnB1dFByb3ZpZGVyLmdldE5leHRJbnB1dChpbnB1dElkKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzcG9zZUNvcHk6IGZ1bmN0aW9uIChtYXRoLCBjb3B5KSB7XG4gICAgICAgICAgICAgICAgY29weS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyO1xufShJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIpKTtcbmV4cG9ydHMuSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5wdXRfcHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBkYXRhc2V0XzEgPSByZXF1aXJlKFwiLi9kYXRhc2V0XCIpO1xudmFyIFBBUlNJTkdfSU1BR0VfQ0FOVkFTX0hFSUdIVF9QWCA9IDEwMDA7XG5mdW5jdGlvbiBnZXRYaHJEYXRhc2V0Q29uZmlnKGpzb25Db25maWdQYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignR0VUJywganNvbkNvbmZpZ1BhdGgpO1xuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5zZW5kKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmdldFhockRhdGFzZXRDb25maWcgPSBnZXRYaHJEYXRhc2V0Q29uZmlnO1xudmFyIFhockRhdGFzZXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYaHJEYXRhc2V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFhockRhdGFzZXQoeGhyRGF0YXNldENvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB4aHJEYXRhc2V0Q29uZmlnLmRhdGEubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNoYXBlOyB9KSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueGhyRGF0YXNldENvbmZpZyA9IHhockRhdGFzZXRDb25maWc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWGhyRGF0YXNldC5wcm90b3R5cGUuZ2V0TkRBcnJheSA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIHZhciBkYXRhUHJvbWlzZSA9IGluZm8uZGF0YVR5cGUgPT09ICdwbmcnID9cbiAgICAgICAgICAgIHBhcnNlVHlwZWRBcnJheUZyb21QbmcoaW5mbywgaW5mby5zaGFwZSkgOlxuICAgICAgICAgICAgcGFyc2VUeXBlZEFycmF5RnJvbUJpbmFyeShpbmZvKTtcbiAgICAgICAgcmV0dXJuIGRhdGFQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoaW5mby5zaGFwZSk7XG4gICAgICAgICAgICB2YXIgbmRhcnJheXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLyBpbnB1dFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBkYXRhLnN1YmFycmF5KGkgKiBpbnB1dFNpemUsIChpICsgMSkgKiBpbnB1dFNpemUpO1xuICAgICAgICAgICAgICAgIHZhciBuZGFycmF5ID0gbmRhcnJheV8xLk5EQXJyYXkubWFrZShpbmZvLnNoYXBlLCB7IHZhbHVlczogbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMpIH0pO1xuICAgICAgICAgICAgICAgIG5kYXJyYXlzLnB1c2gobmRhcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmRhcnJheXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgWGhyRGF0YXNldC5wcm90b3R5cGUuZmV0Y2hEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gX3RoaXMueGhyRGF0YXNldENvbmZpZy5kYXRhLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gX3RoaXMuZ2V0TkRBcnJheSh4KTsgfSk7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRhdGFzZXQgPSBkYXRhO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBYaHJEYXRhc2V0O1xufShkYXRhc2V0XzEuSW5NZW1vcnlEYXRhc2V0KSk7XG5leHBvcnRzLlhockRhdGFzZXQgPSBYaHJEYXRhc2V0O1xuZnVuY3Rpb24gcGFyc2VUeXBlZEFycmF5RnJvbUJpbmFyeShpbmZvKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignR0VUJywgaW5mby5wYXRoKTtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gKGluZm8uZGF0YVR5cGUgPT09ICdmbG9hdDMyJykgP1xuICAgICAgICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoeGhyLnJlc3BvbnNlKSA6XG4gICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikgeyByZXR1cm4gcmVqZWN0KGVycik7IH07XG4gICAgICAgIHhoci5zZW5kKCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZUdyYXlzY2FsZUltYWdlRGF0YShkYXRhLCByZXN1bHQsIHJlc3VsdE9mZnNldCkge1xuICAgIHZhciBpZHggPSByZXN1bHRPZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHJlc3VsdFtpZHgrK10gPSBkYXRhW2ldO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUkdCSW1hZ2VEYXRhKGRhdGEsIHJlc3VsdCwgcmVzdWx0T2Zmc2V0KSB7XG4gICAgdmFyIGlkeCA9IHJlc3VsdE9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgcmVzdWx0W2lkeF0gPSBkYXRhW2ldO1xuICAgICAgICByZXN1bHRbaWR4ICsgMV0gPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgcmVzdWx0W2lkeCArIDJdID0gZGF0YVtpICsgMl07XG4gICAgICAgIGlkeCArPSAzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSW1hZ2UoaW1nLCBzaGFwZSkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIE4gPSBpbWcuaGVpZ2h0O1xuICAgIHZhciBpbnB1dFNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpO1xuICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShOICogaW5wdXRTaXplKTtcbiAgICBpZiAoaW1nLndpZHRoICE9PSBzaGFwZVswXSAqIHNoYXBlWzFdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkltYWdlIHdpZHRoIChcIiArIGltZy53aWR0aCArIFwiKSBtdXN0IGJlIG11bHRpcGxlIG9mIFwiICtcbiAgICAgICAgICAgIChcInJvd3MqY29sdW1ucyAoXCIgKyBzaGFwZVswXSArIFwiKlwiICsgc2hhcGVbMV0gKyBcIikgb2YgdGhlIG5kYXJyYXlcIikpO1xuICAgIH1cbiAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IFBBUlNJTkdfSU1BR0VfQ0FOVkFTX0hFSUdIVF9QWDtcbiAgICB2YXIgc3ggPSAwO1xuICAgIHZhciBzV2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgdmFyIHNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgIHZhciBkeCA9IDA7XG4gICAgdmFyIGR5ID0gMDtcbiAgICB2YXIgZFdpZHRoID0gc1dpZHRoO1xuICAgIHZhciBkSGVpZ2h0ID0gc0hlaWdodDtcbiAgICB2YXIgZGVwdGggPSBzaGFwZVsyXTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgbnVtUGFzc2VzID0gTWF0aC5jZWlsKE4gLyBjYW52YXMuaGVpZ2h0KTtcbiAgICBmb3IgKHZhciBwYXNzID0gMDsgcGFzcyA8IG51bVBhc3NlczsgKytwYXNzKSB7XG4gICAgICAgIHZhciBzeSA9IHBhc3MgKiBjYW52YXMuaGVpZ2h0O1xuICAgICAgICBpZiAoKHBhc3MgPT09IG51bVBhc3NlcyAtIDEpICYmIChOICUgY2FudmFzLmhlaWdodCA+IDApKSB7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gTiAlIGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICBzSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIGRIZWlnaHQgPSBzSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCBzeCwgc3ksIHNXaWR0aCwgc0hlaWdodCwgZHgsIGR5LCBkV2lkdGgsIGRIZWlnaHQpO1xuICAgICAgICB2YXIgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KS5kYXRhO1xuICAgICAgICAoZGVwdGggPT09IDEpID8gcGFyc2VHcmF5c2NhbGVJbWFnZURhdGEoZGF0YSwgcmVzdWx0LCBvZmZzZXQpIDpcbiAgICAgICAgICAgIHBhcnNlUkdCSW1hZ2VEYXRhKGRhdGEsIHJlc3VsdCwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGNhbnZhcy5oZWlnaHQgKiBpbnB1dFNpemU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZVR5cGVkQXJyYXlGcm9tUG5nKGluZm8sIHNoYXBlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWcuc2V0QXR0cmlidXRlKCdjcm9zc09yaWdpbicsICcnKTtcbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUltYWdlKGltZywgc2hhcGUpO1xuICAgICAgICAgICAgaW1nLnNyYyA9ICcnO1xuICAgICAgICAgICAgaW1nID0gbnVsbDtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLnNyYyA9IGluZm8ucGF0aDtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhoci1kYXRhc2V0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gICAgdmFyIGEgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8IG5hdmlnYXRvci52ZW5kb3IgfHwgd2luZG93Lm9wZXJhO1xuICAgIHJldHVybiAvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2lcbiAgICAgICAgLnRlc3QoYSkgfHxcbiAgICAgICAgLzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2lcbiAgICAgICAgICAgIC50ZXN0KGEuc3Vic3RyKDAsIDQpKTtcbn1cbmV4cG9ydHMuaXNNb2JpbGUgPSBpc01vYmlsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldmljZV91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRldmljZV91dGlsID0gcmVxdWlyZShcIi4vZGV2aWNlX3V0aWxcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIFR5cGVbVHlwZVtcIk5VTUJFUlwiXSA9IDBdID0gXCJOVU1CRVJcIjtcbiAgICBUeXBlW1R5cGVbXCJCT09MRUFOXCJdID0gMV0gPSBcIkJPT0xFQU5cIjtcbn0pKFR5cGUgPSBleHBvcnRzLlR5cGUgfHwgKGV4cG9ydHMuVHlwZSA9IHt9KSk7XG5leHBvcnRzLlVSTF9QUk9QRVJUSUVTID0gW1xuICAgIHsgbmFtZTogJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9FTkFCTEVEJywgdHlwZTogVHlwZS5CT09MRUFOIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFJywgdHlwZTogVHlwZS5CT09MRUFOIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfVkVSU0lPTicsIHR5cGU6IFR5cGUuTlVNQkVSIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJywgdHlwZTogVHlwZS5CT09MRUFOIH0sIHtcbiAgICAgICAgbmFtZTogJ1dFQkdMX0dFVF9CVUZGRVJfU1VCX0RBVEFfQVNZTkNfRVhURU5TSU9OX0VOQUJMRUQnLFxuICAgICAgICB0eXBlOiBUeXBlLkJPT0xFQU5cbiAgICB9XG5dO1xuZnVuY3Rpb24gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbikge1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LCBXZWJHTCBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gICAgdmFyIHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBpZiAod2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIHJldHVybiAodGVtcENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8XG4gICAgICAgICAgICB0ZW1wQ2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJyk7XG59XG5mdW5jdGlvbiBsb3NlQ29udGV4dChnbCkge1xuICAgIGlmIChnbCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBsb3NlQ29udGV4dEV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG4gICAgICAgIGlmIChsb3NlQ29udGV4dEV4dGVuc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBXRUJHTF9sb3NlX2NvbnRleHQgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbG9zZUNvbnRleHRFeHRlbnNpb24ubG9zZUNvbnRleHQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1dlYkdMVmVyc2lvbkVuYWJsZWQod2ViR0xWZXJzaW9uKSB7XG4gICAgdmFyIGdsID0gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbik7XG4gICAgaWYgKGdsICE9IG51bGwpIHtcbiAgICAgICAgbG9zZUNvbnRleHQoZ2wpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNXZWJHTERpc2pvaW50UXVlcnlUaW1lckVuYWJsZWQod2ViR0xWZXJzaW9uKSB7XG4gICAgdmFyIGdsID0gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbik7XG4gICAgdmFyIGV4dGVuc2lvbk5hbWUgPSB3ZWJHTFZlcnNpb24gPT09IDEgPyAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5JyA6XG4gICAgICAgICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyJztcbiAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUpO1xuICAgIHZhciBpc0V4dEVuYWJsZWQgPSBleHQgIT0gbnVsbDtcbiAgICBpZiAoZ2wgIT0gbnVsbCkge1xuICAgICAgICBsb3NlQ29udGV4dChnbCk7XG4gICAgfVxuICAgIHJldHVybiBpc0V4dEVuYWJsZWQ7XG59XG5mdW5jdGlvbiBpc0Zsb2F0VGV4dHVyZVJlYWRQaXhlbHNFbmFibGVkKHdlYkdMVmVyc2lvbikge1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZ2wgPSBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICBpZiAod2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIGlmIChnbC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JykgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JykgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBmcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgdmFyIGludGVybmFsRm9ybWF0ID0gd2ViR0xWZXJzaW9uID09PSAyID8gZ2wuUkdCQTMyRiA6IGdsLlJHQkE7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgdmFyIGZyYW1lQnVmZmVyQ29tcGxldGUgPSAoZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUikgPT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKTtcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIDEsIDEsIGdsLlJHQkEsIGdsLkZMT0FULCBuZXcgRmxvYXQzMkFycmF5KDQpKTtcbiAgICB2YXIgcmVhZFBpeGVsc05vRXJyb3IgPSBnbC5nZXRFcnJvcigpID09PSBnbC5OT19FUlJPUjtcbiAgICBsb3NlQ29udGV4dChnbCk7XG4gICAgcmV0dXJuIGZyYW1lQnVmZmVyQ29tcGxldGUgJiYgcmVhZFBpeGVsc05vRXJyb3I7XG59XG5mdW5jdGlvbiBpc1dlYkdMR2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uRW5hYmxlZCh3ZWJHTFZlcnNpb24pIHtcbiAgICBpZiAod2ViR0xWZXJzaW9uICE9PSAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGdsID0gZ2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0KHdlYkdMVmVyc2lvbik7XG4gICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfZ2V0X2J1ZmZlcl9zdWJfZGF0YV9hc3luYycpO1xuICAgIHZhciBpc0VuYWJsZWQgPSBleHQgIT0gbnVsbDtcbiAgICBsb3NlQ29udGV4dChnbCk7XG4gICAgcmV0dXJuIGlzRW5hYmxlZDtcbn1cbnZhciBFbnZpcm9ubWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW52aXJvbm1lbnQoZmVhdHVyZXMpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IHt9O1xuICAgICAgICBpZiAoZmVhdHVyZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICBpZiAoZmVhdHVyZSBpbiB0aGlzLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1tmZWF0dXJlXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZlYXR1cmVzW2ZlYXR1cmVdID0gdGhpcy5ldmFsdWF0ZUZlYXR1cmUoZmVhdHVyZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzW2ZlYXR1cmVdO1xuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLmV2YWx1YXRlRmVhdHVyZSA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGlmIChmZWF0dXJlID09PSAnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX0VOQUJMRUQnKSB7XG4gICAgICAgICAgICB2YXIgd2ViR0xWZXJzaW9uID0gdGhpcy5nZXQoJ1dFQkdMX1ZFUlNJT04nKTtcbiAgICAgICAgICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNXZWJHTERpc2pvaW50UXVlcnlUaW1lckVuYWJsZWQod2ViR0xWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmZWF0dXJlID09PSAnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fRU5BQkxFRCcpICYmXG4gICAgICAgICAgICAgICAgIWRldmljZV91dGlsLmlzTW9iaWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX1ZFUlNJT04nKSB7XG4gICAgICAgICAgICBpZiAoaXNXZWJHTFZlcnNpb25FbmFibGVkKDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1dlYkdMVmVyc2lvbkVuYWJsZWQoMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZlYXR1cmUgPT09ICdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGbG9hdFRleHR1cmVSZWFkUGl4ZWxzRW5hYmxlZCh0aGlzLmdldCgnV0VCR0xfVkVSU0lPTicpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmZWF0dXJlID09PSAnV0VCR0xfR0VUX0JVRkZFUl9TVUJfREFUQV9BU1lOQ19FWFRFTlNJT05fRU5BQkxFRCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1dlYkdMR2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uRW5hYmxlZCh0aGlzLmdldCgnV0VCR0xfVkVSU0lPTicpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZlYXR1cmUgXCIgKyBmZWF0dXJlICsgXCIuXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIEVudmlyb25tZW50O1xufSgpKTtcbmV4cG9ydHMuRW52aXJvbm1lbnQgPSBFbnZpcm9ubWVudDtcbnZhciBERUVQTEVBUk5KU19GTEFHU19QUkVGSVggPSAnZGxqc2ZsYWdzJztcbmZ1bmN0aW9uIGdldEZlYXR1cmVzRnJvbVVSTCgpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSB7fTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgIH1cbiAgICB2YXIgdXJsUGFyYW1zID0gdXRpbC5nZXRRdWVyeVBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICBpZiAoREVFUExFQVJOSlNfRkxBR1NfUFJFRklYIGluIHVybFBhcmFtcykge1xuICAgICAgICB2YXIgdXJsRmxhZ3NfMSA9IHt9O1xuICAgICAgICB2YXIga2V5VmFsdWVzID0gdXJsUGFyYW1zW0RFRVBMRUFSTkpTX0ZMQUdTX1BSRUZJWF0uc3BsaXQoJywnKTtcbiAgICAgICAga2V5VmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKGtleVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBrZXlWYWx1ZS5zcGxpdCgnOicpLCBrZXkgPSBfYVswXSwgdmFsdWUgPSBfYVsxXTtcbiAgICAgICAgICAgIHVybEZsYWdzXzFba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgZXhwb3J0cy5VUkxfUFJPUEVSVElFUy5mb3JFYWNoKGZ1bmN0aW9uICh1cmxQcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKHVybFByb3BlcnR5Lm5hbWUgaW4gdXJsRmxhZ3NfMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2V0dGluZyBmZWF0dXJlIG92ZXJyaWRlIGZyb20gVVJMIFwiICsgdXJsUHJvcGVydHkubmFtZSArIFwiOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIlwiICsgdXJsRmxhZ3NfMVt1cmxQcm9wZXJ0eS5uYW1lXSkpO1xuICAgICAgICAgICAgICAgIGlmICh1cmxQcm9wZXJ0eS50eXBlID09PSBUeXBlLk5VTUJFUikge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlc1t1cmxQcm9wZXJ0eS5uYW1lXSA9ICt1cmxGbGFnc18xW3VybFByb3BlcnR5Lm5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1cmxQcm9wZXJ0eS50eXBlID09PSBUeXBlLkJPT0xFQU4pIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXNbdXJsUHJvcGVydHkubmFtZV0gPSB1cmxGbGFnc18xW3VybFByb3BlcnR5Lm5hbWVdID09PSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIFVSTCBwYXJhbTogXCIgKyB1cmxQcm9wZXJ0eS5uYW1lICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbn1cbmV4cG9ydHMuRU5WID0gbmV3IEVudmlyb25tZW50KGdldEZlYXR1cmVzRnJvbVVSTCgpKTtcbmZ1bmN0aW9uIHNldEVudmlyb25tZW50KGVudmlyb25tZW50KSB7XG4gICAgZXhwb3J0cy5FTlYgPSBlbnZpcm9ubWVudDtcbn1cbmV4cG9ydHMuc2V0RW52aXJvbm1lbnQgPSBzZXRFbnZpcm9ubWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudmlyb25tZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaW5pdGlhbGl6ZXJzXzEgPSByZXF1aXJlKFwiLi4vaW5pdGlhbGl6ZXJzXCIpO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4uL21hdGgvY29uY2F0X3V0aWxcIik7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4uL21hdGgvY29udl91dGlsXCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIEdyYXBoTGF5ZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmFwaExheWVycyhnKSB7XG4gICAgICAgIHRoaXMuZyA9IGc7XG4gICAgfVxuICAgIEdyYXBoTGF5ZXJzLnByb3RvdHlwZS5kZW5zZSA9IGZ1bmN0aW9uIChuYW1lLCB4LCB1bml0cywgYWN0aXZhdGlvbiwgdXNlQmlhcywga2VybmVsSW5pdGlhbGl6ZXIsIGJpYXNJbml0aWFsaXplcikge1xuICAgICAgICBpZiAoYWN0aXZhdGlvbiA9PT0gdm9pZCAwKSB7IGFjdGl2YXRpb24gPSBudWxsOyB9XG4gICAgICAgIGlmICh1c2VCaWFzID09PSB2b2lkIDApIHsgdXNlQmlhcyA9IHRydWU7IH1cbiAgICAgICAgaWYgKGtlcm5lbEluaXRpYWxpemVyID09PSB2b2lkIDApIHsga2VybmVsSW5pdGlhbGl6ZXIgPSBuZXcgaW5pdGlhbGl6ZXJzXzEuVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXIoKTsgfVxuICAgICAgICBpZiAoYmlhc0luaXRpYWxpemVyID09PSB2b2lkIDApIHsgYmlhc0luaXRpYWxpemVyID0gbmV3IGluaXRpYWxpemVyc18xLlplcm9zSW5pdGlhbGl6ZXIoKTsgfVxuICAgICAgICB2YXIgd2VpZ2h0cyA9IHRoaXMuZy52YXJpYWJsZShuYW1lICsgJy13ZWlnaHRzJywga2VybmVsSW5pdGlhbGl6ZXIuaW5pdGlhbGl6ZShbeC5zaGFwZVswXSwgdW5pdHNdLCB4LnNoYXBlWzBdLCB1bml0cykpO1xuICAgICAgICB2YXIgb3V0ID0gdGhpcy5nLm1hdG11bCh4LCB3ZWlnaHRzKTtcbiAgICAgICAgaWYgKHVzZUJpYXMpIHtcbiAgICAgICAgICAgIHZhciBiaWFzID0gdGhpcy5nLnZhcmlhYmxlKG5hbWUgKyAnLWJpYXMnLCBiaWFzSW5pdGlhbGl6ZXIuaW5pdGlhbGl6ZShbdW5pdHNdLCB4LnNoYXBlWzBdLCB1bml0cykpO1xuICAgICAgICAgICAgb3V0ID0gdGhpcy5nLmFkZChvdXQsIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIG91dCA9IGFjdGl2YXRpb24ob3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgcmV0dXJuIEdyYXBoTGF5ZXJzO1xufSgpKTtcbmV4cG9ydHMuR3JhcGhMYXllcnMgPSBHcmFwaExheWVycztcbnZhciBHcmFwaCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGgoKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sYXllcnMgPSBuZXcgR3JhcGhMYXllcnModGhpcyk7XG4gICAgfVxuICAgIEdyYXBoLnByb3RvdHlwZS52YXJpYWJsZSA9IGZ1bmN0aW9uIChuYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFZhcmlhYmxlTm9kZSh0aGlzLCBuYW1lLCBkYXRhKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAobmFtZSwgc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgUGxhY2Vob2xkZXJOb2RlKHRoaXMsIG5hbWUsIHNoYXBlKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuY29uc3RhbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpbmFsVmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gbmRhcnJheV8xLlNjYWxhci5uZXcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB2YXIgZmxhdFZhbHVlcyA9IHV0aWwuZmxhdHRlbih2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgdmFscyA9IG5ldyBGbG9hdDMyQXJyYXkoZmxhdFZhbHVlcyk7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gbmRhcnJheV8xLk5EQXJyYXkubWFrZSh1dGlsLmluZmVyU2hhcGUodmFsdWUpLCB7IHZhbHVlczogdmFscyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCBjb25zdGFudCB0eXBlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IENvbnN0YW50Tm9kZSh0aGlzLCBmaW5hbFZhbHVlKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUucmVzaGFwZSA9IGZ1bmN0aW9uICh4LCBzaGFwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBSZXNoYXBlTm9kZSh0aGlzLCAnUmVzaGFwZScsIHgsIHNoYXBlKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuZnVzZWRMaW5lYXJDb21iaW5hdGlvbiA9IGZ1bmN0aW9uICh4MSwgeDIsIGMxLCBjMikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSh0aGlzLCB4MSwgeDIsIGMxLCBjMikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQWRkTm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU3VidHJhY3ROb2RlKHRoaXMsIHgxLCB4MikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBNdWx0aXBseU5vZGUodGhpcywgeDEsIHgyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBEaXZpZGVOb2RlKHRoaXMsIHgxLCB4MikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnJlZHVjZVN1bSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFJlZHVjZVN1bU5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmNvbmNhdDNkID0gZnVuY3Rpb24gKHgxLCB4MiwgYXhpcykge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBDb25jYXQzRE5vZGUodGhpcywgeDEsIHgyLCBheGlzKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUubWF0bXVsID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBNYXRNdWxOb2RlKHRoaXMsIHgxLCB4MikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmNvbnYyZCA9IGZ1bmN0aW9uICh4LCB3LCBiLCBmaWVsZFNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsIHplcm9QYWQpIHtcbiAgICAgICAgaWYgKHN0cmlkZSA9PT0gdm9pZCAwKSB7IHN0cmlkZSA9IDE7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQ29udm9sdXRpb24yRE5vZGUodGhpcywgeCwgdywgYiwgZmllbGRTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUubWF4UG9vbCA9IGZ1bmN0aW9uICh4LCBmaWVsZFNpemUsIHN0cmlkZSwgemVyb1BhZCkge1xuICAgICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHsgc3RyaWRlID0gMTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBNYXhQb29sTm9kZSh0aGlzLCB4LCBmaWVsZFNpemUsIHN0cmlkZSwgemVyb1BhZCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IEV4cE5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IExvZ05vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnJlbHUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBSZUxVTm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUubGVha3lSZWx1ID0gZnVuY3Rpb24gKHgsIGFscGhhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IExlYWt5UmVMVU5vZGUodGhpcywgeCwgYWxwaGEpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS50YW5oID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgVGFuSE5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnNpZ21vaWQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBTaWdtb2lkTm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU3F1YXJlTm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuc29mdG1heCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFNvZnRtYXhOb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5zb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCA9IGZ1bmN0aW9uICh4LCB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlKHRoaXMsIHgsIHRhcmdldCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLm1lYW5TcXVhcmVkQ29zdCA9IGZ1bmN0aW9uIChsYWJlbCwgcHJlZGljdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBNZWFuU3F1YXJlZENvc3ROb2RlKHRoaXMsIGxhYmVsLCBwcmVkaWN0aW9uKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuYXJnbWF4ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQXJnTWF4Tm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuYXJnbWF4RXF1YWxzID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBBcmdNYXhFcXVhbHNOb2RlKHRoaXMsIHgxLCB4MikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUudmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIG5vZGUub3V0cHV0O1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmdldE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9O1xuICAgIHJldHVybiBHcmFwaDtcbn0oKSk7XG5leHBvcnRzLkdyYXBoID0gR3JhcGg7XG52YXIgVGVuc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW5zb3Ioc2hhcGUpIHtcbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlO1xuICAgICAgICB0aGlzLmlkID0gVGVuc29yLm5leHRJRCsrO1xuICAgIH1cbiAgICBUZW5zb3IubmV4dElEID0gMDtcbiAgICByZXR1cm4gVGVuc29yO1xufSgpKTtcbmV4cG9ydHMuVGVuc29yID0gVGVuc29yO1xudmFyIE5vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGUoZ3JhcGgsIG5hbWUsIGlucHV0cywgb3V0cHV0KSB7XG4gICAgICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gb3V0cHV0O1xuICAgICAgICB0aGlzLmlkID0gTm9kZS5uZXh0SUQrKztcbiAgICAgICAgb3V0cHV0Lm5vZGUgPSB0aGlzO1xuICAgIH1cbiAgICBOb2RlLm5leHRJRCA9IDA7XG4gICAgcmV0dXJuIE5vZGU7XG59KCkpO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbnZhciBWYXJpYWJsZU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWYXJpYWJsZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmFyaWFibGVOb2RlKGdyYXBoLCBuYW1lLCBkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCBuYW1lLCB7fSwgbmV3IFRlbnNvcihkYXRhLnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVmFyaWFibGVOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5kYXRhICE9IG51bGwsICdFcnJvciBhZGRpbmcgdmFyaWFibGUgb3A6IERhdGEgZm9yIHZhcmlhYmxlIFxcJycgKyB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgJ1xcJyBpcyBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIFZhcmlhYmxlTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5WYXJpYWJsZU5vZGUgPSBWYXJpYWJsZU5vZGU7XG52YXIgUGxhY2Vob2xkZXJOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGxhY2Vob2xkZXJOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBsYWNlaG9sZGVyTm9kZShncmFwaCwgbmFtZSwgc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCBuYW1lLCB7fSwgbmV3IFRlbnNvcihzaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIFBsYWNlaG9sZGVyTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIFBsYWNlaG9sZGVyTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5QbGFjZWhvbGRlck5vZGUgPSBQbGFjZWhvbGRlck5vZGU7XG52YXIgQ29uc3RhbnROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uc3RhbnROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnN0YW50Tm9kZShncmFwaCwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0NvbnN0YW50Jywge30sIG5ldyBUZW5zb3IoZGF0YS5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbnN0YW50Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMuZGF0YSAhPSBudWxsLCAnRXJyb3IgYWRkaW5nIGNvbnN0YW50OiBkYXRhIGZvciBwbGFjZWhvbGRlciBcXCcnICsgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICdcXCcgaXMgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBDb25zdGFudE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQ29uc3RhbnROb2RlID0gQ29uc3RhbnROb2RlO1xudmFyIFJlc2hhcGVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzaGFwZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVzaGFwZU5vZGUoZ3JhcGgsIG5hbWUsIHgsIHNoYXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCBuYW1lLCB7IHg6IHggfSwgbmV3IFRlbnNvcihzaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgX3RoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZXNoYXBlTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB4U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnguc2hhcGUpO1xuICAgICAgICB2YXIgc2hhcGVTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMuc2hhcGUpO1xuICAgICAgICB1dGlsLmFzc2VydCh4U2l6ZSA9PT0gc2hhcGVTaXplLCBcIkVycm9yIG1ha2luZyByZXNoYXBlIG9wZXJhdGlvbjogaW5wdXQgdG8gcmVzaGFwZSAnXCIgKyB0aGlzLm5hbWUgKyBcIidcIiArXG4gICAgICAgICAgICAoXCIgb2Ygc2hhcGUgKFwiICsgdGhpcy54LnNoYXBlICsgXCIpIGRvZXMgbm90IG1hdGNoIHNpemUgb2YgXCIpICtcbiAgICAgICAgICAgIChcInJlcXVlc3RlZCBzaGFwZSBcIiArIHRoaXMuc2hhcGUgKyBcIi5cIikpO1xuICAgIH07XG4gICAgUmVzaGFwZU5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gUmVzaGFwZU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuUmVzaGFwZU5vZGUgPSBSZXNoYXBlTm9kZTtcbnZhciBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlKGdyYXBoLCB0MSwgdDIsIGMxLCBjMikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0xpbmVhciBDb21iaW5hdGlvbicsIHsgdDE6IHQxLCB0MjogdDIsIGMxOiBjMSwgYzI6IGMyIH0sIG5ldyBUZW5zb3IodDEuc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50MSA9IHQxO1xuICAgICAgICBfdGhpcy50MiA9IHQyO1xuICAgICAgICBfdGhpcy5jMSA9IGMxO1xuICAgICAgICBfdGhpcy5jMiA9IGMyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaCh0aGlzLnQxLnNoYXBlLCB0aGlzLnQyLnNoYXBlKTtcbiAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyU2hhcGUodGhpcy5jMS5zaGFwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWRkaW5nIGZ1c2VkTGluZWFyQ29tYmluYXRpb246IGMxIGlzIG5vdCBhIHNjYWxhciwgZ290ICcgK1xuICAgICAgICAgICAgICAgIChcInNoYXBlOiBcIiArIHRoaXMuYzEuc2hhcGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXJTaGFwZSh0aGlzLmMyLnNoYXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZGRpbmcgZnVzZWRMaW5lYXJDb21iaW5hdGlvbjogYzIgaXMgbm90IGEgc2NhbGFyLCBnb3QgJyArXG4gICAgICAgICAgICAgICAgKFwic2hhcGU6IFwiICsgdGhpcy5jMi5zaGFwZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5UMSA9ICd0MSc7XG4gICAgRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuVDIgPSAndDInO1xuICAgIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLkMxID0gJ2MxJztcbiAgICBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5DMiA9ICdjMic7XG4gICAgcmV0dXJuIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlID0gRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGU7XG52YXIgQWRkTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkZE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWRkTm9kZShncmFwaCwgdDEsIHQyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQWRkJywgeyB0MTogdDEsIHQyOiB0MiB9LCBuZXcgVGVuc29yKHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgPyB0Mi5zaGFwZSA6IHQxLnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudDEgPSB0MTtcbiAgICAgICAgX3RoaXMudDIgPSB0MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSksICdFcnJvciBhZGRpbmcgYWRkIG9wZXJhdGlvbiBvcDogb25lIG9mIGlucHV0cyBtdXN0IGJlIHNjYWxhciBvciB0aGUgJyArXG4gICAgICAgICAgICAoXCJzaGFwZXMgXCIgKyB0aGlzLnQxLnNoYXBlICsgXCIgYW5kIFwiICsgdGhpcy50Mi5zaGFwZSArIFwiIG11c3QgbWF0Y2guXCIpKTtcbiAgICB9O1xuICAgIEFkZE5vZGUuVDEgPSAndDEnO1xuICAgIEFkZE5vZGUuVDIgPSAndDInO1xuICAgIHJldHVybiBBZGROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkFkZE5vZGUgPSBBZGROb2RlO1xudmFyIFN1YnRyYWN0Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnRyYWN0Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJ0cmFjdE5vZGUoZ3JhcGgsIHQxLCB0Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1N1YnRyYWN0JywgeyB0MTogdDEsIHQyOiB0MiB9LCBuZXcgVGVuc29yKHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgPyB0Mi5zaGFwZSA6IHQxLnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudDEgPSB0MTtcbiAgICAgICAgX3RoaXMudDIgPSB0MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdWJ0cmFjdE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50MS5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQyLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh0aGlzLnQxLnNoYXBlLCB0aGlzLnQyLnNoYXBlKSwgJ0Vycm9yIGFkZGluZyBzdWJ0cmFjdCBvcDogb25lIG9mIGlucHV0cyBtdXN0IGJlIHNjYWxhciBvciB0aGUgJyArXG4gICAgICAgICAgICAoXCJzaGFwZXMgXCIgKyB0aGlzLnQxLnNoYXBlICsgXCIgYW5kIFwiICsgdGhpcy50Mi5zaGFwZSArIFwiIG11c3QgbWF0Y2guXCIpKTtcbiAgICB9O1xuICAgIFN1YnRyYWN0Tm9kZS5UMSA9ICd0MSc7XG4gICAgU3VidHJhY3ROb2RlLlQyID0gJ3QyJztcbiAgICByZXR1cm4gU3VidHJhY3ROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlN1YnRyYWN0Tm9kZSA9IFN1YnRyYWN0Tm9kZTtcbnZhciBNdWx0aXBseU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNdWx0aXBseU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTXVsdGlwbHlOb2RlKGdyYXBoLCB0MSwgdDIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdNdWx0aXBseScsIHsgdDE6IHQxLCB0MjogdDIgfSwgbmV3IFRlbnNvcih1dGlsLnNpemVGcm9tU2hhcGUodDEuc2hhcGUpID09PSAxID8gdDIuc2hhcGUgOiB0MS5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnQxID0gdDE7XG4gICAgICAgIF90aGlzLnQyID0gdDI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTXVsdGlwbHlOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSksICdFcnJvciBhZGRpbmcgbXVsdGlwbHkgb3A6IG9uZSBvZiBpbnB1dHMgbXVzdCBiZSBzY2FsYXIgb3IgdGhlICcgK1xuICAgICAgICAgICAgKFwic2hhcGVzIFwiICsgdGhpcy50MS5zaGFwZSArIFwiIGFuZCBcIiArIHRoaXMudDIuc2hhcGUgKyBcIiBtdXN0IG1hdGNoLlwiKSk7XG4gICAgfTtcbiAgICBNdWx0aXBseU5vZGUuVDEgPSAndDEnO1xuICAgIE11bHRpcGx5Tm9kZS5UMiA9ICd0Mic7XG4gICAgcmV0dXJuIE11bHRpcGx5Tm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5NdWx0aXBseU5vZGUgPSBNdWx0aXBseU5vZGU7XG52YXIgRGl2aWRlTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpdmlkZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGl2aWRlTm9kZShncmFwaCwgdDEsIHQyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnRGl2aWRlJywgeyB0MTogdDEsIHQyOiB0MiB9LCBuZXcgVGVuc29yKHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgPyB0Mi5zaGFwZSA6IHQxLnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudDEgPSB0MTtcbiAgICAgICAgX3RoaXMudDIgPSB0MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEaXZpZGVOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSksICdFcnJvciBhZGRpbmcgZGl2aWRlIG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyIG9yIHRoZSAnICtcbiAgICAgICAgICAgIChcInNoYXBlcyBcIiArIHRoaXMudDEuc2hhcGUgKyBcIiBhbmQgXCIgKyB0aGlzLnQyLnNoYXBlICsgXCIgbXVzdCBtYXRjaC5cIikpO1xuICAgIH07XG4gICAgRGl2aWRlTm9kZS5UMSA9ICd0MSc7XG4gICAgRGl2aWRlTm9kZS5UMiA9ICd0Mic7XG4gICAgcmV0dXJuIERpdmlkZU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuRGl2aWRlTm9kZSA9IERpdmlkZU5vZGU7XG52YXIgUmVkdWNlU3VtTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZHVjZVN1bU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVkdWNlU3VtTm9kZShncmFwaCwgeCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdSZWR1Y2VTdW0nLCB7IHg6IHggfSwgbmV3IFRlbnNvcihbXSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIFJlZHVjZVN1bU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFJlZHVjZVN1bU5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gUmVkdWNlU3VtTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5SZWR1Y2VTdW1Ob2RlID0gUmVkdWNlU3VtTm9kZTtcbnZhciBDb25jYXQzRE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25jYXQzRE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uY2F0M0ROb2RlKGdyYXBoLCB4MSwgeDIsIGF4aXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdDb25jYXQzRCcsIHsgeDE6IHgxLCB4MjogeDIgfSwgbmV3IFRlbnNvcihjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoeDEuc2hhcGUsIHgyLnNoYXBlLCBheGlzKSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxID0geDE7XG4gICAgICAgIF90aGlzLngyID0geDI7XG4gICAgICAgIF90aGlzLmF4aXMgPSBheGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbmNhdDNETm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbmNhdF91dGlsLmFzc2VydFBhcmFtcyh0aGlzLngxLnNoYXBlLCB0aGlzLngyLnNoYXBlLCB0aGlzLmF4aXMpO1xuICAgIH07XG4gICAgQ29uY2F0M0ROb2RlLlgxID0gJ3gxJztcbiAgICBDb25jYXQzRE5vZGUuWDIgPSAneDInO1xuICAgIENvbmNhdDNETm9kZS5BWElTID0gJ2F4aXMnO1xuICAgIHJldHVybiBDb25jYXQzRE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQ29uY2F0M0ROb2RlID0gQ29uY2F0M0ROb2RlO1xuZnVuY3Rpb24gZ2V0TWF0TXVsT3V0cHV0U2hhcGUoeDFTaGFwZSwgeDJTaGFwZSkge1xuICAgIGlmICh4MVNoYXBlLmxlbmd0aCA9PT0gMSAmJiB4MlNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gWzFdO1xuICAgIH1cbiAgICBlbHNlIGlmICh4MVNoYXBlLmxlbmd0aCA9PT0gMSAmJiB4MlNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gW3gyU2hhcGVbMV1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh4MVNoYXBlLmxlbmd0aCA9PT0gMiAmJiB4MlNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gW3gxU2hhcGVbMF1dO1xuICAgIH1cbiAgICByZXR1cm4gW3gxU2hhcGVbMF0sIHgyU2hhcGVbMV1dO1xufVxudmFyIE1hdE11bE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXRNdWxOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hdE11bE5vZGUoZ3JhcGgsIHgxLCB4Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ01hdE11bCcsIHsgeDE6IHgxLCB4MjogeDIgfSwgbmV3IFRlbnNvcihnZXRNYXRNdWxPdXRwdXRTaGFwZSh4MS5zaGFwZSwgeDIuc2hhcGUpKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDEgPSB4MTtcbiAgICAgICAgX3RoaXMueDIgPSB4MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYXRNdWxOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMueDEuc2hhcGUubGVuZ3RoID09PSAyICYmIHRoaXMueDIuc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh0aGlzLngxLnNoYXBlWzFdID09PSB0aGlzLngyLnNoYXBlWzBdLCAnRXJyb3IgYWRkaW5nIG1hdG11bCBvcDogaW5uZXIgc2hhcGVzIG9mIG1hdHJpY2VzIHdpdGggc2hhcGVzICcgK1xuICAgICAgICAgICAgICAgICh0aGlzLngxLnNoYXBlICsgXCIgYW5kIFwiICsgdGhpcy54Mi5zaGFwZSArIFwiIG11c3QgbWF0Y2guXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLngxLnNoYXBlLmxlbmd0aCA9PT0gMiAmJiB0aGlzLngyLnNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54MS5zaGFwZVsxXSA9PT0gdGhpcy54Mi5zaGFwZVswXSwgJ0Vycm9yIGFkZGluZyBtYXRtdWwgb3A6IHNlY29uZCBkaW1lbnNpb24gb2YgbWF0cml4IHdpdGggc2hhcGUgJyArXG4gICAgICAgICAgICAgICAgdGhpcy54MS5zaGFwZS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAoXCIgbXVzdCBtYXRjaCBzaXplIG9mIHZlY3RvciB3aXRoIHNoYXBlIFwiICsgdGhpcy54Mi5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy54MS5zaGFwZS5sZW5ndGggPT09IDEgJiYgdGhpcy54Mi5zaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueDEuc2hhcGVbMF0gPT09IHRoaXMueDIuc2hhcGVbMF0sIFwiRXJyb3IgYWRkaW5nIG1hdG11bCBvcDogc2l6ZSBvZiB2ZWN0b3Igd2l0aCBzaGFwZSBcIiArIHRoaXMueDEuc2hhcGUgK1xuICAgICAgICAgICAgICAgIFwiIG11c3QgbWF0Y2ggZmlyc3QgZGltZW5zaW9uIG9mIG1hdHJpeCB3aXRoIFwiICtcbiAgICAgICAgICAgICAgICAoXCJzaGFwZSBcIiArIHRoaXMueDIuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZGRpbmcgbWF0bXVsIG9wOiBpbnB1dHMgbXVzdCBiZSB2ZWN0b3JzIG9yIG1hdHJpY2VzLicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRNdWxOb2RlLlgxID0gJ3gxJztcbiAgICBNYXRNdWxOb2RlLlgyID0gJ3gyJztcbiAgICByZXR1cm4gTWF0TXVsTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5NYXRNdWxOb2RlID0gTWF0TXVsTm9kZTtcbnZhciBDb252b2x1dGlvbjJETm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnZvbHV0aW9uMkROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnZvbHV0aW9uMkROb2RlKGdyYXBoLCB4LCB3LCBiLCBmaWVsZFNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsIHplcm9QYWQpIHtcbiAgICAgICAgaWYgKHN0cmlkZSA9PT0gdm9pZCAwKSB7IHN0cmlkZSA9IDE7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdDb252b2x1dGlvbiAyRCcsIHsgeDogeCwgdzogdywgYjogYiB9LCBuZXcgVGVuc29yKGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRCh4LnNoYXBlLCBmaWVsZFNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsIHplcm9QYWQpKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueCA9IHg7XG4gICAgICAgIF90aGlzLncgPSB3O1xuICAgICAgICBfdGhpcy5iID0gYjtcbiAgICAgICAgX3RoaXMuZmllbGRTaXplID0gZmllbGRTaXplO1xuICAgICAgICBfdGhpcy5vdXRwdXREZXB0aCA9IG91dHB1dERlcHRoO1xuICAgICAgICBfdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gICAgICAgIF90aGlzLnplcm9QYWQgPSB6ZXJvUGFkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbnZvbHV0aW9uMkROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54LnNoYXBlLmxlbmd0aCA9PT0gMywgJ0Vycm9yIGFkZGluZyBjb252MmQgb3A6IGlucHV0IG11c3QgYmUgb2YgcmFuayAzLCBidXQgZ290IHNoYXBlOiAnICtcbiAgICAgICAgICAgICh0aGlzLnguc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLncuc2hhcGUubGVuZ3RoID09PSA0LCAnRXJyb3IgYWRkaW5nIGNvbnYyZCBvcDogd2VpZ2h0cyBtdXN0IGJlIG9mIHJhbmsgNCwgYnV0IGdvdCBzaGFwZTogJyArXG4gICAgICAgICAgICAodGhpcy53LnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5iLnNoYXBlLmxlbmd0aCA9PT0gMSwgJ0Vycm9yIGFkZGluZyBjb252MmQgb3A6IGJpYXNlcyBtdXN0IGJlIG9mIHJhbmsgMSwgYnV0IGdvdCBzaGFwZTogJyArXG4gICAgICAgICAgICAodGhpcy5iLnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54LnNoYXBlWzJdID09PSB0aGlzLncuc2hhcGVbMl0sIFwiRXJyb3IgYWRkaW5nIGNvbnYyZCBvcDogZGVwdGggb2YgaW5wdXQgKFwiICsgdGhpcy54LnNoYXBlWzJdICsgXCIpIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIHdlaWdodHMgKFwiICsgdGhpcy53LnNoYXBlWzJdICsgXCIpLlwiKSk7XG4gICAgfTtcbiAgICBDb252b2x1dGlvbjJETm9kZS5YID0gJ3gnO1xuICAgIENvbnZvbHV0aW9uMkROb2RlLlcgPSAndyc7XG4gICAgQ29udm9sdXRpb24yRE5vZGUuQiA9ICdiJztcbiAgICByZXR1cm4gQ29udm9sdXRpb24yRE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQ29udm9sdXRpb24yRE5vZGUgPSBDb252b2x1dGlvbjJETm9kZTtcbnZhciBNYXhQb29sTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1heFBvb2xOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1heFBvb2xOb2RlKGdyYXBoLCB4LCBmaWVsZFNpemUsIHN0cmlkZSwgemVyb1BhZCkge1xuICAgICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHsgc3RyaWRlID0gMTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ01heCBwb29sJywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoY29udl91dGlsLmNvbXB1dGVPdXRwdXRTaGFwZTNEKHguc2hhcGUsIGZpZWxkU2l6ZSwgeC5zaGFwZVsyXSwgc3RyaWRlLCB6ZXJvUGFkKSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnggPSB4O1xuICAgICAgICBfdGhpcy5maWVsZFNpemUgPSBmaWVsZFNpemU7XG4gICAgICAgIF90aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgICAgICAgX3RoaXMuemVyb1BhZCA9IHplcm9QYWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWF4UG9vbE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnguc2hhcGUubGVuZ3RoID09PSAzLCAnRXJyb3IgYWRkaW5nIG1heFBvb2wgb3A6IGlucHV0IG11c3QgYmUgb2YgcmFuayAzLCBidXQgZ290IHNoYXBlOiAnICtcbiAgICAgICAgICAgICh0aGlzLnguc2hhcGUgKyBcIi5cIikpO1xuICAgIH07XG4gICAgTWF4UG9vbE5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gTWF4UG9vbE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuTWF4UG9vbE5vZGUgPSBNYXhQb29sTm9kZTtcbnZhciBSZUxVTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlTFVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlTFVOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1JlTFUnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgUmVMVU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFJlTFVOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFJlTFVOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlJlTFVOb2RlID0gUmVMVU5vZGU7XG52YXIgTGVha3lSZUxVTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExlYWt5UmVMVU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGVha3lSZUxVTm9kZShncmFwaCwgeCwgYWxwaGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdMZWFreVJlTFUnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYWxwaGEgPSBhbHBoYTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMZWFreVJlTFVOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBMZWFreVJlTFVOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIExlYWt5UmVMVU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuTGVha3lSZUxVTm9kZSA9IExlYWt5UmVMVU5vZGU7XG52YXIgRXhwTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4cE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXhwTm9kZShncmFwaCwgeCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdFeHAnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgRXhwTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgRXhwTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBFeHBOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkV4cE5vZGUgPSBFeHBOb2RlO1xudmFyIExvZ05vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2dOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExvZ05vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnTG9nJywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIExvZ05vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIExvZ05vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gTG9nTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5Mb2dOb2RlID0gTG9nTm9kZTtcbnZhciBUYW5ITm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhbkhOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhbkhOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1RhbkgnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgVGFuSE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFRhbkhOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFRhbkhOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlRhbkhOb2RlID0gVGFuSE5vZGU7XG52YXIgU2lnbW9pZE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaWdtb2lkTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaWdtb2lkTm9kZShncmFwaCwgeCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdTaWdtb2lkJywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNpZ21vaWROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBTaWdtb2lkTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBTaWdtb2lkTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5TaWdtb2lkTm9kZSA9IFNpZ21vaWROb2RlO1xudmFyIFNxdWFyZU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTcXVhcmVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNxdWFyZU5vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnU3F1YXJlJywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNxdWFyZU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFNxdWFyZU5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gU3F1YXJlTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5TcXVhcmVOb2RlID0gU3F1YXJlTm9kZTtcbnZhciBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlKGdyYXBoLCB4LCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCcsIHsgeDogeCwgdGFyZ2V0OiB0YXJnZXQgfSwgbmV3IFRlbnNvcihbXSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnggPSB4O1xuICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5hcnJheXNFcXVhbCh0aGlzLnguc2hhcGUsIHRoaXMudGFyZ2V0LnNoYXBlKSwgXCJFcnJvciBhZGRpbmcgc29mdG1heENyb3NzRW50cm9weUNvc3Qgb3A6IHggc2hhcGUgKFwiICsgdGhpcy54LnNoYXBlICsgXCIpIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggdGFyZ2V0IHNoYXBlIChcIiArIHRoaXMudGFyZ2V0LnNoYXBlICsgXCIpLlwiKSk7XG4gICAgfTtcbiAgICBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUuWCA9ICd4JztcbiAgICBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUuVEFSR0VUID0gJ3RhcmdldCc7XG4gICAgcmV0dXJuIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5Tb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUgPSBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGU7XG52YXIgU29mdG1heE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTb2Z0bWF4Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTb2Z0bWF4Tm9kZShncmFwaCwgeCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1NvZnRtYXgnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueCA9IHg7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU29mdG1heE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnguc2hhcGUubGVuZ3RoID09PSAxLCAnVGhlIGlucHV0IHRvIGEgc29mdG1heCBtdXN0IGJlIGEgMS1EIHRlbnNvcicpO1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnguc2hhcGVbMF0gPj0gMiwgJ1RoZSBpbnB1dCB0byBhIHNvZnRtYXggbXVzdCBoYXZlIGF0IGxlYXN0IDIgdmFsdWVzJyk7XG4gICAgfTtcbiAgICBTb2Z0bWF4Tm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBTb2Z0bWF4Tm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5Tb2Z0bWF4Tm9kZSA9IFNvZnRtYXhOb2RlO1xudmFyIE1lYW5TcXVhcmVkQ29zdE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZWFuU3F1YXJlZENvc3ROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lYW5TcXVhcmVkQ29zdE5vZGUoZ3JhcGgsIGxhYmVsLCBwcmVkaWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnTWVhbiBTcXVhcmVkIENvc3QnLCB7IGxhYmVsOiBsYWJlbCwgcHJlZGljdGlvbjogcHJlZGljdGlvbiB9LCBuZXcgVGVuc29yKFtdKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgX3RoaXMucHJlZGljdGlvbiA9IHByZWRpY3Rpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWVhblNxdWFyZWRDb3N0Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuYXJyYXlzRXF1YWwodGhpcy5sYWJlbC5zaGFwZSwgdGhpcy5wcmVkaWN0aW9uLnNoYXBlKSwgXCJFcnJvciBhZGRpbmcgbWVhblNxdWFyZWRDb3N0IG9wOiBsYWJlbCBzaGFwZSAoXCIgKyB0aGlzLmxhYmVsLnNoYXBlICsgXCIpIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggcHJlZGljdGlvbiBzaGFwZSAoXCIgKyB0aGlzLnByZWRpY3Rpb24uc2hhcGUgKyBcIikuXCIpKTtcbiAgICB9O1xuICAgIE1lYW5TcXVhcmVkQ29zdE5vZGUuTEFCRUwgPSAnbGFiZWwnO1xuICAgIE1lYW5TcXVhcmVkQ29zdE5vZGUuUFJFRElDVElPTiA9ICdwcmVkaWN0aW9uJztcbiAgICByZXR1cm4gTWVhblNxdWFyZWRDb3N0Tm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5NZWFuU3F1YXJlZENvc3ROb2RlID0gTWVhblNxdWFyZWRDb3N0Tm9kZTtcbnZhciBBcmdNYXhOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJnTWF4Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcmdNYXhOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQXJnTWF4JywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoWzFdKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueCA9IHg7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJnTWF4Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnguc2hhcGUpID4gMCwgJ0Vycm9yIGFkZGluZyBhcmdtYXggb3A6IGlucHV0IHRlbnNvciBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVudHJ5LicpO1xuICAgIH07XG4gICAgQXJnTWF4Tm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBBcmdNYXhOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkFyZ01heE5vZGUgPSBBcmdNYXhOb2RlO1xudmFyIEFyZ01heEVxdWFsc05vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcmdNYXhFcXVhbHNOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFyZ01heEVxdWFsc05vZGUoZ3JhcGgsIHgxLCB4Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0FyZ01heEVxdWFscycsIHsgeDE6IHgxLCB4MjogeDIgfSwgbmV3IFRlbnNvcihbMV0pKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MSA9IHgxO1xuICAgICAgICBfdGhpcy54MiA9IHgyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFyZ01heEVxdWFsc05vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmFycmF5c0VxdWFsKHRoaXMueDEuc2hhcGUsIHRoaXMueDIuc2hhcGUpLCBcIkVycm9yIGFkZGluZyBBcmdNYXhFcXVhbHMgb3A6IHgxIHNoYXBlIChcIiArIHRoaXMueDEuc2hhcGUgKyBcIikgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCB4MiBzaGFwZSAoXCIgKyB0aGlzLngyLnNoYXBlICsgXCIpLlwiKSk7XG4gICAgfTtcbiAgICBBcmdNYXhFcXVhbHNOb2RlLlgxID0gJ3gxJztcbiAgICBBcmdNYXhFcXVhbHNOb2RlLlgyID0gJ3gyJztcbiAgICByZXR1cm4gQXJnTWF4RXF1YWxzTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5BcmdNYXhFcXVhbHNOb2RlID0gQXJnTWF4RXF1YWxzTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYXBoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYXBoXzEgPSByZXF1aXJlKFwiLi9ncmFwaFwiKTtcbnZhciBwcmlvcml0eV9xdWV1ZSA9IHJlcXVpcmUoXCIuL3ByaW9yaXR5X3F1ZXVlXCIpO1xudmFyIHByaW9yaXR5X3F1ZXVlXzEgPSByZXF1aXJlKFwiLi9wcmlvcml0eV9xdWV1ZVwiKTtcbmZ1bmN0aW9uIGdldFVub3JkZXJlZEV2YWx1YXRpb25TZXQobm9kZXMsIHRlcm1pbmF0aW5nTm9kZXMpIHtcbiAgICB2YXIgdGVybWluYXRpbmdOb2RlTWFwID0ge307XG4gICAgdmFyIHNlZW4gPSB7fTtcbiAgICB2YXIgc2V0ID0gW107XG4gICAgdmFyIHZpc2l0ID0gbm9kZXMuc2xpY2UoKTtcbiAgICB0ZXJtaW5hdGluZ05vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRlcm1pbmF0aW5nTm9kZU1hcFtub2RlLmlkXSA9IG5vZGU7IH0pO1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VyID0gdmlzaXQucG9wKCk7XG4gICAgICAgIGlmIChzZWVuW2N1ci5pZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRlcm1pbmF0aW5nTm9kZU1hcFtjdXIuaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjdXIuaW5wdXRzKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpbnB1dE5hbWUpIHsgcmV0dXJuIGN1ci5pbnB1dHNbaW5wdXROYW1lXTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiB2aXNpdC5wdXNoKGlucHV0Lm5vZGUpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldC5wdXNoKGN1cik7XG4gICAgICAgICAgICBzZWVuW2N1ci5pZF0gPSBjdXI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlICh2aXNpdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgX2xvb3BfMSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xufVxuZXhwb3J0cy5nZXRVbm9yZGVyZWRFdmFsdWF0aW9uU2V0ID0gZ2V0VW5vcmRlcmVkRXZhbHVhdGlvblNldDtcbmZ1bmN0aW9uIGdldE9yZGVyZWRFdmFsdWF0aW9uU2V0KHVub3JkZXJlZEV2YWx1YXRpb25TZXQpIHtcbiAgICB2YXIgc2V0ID0gW107XG4gICAgdmFyIG5vZGVJbmRpY2VzID0ge307XG4gICAgdmFyIHBlbmRpbmdEZXBlbmRlbmNpZXMgPSB7fTtcbiAgICB2YXIgbm9kZVF1ZXVlID0gbmV3IHByaW9yaXR5X3F1ZXVlXzEuUHJpb3JpdHlRdWV1ZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gcHJpb3JpdHlfcXVldWUuZGVmYXVsdENvbXBhcmUocGVuZGluZ0RlcGVuZGVuY2llc1thLmlkXSwgcGVuZGluZ0RlcGVuZGVuY2llc1tiLmlkXSk7IH0sIGZ1bmN0aW9uIChub2RlLCBuZXdJbmRleCkgeyByZXR1cm4gbm9kZUluZGljZXNbbm9kZS5pZF0gPSBuZXdJbmRleDsgfSk7XG4gICAgdW5vcmRlcmVkRXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBwZW5kaW5nRGVwZW5kZW5jaWVzW25vZGUuaWRdID0gMDsgfSk7XG4gICAgdW5vcmRlcmVkRXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBPYmplY3Qua2V5cyhub2RlLmlucHV0cylcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBub2RlLmlucHV0c1trZXldOyB9KVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKHVub3JkZXJlZEV2YWx1YXRpb25TZXQuaW5kZXhPZihpbnB1dC5ub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHBlbmRpbmdEZXBlbmRlbmNpZXNbaW5wdXQubm9kZS5pZF0rKztcbiAgICAgICAgfVxuICAgIH0pOyB9KTtcbiAgICB1bm9yZGVyZWRFdmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGVRdWV1ZS5lbnF1ZXVlKG5vZGUpOyB9KTtcbiAgICB3aGlsZSAoIW5vZGVRdWV1ZS5lbXB0eSgpKSB7XG4gICAgICAgIHNldC51bnNoaWZ0KG5vZGVRdWV1ZS5kZXF1ZXVlKCkpO1xuICAgICAgICBPYmplY3Qua2V5cyhzZXRbMF0uaW5wdXRzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc2V0WzBdLmlucHV0c1trZXldOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgaWYgKHVub3JkZXJlZEV2YWx1YXRpb25TZXQuaW5kZXhPZihpbnB1dC5ub2RlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZW5kaW5nRGVwZW5kZW5jaWVzW2lucHV0Lm5vZGUuaWRdLS07XG4gICAgICAgICAgICBub2RlUXVldWUudXBkYXRlKGlucHV0Lm5vZGUsIG5vZGVJbmRpY2VzW2lucHV0Lm5vZGUuaWRdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG59XG5leHBvcnRzLmdldE9yZGVyZWRFdmFsdWF0aW9uU2V0ID0gZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXQ7XG5mdW5jdGlvbiBpc0lucHV0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG5vZGUuaW5wdXRzKS5sZW5ndGggPT09IDA7XG59XG5leHBvcnRzLmlzSW5wdXROb2RlID0gaXNJbnB1dE5vZGU7XG5mdW5jdGlvbiBzaG91bGRCYWNrUHJvcCh0KSB7XG4gICAgcmV0dXJuICEodC5ub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Db25zdGFudE5vZGUpO1xufVxuZXhwb3J0cy5zaG91bGRCYWNrUHJvcCA9IHNob3VsZEJhY2tQcm9wO1xuZnVuY3Rpb24gaXNQYXNzdGhyb3VnaE5vZGUobm9kZSwgbWFwKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2RlLmlucHV0cyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IG5vZGUuaW5wdXRzW2tleXNbaV1dO1xuICAgICAgICBpZiAobWFwLmdldChpbnB1dCwgdHJ1ZSkgPT09IG1hcC5nZXQobm9kZS5vdXRwdXQsIHRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzUGFzc3Rocm91Z2hOb2RlID0gaXNQYXNzdGhyb3VnaE5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmFwaF91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYXBoXzEgPSByZXF1aXJlKFwiLi9ncmFwaFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBhZGRfMSA9IHJlcXVpcmUoXCIuL29wcy9hZGRcIik7XG52YXIgYXJnbWF4XzEgPSByZXF1aXJlKFwiLi9vcHMvYXJnbWF4XCIpO1xudmFyIGFyZ21heGVxdWFsc18xID0gcmVxdWlyZShcIi4vb3BzL2FyZ21heGVxdWFsc1wiKTtcbnZhciBjb25jYXQzZF8xID0gcmVxdWlyZShcIi4vb3BzL2NvbmNhdDNkXCIpO1xudmFyIGNvbnZvbHV0aW9uXzEgPSByZXF1aXJlKFwiLi9vcHMvY29udm9sdXRpb25cIik7XG52YXIgZGl2aWRlXzEgPSByZXF1aXJlKFwiLi9vcHMvZGl2aWRlXCIpO1xudmFyIGVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcHMvZWxlbWVudF93aXNlX2FjdGl2YXRpb25cIik7XG52YXIgZWxlbWVudF93aXNlX2Nvc3RfMSA9IHJlcXVpcmUoXCIuL29wcy9lbGVtZW50X3dpc2VfY29zdFwiKTtcbnZhciBleHBfMSA9IHJlcXVpcmUoXCIuL29wcy9leHBcIik7XG52YXIgbGluZWFyX2NvbWJpbmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcHMvbGluZWFyX2NvbWJpbmF0aW9uXCIpO1xudmFyIGxvZ18xID0gcmVxdWlyZShcIi4vb3BzL2xvZ1wiKTtcbnZhciBtYXRtdWxfMSA9IHJlcXVpcmUoXCIuL29wcy9tYXRtdWxcIik7XG52YXIgbWF4X3Bvb2xfMSA9IHJlcXVpcmUoXCIuL29wcy9tYXhfcG9vbFwiKTtcbnZhciBtdWx0aXBseV8xID0gcmVxdWlyZShcIi4vb3BzL211bHRpcGx5XCIpO1xudmFyIHJlZHVjZV9zdW1fMSA9IHJlcXVpcmUoXCIuL29wcy9yZWR1Y2Vfc3VtXCIpO1xudmFyIHJlc2hhcGVfMSA9IHJlcXVpcmUoXCIuL29wcy9yZXNoYXBlXCIpO1xudmFyIHNvZnRtYXhfMSA9IHJlcXVpcmUoXCIuL29wcy9zb2Z0bWF4XCIpO1xudmFyIHN1YnRyYWN0XzEgPSByZXF1aXJlKFwiLi9vcHMvc3VidHJhY3RcIik7XG5mdW5jdGlvbiBlbWl0RnJvbUdyYXBoTm9kZXMobm9kZXMpIHtcbiAgICB2YXIgb3BzID0gW107XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkob3BzLCBlbWl0T3BGcm9tTm9kZShub2RlKSk7IH0pO1xuICAgIHJldHVybiBvcHM7XG59XG5leHBvcnRzLmVtaXRGcm9tR3JhcGhOb2RlcyA9IGVtaXRGcm9tR3JhcGhOb2RlcztcbmZ1bmN0aW9uIGVtaXRPcEZyb21Ob2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuUmVzaGFwZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgcmVzaGFwZV8xLlJlc2hhcGUobm9kZS5pbnB1dHNbZ3JhcGhfMS5SZXNoYXBlTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuTWF0TXVsTm9kZSkge1xuICAgICAgICB2YXIgeDEgPSBub2RlLmlucHV0c1tncmFwaF8xLk1hdE11bE5vZGUuWDFdO1xuICAgICAgICB2YXIgeDIgPSBub2RlLmlucHV0c1tncmFwaF8xLk1hdE11bE5vZGUuWDJdO1xuICAgICAgICByZXR1cm4gW25ldyBtYXRtdWxfMS5NYXRNdWwoeDEsIHgyLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Db252b2x1dGlvbjJETm9kZSkge1xuICAgICAgICB2YXIgdyA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuQ29udm9sdXRpb24yRE5vZGUuV107XG4gICAgICAgIHZhciB4ID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5Db252b2x1dGlvbjJETm9kZS5YXTtcbiAgICAgICAgdmFyIGIgPSBub2RlLmlucHV0c1tncmFwaF8xLkNvbnZvbHV0aW9uMkROb2RlLkJdO1xuICAgICAgICByZXR1cm4gW25ldyBjb252b2x1dGlvbl8xLkNvbnZvbHV0aW9uMkQodywgeCwgYiwgbm9kZS5vdXRwdXQsIG5vZGUuZmllbGRTaXplLCBub2RlLm91dHB1dERlcHRoLCBub2RlLnN0cmlkZSwgbm9kZS56ZXJvUGFkKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLk1heFBvb2xOb2RlKSB7XG4gICAgICAgIHZhciB4ID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5NYXhQb29sTm9kZS5YXTtcbiAgICAgICAgcmV0dXJuIFtuZXcgbWF4X3Bvb2xfMS5NYXhQb29sKHgsIG5vZGUub3V0cHV0LCBub2RlLmZpZWxkU2l6ZSwgbm9kZS5zdHJpZGUsIG5vZGUuemVyb1BhZCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5FeHBOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGV4cF8xLkV4cChub2RlLmlucHV0c1tncmFwaF8xLkV4cE5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkxvZ05vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgbG9nXzEuTG9nKG5vZGUuaW5wdXRzW2dyYXBoXzEuTG9nTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuUmVMVU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgZWxlbWVudF93aXNlX2FjdGl2YXRpb25fMS5SZUxVKG5vZGUuaW5wdXRzW2dyYXBoXzEuUmVMVU5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkxlYWt5UmVMVU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgZWxlbWVudF93aXNlX2FjdGl2YXRpb25fMS5MZWFreVJlTFUobm9kZS5pbnB1dHNbZ3JhcGhfMS5MZWFreVJlTFVOb2RlLlhdLCBub2RlLm91dHB1dCwgbm9kZS5hbHBoYSldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5UYW5ITm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xLlRhbkgobm9kZS5pbnB1dHNbZ3JhcGhfMS5UYW5ITm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuU2lnbW9pZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgZWxlbWVudF93aXNlX2FjdGl2YXRpb25fMS5TaWdtb2lkKG5vZGUuaW5wdXRzW2dyYXBoXzEuU2lnbW9pZE5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSkge1xuICAgICAgICB2YXIgeCA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlLlhdO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5Tb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUuVEFSR0VUXTtcbiAgICAgICAgcmV0dXJuIFtuZXcgc29mdG1heF8xLlNvZnRtYXhDcm9zc0VudHJvcHlDb3N0KHgsIHRhcmdldCwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuU29mdG1heE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgc29mdG1heF8xLlNvZnRtYXgobm9kZS5pbnB1dHNbZ3JhcGhfMS5Tb2Z0bWF4Tm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuTWVhblNxdWFyZWRDb3N0Tm9kZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBub2RlLmlucHV0c1tncmFwaF8xLk1lYW5TcXVhcmVkQ29zdE5vZGUuTEFCRUxdO1xuICAgICAgICB2YXIgcHJlZGljdGlvbiA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuTWVhblNxdWFyZWRDb3N0Tm9kZS5QUkVESUNUSU9OXTtcbiAgICAgICAgcmV0dXJuIFtuZXcgZWxlbWVudF93aXNlX2Nvc3RfMS5NZWFuU3F1YXJlZENvc3QobGFiZWwsIHByZWRpY3Rpb24sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkFyZ01heEVxdWFsc05vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgYXJnbWF4ZXF1YWxzXzEuQXJnTWF4RXF1YWxzKG5vZGUuaW5wdXRzW2dyYXBoXzEuQXJnTWF4RXF1YWxzTm9kZS5YMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuQXJnTWF4RXF1YWxzTm9kZS5YMl0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkFyZ01heE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgYXJnbWF4XzEuQXJnTWF4KG5vZGUueCwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgbGluZWFyX2NvbWJpbmF0aW9uXzEuTGluZWFyQ29tYmluYXRpb24obm9kZS5pbnB1dHNbZ3JhcGhfMS5GdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5UMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuVDJdLCBub2RlLmlucHV0c1tncmFwaF8xLkZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLkMxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5GdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5DMl0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkNvbmNhdDNETm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBjb25jYXQzZF8xLkNvbmNhdDNEKG5vZGUuaW5wdXRzW2dyYXBoXzEuQ29uY2F0M0ROb2RlLlgxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5Db25jYXQzRE5vZGUuWDJdLCBub2RlLmF4aXMsIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlNxdWFyZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgZWxlbWVudF93aXNlX2FjdGl2YXRpb25fMS5TcXVhcmUobm9kZS5pbnB1dHNbZ3JhcGhfMS5TcXVhcmVOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5BZGROb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGFkZF8xLkFkZChub2RlLmlucHV0c1tncmFwaF8xLkFkZE5vZGUuVDFdLCBub2RlLmlucHV0c1tncmFwaF8xLkFkZE5vZGUuVDJdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5TdWJ0cmFjdE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgc3VidHJhY3RfMS5TdWJ0cmFjdChub2RlLmlucHV0c1tncmFwaF8xLlN1YnRyYWN0Tm9kZS5UMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuU3VidHJhY3ROb2RlLlQyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuTXVsdGlwbHlOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IG11bHRpcGx5XzEuTXVsdGlwbHkobm9kZS5pbnB1dHNbZ3JhcGhfMS5NdWx0aXBseU5vZGUuVDFdLCBub2RlLmlucHV0c1tncmFwaF8xLk11bHRpcGx5Tm9kZS5UMl0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkRpdmlkZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgZGl2aWRlXzEuRGl2aWRlKG5vZGUuaW5wdXRzW2dyYXBoXzEuRGl2aWRlTm9kZS5UMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuRGl2aWRlTm9kZS5UMl0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlJlZHVjZVN1bU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgcmVkdWNlX3N1bV8xLlJlZHVjZVN1bShub2RlLmlucHV0c1tncmFwaF8xLlJlZHVjZVN1bU5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGdyYXBoX3V0aWwuaXNJbnB1dE5vZGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBub2RlIHR5cGU6IFwiICsgbm9kZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGVyYXRpb25fZW1pdHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgQWRkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkZCh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh4MVRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh4MlRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwoeDFUZW5zb3Iuc2hhcGUsIHgyVGVuc29yLnNoYXBlKSwgJ09uZSBvZiB0MSBvciB0MiBtdXN0IGJlIGEgc2NhbGFyLCBvciB0MSBhbmQgdDIgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgJ3RoZSBzYW1lIHNoYXBlJyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWRkLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoeDEuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJQbHVzQXJyYXkoeDEsIHgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh4Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhclBsdXNBcnJheSh4MiwgeDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5hZGQoeDEsIHgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBZGQucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZShfdGhpcy54MVRlbnNvci5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IG1hdGguc3VtKGR5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmR5U2l6ZVNjYWxhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5keVNpemVTY2FsYXIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhkeS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguZGl2aWRlKHN1bSwgX3RoaXMuZHlTaXplU2NhbGFyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguY2xvbmUoZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKF90aGlzLngyVGVuc29yLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gbWF0aC5zdW0oZHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZHlTaXplU2NhbGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmR5U2l6ZVNjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KGR5LnNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgbWF0aC5kaXZpZGUoc3VtLCBfdGhpcy5keVNpemVTY2FsYXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgbWF0aC5jbG9uZShkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBZGQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmR5U2l6ZVNjYWxhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmR5U2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBZGQ7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkFkZCA9IEFkZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBBcmdNYXggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcmdNYXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJnTWF4KHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFyZ01heC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5hcmdNYXgoeCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcmdNYXgucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmdNYXggYmFja3Byb3AgdW5pbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIEFyZ01heDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuQXJnTWF4ID0gQXJnTWF4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJnbWF4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIEFyZ01heEVxdWFscyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFyZ01heEVxdWFscywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcmdNYXhFcXVhbHMoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFyZ01heEVxdWFscy5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChtYXRoLmFyZ01heEVxdWFscyh4MSwgeDIpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXJnTWF4RXF1YWxzLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJnTWF4RXF1YWxzIGJhY2twcm9wIHVuaW1wbGVtZW50ZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBBcmdNYXhFcXVhbHM7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkFyZ01heEVxdWFscyA9IEFyZ01heEVxdWFscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyZ21heGVxdWFscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4uLy4uL21hdGgvY29uY2F0X3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIENvbmNhdDNEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uY2F0M0QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uY2F0M0QoeDFUZW5zb3IsIHgyVGVuc29yLCBheGlzLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLmF4aXMgPSBheGlzO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKHgxVGVuc29yLnNoYXBlLCB4MlRlbnNvci5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uY2F0M0QucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICB2YXIgY29uY2F0UmVzdWx0ID0gbWF0aC5jb25jYXQzRCh4MSwgeDIsIF90aGlzLmF4aXMpO1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKGNvbmNhdFJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbmNhdDNELnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uY2F0M0QgYmFja3Byb3Agbm90IGltcGxlbWVudGVkLicpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmNhdDNEO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5Db25jYXQzRCA9IENvbmNhdDNEO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0M2QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb252X3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9jb252X3V0aWxcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBDb252b2x1dGlvbjJEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udm9sdXRpb24yRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb252b2x1dGlvbjJEKHdUZW5zb3IsIHhUZW5zb3IsIGJUZW5zb3IsIHlUZW5zb3IsIGZpZWxkU2l6ZSwgb3V0cHV0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCkge1xuICAgICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHsgc3RyaWRlID0gMTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy53VGVuc29yID0gd1RlbnNvcjtcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLmJUZW5zb3IgPSBiVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgX3RoaXMuZmllbGRTaXplID0gZmllbGRTaXplO1xuICAgICAgICBfdGhpcy5vdXRwdXREZXB0aCA9IG91dHB1dERlcHRoO1xuICAgICAgICBfdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gICAgICAgIF90aGlzLmFzc2VydFdlaWdodHNTaGFwZSh3VGVuc29yLnNoYXBlKTtcbiAgICAgICAgX3RoaXMuemVyb1BhZCA9IHplcm9QYWQgIT0gbnVsbCA/XG4gICAgICAgICAgICB6ZXJvUGFkIDpcbiAgICAgICAgICAgIGNvbnZfdXRpbC5jb21wdXRlRGVmYXVsdFBhZChfdGhpcy54VGVuc29yLnNoYXBlLCBfdGhpcy5maWVsZFNpemUsIF90aGlzLnN0cmlkZSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQoX3RoaXMuemVyb1BhZCksIFwiVGhlIHplcm8gcGFkZGluZyAoXCIgKyBfdGhpcy56ZXJvUGFkICsgXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBcIiArXG4gICAgICAgICAgICBcInN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb252b2x1dGlvbjJELnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHdlaWdodHMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMud1RlbnNvcik7XG4gICAgICAgIHZhciBiaWFzZXMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuYlRlbnNvcik7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5jb252MmQoeCwgd2VpZ2h0cywgYmlhc2VzLCBfdGhpcy5zdHJpZGUsIF90aGlzLnplcm9QYWQpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udm9sdXRpb24yRC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgd2VpZ2h0cyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy53VGVuc29yKTtcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IG1hdGguY29udjJkQmFja1Byb3AoeCwgZHksIHdlaWdodHMsIF90aGlzLnN0cmlkZSwgX3RoaXMuemVyb1BhZCksIGR3ID0gX2EuZHcsIGRiID0gX2EuZGIsIGR4ID0gX2EuZHg7XG4gICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMud1RlbnNvciwgZHcpO1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLmJUZW5zb3IsIGRiKTtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54VGVuc29yLCBkeCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udm9sdXRpb24yRC5wcm90b3R5cGUuYXNzZXJ0V2VpZ2h0c1NoYXBlID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSkge1xuICAgICAgICB1dGlsLmFzc2VydCh3ZWlnaHRzU2hhcGVbMF0gPT09IHRoaXMuZmllbGRTaXplICYmXG4gICAgICAgICAgICB3ZWlnaHRzU2hhcGVbMV0gPT09IHRoaXMuZmllbGRTaXplICYmXG4gICAgICAgICAgICB3ZWlnaHRzU2hhcGVbMl0gPT09IHRoaXMueFRlbnNvci5zaGFwZVsyXSAmJlxuICAgICAgICAgICAgd2VpZ2h0c1NoYXBlWzNdID09PSB0aGlzLm91dHB1dERlcHRoLCBcIndlaWdodHMgbXVzdCBiZSBvZiBzaGFwZSBbXCIgKyB0aGlzLmZpZWxkU2l6ZSArIFwiLFwiICsgdGhpcy5maWVsZFNpemUgKyBcIixcIiArXG4gICAgICAgICAgICAodGhpcy54VGVuc29yLnNoYXBlWzJdICsgXCIsXCIgKyB0aGlzLm91dHB1dERlcHRoICsgXCJdIGJ1dCB0aGV5IGFyZSBvZlwiKSArXG4gICAgICAgICAgICAoXCJzaGFwZSBbXCIgKyB3ZWlnaHRzU2hhcGUgKyBcIl1cIikpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnZvbHV0aW9uMkQ7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkNvbnZvbHV0aW9uMkQgPSBDb252b2x1dGlvbjJEO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udm9sdXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBEaXZpZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaXZpZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGl2aWRlKHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHgxVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHgyVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh4MVRlbnNvci5zaGFwZSwgeDJUZW5zb3Iuc2hhcGUpLCAnT25lIG9mIHQxIG9yIHQyIG11c3QgYmUgYSBzY2FsYXIsIG9yIHQxIGFuZCB0MiBtdXN0IGhhdmUgJyArXG4gICAgICAgICAgICAndGhlIHNhbWUgc2hhcGUnKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEaXZpZGUucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgdDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0MS5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhckRpdmlkZWRCeUFycmF5KHQxLCB0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodDIuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5hcnJheURpdmlkZWRCeVNjYWxhcih0MSwgdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5kaXZpZGUodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEaXZpZGUucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIHZhciB4MUlzU2NhbGFyID0gdXRpbC5pc1NjYWxhclNoYXBlKHgxLnNoYXBlKTtcbiAgICAgICAgdmFyIHgySXNTY2FsYXIgPSB1dGlsLmlzU2NhbGFyU2hhcGUoeDIuc2hhcGUpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGlmICh4MUlzU2NhbGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXYgPSBtYXRoLmRpdmlkZShkeSwgeDIpO1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguc3VtKGRpdikpO1xuICAgICAgICAgICAgICAgICAgICBkaXYuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4MklzU2NhbGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5hcnJheURpdmlkZWRCeVNjYWxhcihkeSwgeDIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5kaXZpZGUoZHksIHgyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHgyU3F1YXJlZCA9IG1hdGguZWxlbWVudFdpc2VNdWwoeDIsIHgyKTtcbiAgICAgICAgICAgICAgICB2YXIgeDFPdmVyWDJTcXVhcmVkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmICh4MklzU2NhbGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHgxT3ZlclgyU3F1YXJlZCA9IG1hdGguYXJyYXlEaXZpZGVkQnlTY2FsYXIoeDEsIHgyU3F1YXJlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHgxSXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgeDFPdmVyWDJTcXVhcmVkID0gbWF0aC5zY2FsYXJEaXZpZGVkQnlBcnJheSh4MSwgeDJTcXVhcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHgxT3ZlclgyU3F1YXJlZCA9IG1hdGguZGl2aWRlKHgxLCB4MlNxdWFyZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZHgyID0gbWF0aC5uZWcoeDFPdmVyWDJTcXVhcmVkKTtcbiAgICAgICAgICAgICAgICB2YXIgZHlUaW1lc0Rlcml2YXRpdmUgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKGR5LCBkeDIpO1xuICAgICAgICAgICAgICAgIGlmICh4MklzU2NhbGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgbWF0aC5zdW0oZHlUaW1lc0Rlcml2YXRpdmUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgZHlUaW1lc0Rlcml2YXRpdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGl2aWRlO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5EaXZpZGUgPSBEaXZpZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXZpZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhY3RpdmF0aW9uX2Z1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvYWN0aXZhdGlvbl9mdW5jdGlvbnNcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIEVsZW1lbnRXaXNlQWN0aXZhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVsZW1lbnRXaXNlQWN0aXZhdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbGVtZW50V2lzZUFjdGl2YXRpb24oeFRlbnNvciwgeVRlbnNvciwgZnVuYykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIF90aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEVsZW1lbnRXaXNlQWN0aXZhdGlvbi5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAoX3RoaXMuZnVuYy5vdXRwdXQobWF0aCwgeCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbGVtZW50V2lzZUFjdGl2YXRpb24ucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIHZhciB5ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHlkeCA9IF90aGlzLmZ1bmMuZGVyKG1hdGgsIHgsIHkpO1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnhUZW5zb3IsIG1hdGguZWxlbWVudFdpc2VNdWwoZHksIGR5ZHgpKTtcbiAgICAgICAgICAgIGR5ZHguZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVsZW1lbnRXaXNlQWN0aXZhdGlvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mdW5jLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50V2lzZUFjdGl2YXRpb247XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkVsZW1lbnRXaXNlQWN0aXZhdGlvbiA9IEVsZW1lbnRXaXNlQWN0aXZhdGlvbjtcbnZhciBSZUxVID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVMVSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZUxVKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBhY3RpdmF0aW9uX2Z1bmN0aW9uc18xLlJlTFVGdW5jKCkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZUxVO1xufShFbGVtZW50V2lzZUFjdGl2YXRpb24pKTtcbmV4cG9ydHMuUmVMVSA9IFJlTFU7XG52YXIgTGVha3lSZUxVID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGVha3lSZUxVLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExlYWt5UmVMVSh4VGVuc29yLCB5VGVuc29yLCBhbHBoYSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeFRlbnNvciwgeVRlbnNvciwgbmV3IGFjdGl2YXRpb25fZnVuY3Rpb25zXzEuTGVha3lSZWx1RnVuYyhhbHBoYSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBMZWFreVJlTFU7XG59KEVsZW1lbnRXaXNlQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5MZWFreVJlTFUgPSBMZWFreVJlTFU7XG52YXIgVGFuSCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhbkgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFuSCh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4VGVuc29yLCB5VGVuc29yLCBuZXcgYWN0aXZhdGlvbl9mdW5jdGlvbnNfMS5UYW5IRnVuYygpKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFuSDtcbn0oRWxlbWVudFdpc2VBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlRhbkggPSBUYW5IO1xudmFyIFNpZ21vaWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaWdtb2lkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpZ21vaWQoeFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeFRlbnNvciwgeVRlbnNvciwgbmV3IGFjdGl2YXRpb25fZnVuY3Rpb25zXzEuU2lnbW9pZEZ1bmMoKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNpZ21vaWQ7XG59KEVsZW1lbnRXaXNlQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5TaWdtb2lkID0gU2lnbW9pZDtcbnZhciBTcXVhcmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTcXVhcmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3F1YXJlKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBhY3RpdmF0aW9uX2Z1bmN0aW9uc18xLlNxdWFyZUZ1bmMoKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNxdWFyZTtcbn0oRWxlbWVudFdpc2VBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlNxdWFyZSA9IFNxdWFyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29zdF9mdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL2Nvc3RfZnVuY3Rpb25zXCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgRWxlbWVudFdpc2VDb3N0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRWxlbWVudFdpc2VDb3N0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRXaXNlQ29zdCh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IsIGZ1bmMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIF90aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICBfdGhpcy5vbmVPdmVyTlNjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDEgLyB1dGlsLnNpemVGcm9tU2hhcGUoeDFUZW5zb3Iuc2hhcGUpKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFbGVtZW50V2lzZUNvc3QucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudFdpc2VDb3N0ID0gX3RoaXMuZnVuYy5jb3N0KG1hdGgsIHgxLCB4Mik7XG4gICAgICAgICAgICB2YXIgc3VtID0gbWF0aC5zdW0oZWxlbWVudFdpc2VDb3N0KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtYXRoLnNjYWxhclRpbWVzQXJyYXkoX3RoaXMub25lT3Zlck5TY2FsYXIsIHN1bSk7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWxlbWVudFdpc2VDb3N0LnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBfdGhpcy5mdW5jLmRlcihtYXRoLCB4MSwgeDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngyVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgX3RoaXMuZnVuYy5kZXIobWF0aCwgeDIsIHgxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWxlbWVudFdpc2VDb3N0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZ1bmMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLm9uZU92ZXJOU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50V2lzZUNvc3Q7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkVsZW1lbnRXaXNlQ29zdCA9IEVsZW1lbnRXaXNlQ29zdDtcbnZhciBNZWFuU3F1YXJlZENvc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZWFuU3F1YXJlZENvc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVhblNxdWFyZWRDb3N0KHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yLCBuZXcgY29zdF9mdW5jdGlvbnNfMS5TcXVhcmVDb3N0RnVuYygpKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWVhblNxdWFyZWRDb3N0O1xufShFbGVtZW50V2lzZUNvc3QpKTtcbmV4cG9ydHMuTWVhblNxdWFyZWRDb3N0ID0gTWVhblNxdWFyZWRDb3N0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudF93aXNlX2Nvc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIEV4cCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4cCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHAoeFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRXhwLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChtYXRoLmV4cCh4KSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEV4cC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueFRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueFRlbnNvciwgbWF0aC5lbGVtZW50V2lzZU11bCh5LCBkeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBFeHA7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkV4cCA9IEV4cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgTGluZWFyQ29tYmluYXRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaW5lYXJDb21iaW5hdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5lYXJDb21iaW5hdGlvbih4MVRlbnNvciwgeDJUZW5zb3IsIGMxVGVuc29yLCBjMlRlbnNvciwgb3V0VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLmMxVGVuc29yID0gYzFUZW5zb3I7XG4gICAgICAgIF90aGlzLmMyVGVuc29yID0gYzJUZW5zb3I7XG4gICAgICAgIF90aGlzLm91dFRlbnNvciA9IG91dFRlbnNvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMaW5lYXJDb21iaW5hdGlvbi5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIHZhciBjMSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5jMVRlbnNvcikuYXNTY2FsYXIoKTtcbiAgICAgICAgdmFyIGMyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmMyVGVuc29yKS5hc1NjYWxhcigpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLm91dFRlbnNvciwga2VlcChtYXRoLnNjYWxlZEFycmF5QWRkKGMxLCB4MSwgYzIsIHgyKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExpbmVhckNvbWJpbmF0aW9uLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIHZhciBjMSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5jMVRlbnNvcik7XG4gICAgICAgIHZhciBjMiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5jMlRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLm91dFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLnNjYWxhclRpbWVzQXJyYXkoYzEsIGR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIG1hdGguc2NhbGFyVGltZXNBcnJheShjMiwgZHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLmMxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kdWN0MSA9IG1hdGguZWxlbWVudFdpc2VNdWwoeDEsIGR5KTtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMuYzFUZW5zb3IsIG1hdGguc3VtKGRvdFByb2R1Y3QxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy5jMlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG90UHJvZHVjdDIgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHgyLCBkeSk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLmMyVGVuc29yLCBtYXRoLnN1bShkb3RQcm9kdWN0MikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBMaW5lYXJDb21iaW5hdGlvbjtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuTGluZWFyQ29tYmluYXRpb24gPSBMaW5lYXJDb21iaW5hdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmVhcl9jb21iaW5hdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgTG9nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExvZyh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhUZW5zb3IgPSB4VGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMb2cucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGgubG9nKHgpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9nLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54VGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54VGVuc29yLCBtYXRoLmRpdmlkZShkeSwgeCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBMb2c7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkxvZyA9IExvZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1hdGhfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL21hdGhcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBNYXRNdWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXRNdWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF0TXVsKHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYXRNdWwucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpZiAoeDEuc2hhcGUubGVuZ3RoID09PSAyICYmIHgyLnNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChtYXRoLm1hdE11bCh4MSwgeDIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4MS5zaGFwZS5sZW5ndGggPT09IDIgJiYgeDIuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGgubWF0cml4VGltZXNWZWN0b3IoeDEsIHgyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeDEuc2hhcGUubGVuZ3RoID09PSAxICYmIHgyLnNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChtYXRoLnZlY3RvclRpbWVzTWF0cml4KHgxLCB4MikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRNdWwucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIGlmICh4MS5zaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHgxID0geDEucmVzaGFwZShbMSwgeDEuc2l6ZV0pO1xuICAgICAgICAgICAgZHkgPSBkeS5yZXNoYXBlKFsxLCBkeS5zaXplXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHgyLnNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgeDIgPSB4Mi5yZXNoYXBlKFt4Mi5zaXplLCAxXSk7XG4gICAgICAgICAgICBkeSA9IGR5LnJlc2hhcGUoW2R5LnNpemUsIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIHZhciBkeDEgPSBtYXRoLm1hdE11bChkeSwgeDIsIG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSLCBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uVFJBTlNQT1NFRCk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBfdGhpcy54MVRlbnNvci5zaGFwZS5sZW5ndGggPT09IDEgPyBkeDEuYXMxRCgpIDogZHgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngyVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIHZhciBkeDIgPSBtYXRoLm1hdE11bCh4MSwgZHksIG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5UUkFOU1BPU0VELCBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUik7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBfdGhpcy54MlRlbnNvci5zaGFwZS5sZW5ndGggPT09IDEgPyBkeDIuYXMxRCgpIDogZHgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWF0TXVsO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5NYXRNdWwgPSBNYXRNdWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRtdWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb252X3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9jb252X3V0aWxcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBNYXhQb29sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF4UG9vbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXhQb29sKHhUZW5zb3IsIHlUZW5zb3IsIGZpZWxkU2l6ZSwgc3RyaWRlLCBwYWQpIHtcbiAgICAgICAgaWYgKHN0cmlkZSA9PT0gdm9pZCAwKSB7IHN0cmlkZSA9IDE7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICBfdGhpcy5maWVsZFNpemUgPSBmaWVsZFNpemU7XG4gICAgICAgIF90aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgICAgICAgaWYgKHBhZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpcy5wYWQgPSBwYWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5wYWQgPSBjb252X3V0aWwuY29tcHV0ZURlZmF1bHRQYWQoeFRlbnNvci5zaGFwZSwgX3RoaXMuZmllbGRTaXplLCBfdGhpcy5zdHJpZGUpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQoX3RoaXMucGFkKSwgXCJUaGUgemVybyBwYWRkaW5nIChcIiArIF90aGlzLnBhZCArIFwiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgXCIgK1xuICAgICAgICAgICAgXCJzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWF4UG9vbC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5tYXhQb29sKHgsIF90aGlzLmZpZWxkU2l6ZSwgX3RoaXMuc3RyaWRlLCBfdGhpcy5wYWQpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF4UG9vbC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnhUZW5zb3IsIG1hdGgubWF4UG9vbEJhY2twcm9wKGR5LCB4LCBfdGhpcy5maWVsZFNpemUsIF90aGlzLnN0cmlkZSwgX3RoaXMucGFkKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1heFBvb2w7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLk1heFBvb2wgPSBNYXhQb29sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF4X3Bvb2wuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBNdWx0aXBseSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE11bHRpcGx5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE11bHRpcGx5KHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHgxVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHgyVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh4MVRlbnNvci5zaGFwZSwgeDJUZW5zb3Iuc2hhcGUpLCAnT25lIG9mIHQxIG9yIHQyIG11c3QgYmUgYSBzY2FsYXIsIG9yIHQxIGFuZCB0MiBtdXN0IGhhdmUgJyArXG4gICAgICAgICAgICAndGhlIHNhbWUgc2hhcGUnKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNdWx0aXBseS5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB0MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQxLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguc2NhbGFyVGltZXNBcnJheSh0MSwgdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQyLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguc2NhbGFyVGltZXNBcnJheSh0MiwgdDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5lbGVtZW50V2lzZU11bCh0MSwgdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKHJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE11bHRpcGx5LnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoX3RoaXMueDFUZW5zb3Iuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtdWwgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKGR5LCB4Mik7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5zdW0obXVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh4Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLnNjYWxhclRpbWVzQXJyYXkoeDIsIGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguZWxlbWVudFdpc2VNdWwoeDIsIGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZShfdGhpcy54MlRlbnNvci5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG11bCA9IG1hdGguZWxlbWVudFdpc2VNdWwoZHksIHgxKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLnN1bShtdWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHgxLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIG1hdGguc2NhbGFyVGltZXNBcnJheSh4MSwgZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgbWF0aC5lbGVtZW50V2lzZU11bCh4MSwgZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpcGx5O1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5NdWx0aXBseSA9IE11bHRpcGx5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlwbHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgT3BlcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcGVyYXRpb24oKSB7XG4gICAgfVxuICAgIE9wZXJhdGlvbi5wcm90b3R5cGUuZGlzcG9zZVRyYW5zaWVudEFycmF5cyA9IGZ1bmN0aW9uIChpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7IH07XG4gICAgT3BlcmF0aW9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBPcGVyYXRpb247XG59KCkpO1xuZXhwb3J0cy5PcGVyYXRpb24gPSBPcGVyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgUmVkdWNlU3VtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVkdWNlU3VtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZHVjZVN1bSh4LCBvdXRUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueCA9IHg7XG4gICAgICAgIF90aGlzLm91dFRlbnNvciA9IG91dFRlbnNvcjtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChvdXRUZW5zb3Iuc2hhcGUsIFtdKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZWR1Y2VTdW0ucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54KTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy5vdXRUZW5zb3IsIGtlZXAobWF0aC5zdW0oeCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWR1Y2VTdW0ucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMueCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldChfdGhpcy5vdXRUZW5zb3IpO1xuICAgICAgICAgICAgaWYgKF90aGlzLm9uZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciB4QXJyYXkgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KF90aGlzLngpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uZXMgPSBuZGFycmF5XzEuTkRBcnJheS56ZXJvc0xpa2UoeEFycmF5KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmVzLmZpbGwoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueCwgbWF0aC5zY2FsYXJUaW1lc0FycmF5KGR5LCBfdGhpcy5vbmVzKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZHVjZVN1bTtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuUmVkdWNlU3VtID0gUmVkdWNlU3VtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdWNlX3N1bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgUmVzaGFwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlc2hhcGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVzaGFwZSh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhUZW5zb3IgPSB4VGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgdmFyIHhTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHhUZW5zb3Iuc2hhcGUpO1xuICAgICAgICB2YXIgeVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoeVRlbnNvci5zaGFwZSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHhTaXplID09PSB5U2l6ZSwgXCJUaGUgaW5wdXQgc2l6ZSAoXCIgKyB4U2l6ZSArIFwiKSBhbmQgb3V0cHV0IHNpemUgKFwiICsgeVNpemUgKyBcIikgbXVzdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZXNoYXBlLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIHZhciBjbG9uZSA9IG1hdGguY2xvbmUoeCk7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChjbG9uZS5yZXNoYXBlKF90aGlzLnlUZW5zb3Iuc2hhcGUpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzaGFwZS5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgdmFyIGNsb25lID0gbWF0aC5jbG9uZShkeSk7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnhUZW5zb3IsIGNsb25lLnJlc2hhcGUoX3RoaXMueFRlbnNvci5zaGFwZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNoYXBlO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5SZXNoYXBlID0gUmVzaGFwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc2hhcGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBncmFwaF8xID0gcmVxdWlyZShcIi4uL2dyYXBoXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBTb2Z0bWF4ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU29mdG1heCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTb2Z0bWF4KGxvZ2l0c1RlbnNvciwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxvZ2l0c1RlbnNvciA9IGxvZ2l0c1RlbnNvcjtcbiAgICAgICAgX3RoaXMub3V0cHV0ID0gb3V0cHV0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNvZnRtYXgucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbG9naXRzID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmxvZ2l0c1RlbnNvcik7XG4gICAgICAgIHJldHVybiBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLm91dHB1dCwga2VlcChtYXRoLnNvZnRtYXgobG9naXRzKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNvZnRtYXgucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcignU29mdG1heCBiYWNrcHJvcCBpcyBub3QgeWV0IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gU29mdG1heDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuU29mdG1heCA9IFNvZnRtYXg7XG52YXIgU29mdG1heENyb3NzRW50cm9weUNvc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdChsb2dpdHNUZW5zb3IsIGxhYmVsVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxvZ2l0c1RlbnNvciA9IGxvZ2l0c1RlbnNvcjtcbiAgICAgICAgX3RoaXMubGFiZWxUZW5zb3IgPSBsYWJlbFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIF90aGlzLmVwc2lsb24gPSBuZGFycmF5XzEuU2NhbGFyLm5ldygxZS01KTtcbiAgICAgICAgX3RoaXMuc29mdG1heFRlbnNvciA9IG5ldyBncmFwaF8xLlRlbnNvcihsb2dpdHNUZW5zb3Iuc2hhcGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0LnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxvZ2l0cyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5sb2dpdHNUZW5zb3IpO1xuICAgICAgICB2YXIgbGFiZWwgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMubGFiZWxUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICB2YXIgc29mdG1heFJlc3VsdCA9IG1hdGguc29mdG1heChsb2dpdHMpO1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy5zb2Z0bWF4VGVuc29yLCBrZWVwKHNvZnRtYXhSZXN1bHQpKTtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChjcm9zc0VudHJvcHlDb3N0KG1hdGgsIHNvZnRtYXhSZXN1bHQsIGxhYmVsLCBfdGhpcy5lcHNpbG9uKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0LnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzb2Z0bWF4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnNvZnRtYXhUZW5zb3IpO1xuICAgICAgICB2YXIgbGFiZWwgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMubGFiZWxUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy5sb2dpdHNUZW5zb3IsIG1hdGguc3VidHJhY3Qoc29mdG1heCwgbGFiZWwpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdC5wcm90b3R5cGUuZGlzcG9zZVRyYW5zaWVudEFycmF5cyA9IGZ1bmN0aW9uIChpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIGluZmVyZW5jZUFycmF5cy5kaXNwb3NlQXJyYXkodGhpcy5zb2Z0bWF4VGVuc29yKTtcbiAgICB9O1xuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVwc2lsb24uZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0O1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5Tb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCA9IFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0O1xuZnVuY3Rpb24gY3Jvc3NFbnRyb3B5Q29zdChtYXRoLCB5LCB0YXJnZXQsIGVwc2lsb24pIHtcbiAgICB1dGlsLmFzc2VydCh5LnNpemUgPT09IHRhcmdldC5zaXplLCAnVGhlIG91dHB1dCBhbmQgdGFyZ2V0IG11c3QgYmUgdGhlIHNhbWUgc2l6ZScpO1xuICAgIHJldHVybiBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHlQbHVzRXBzID0gbWF0aC5zY2FsYXJQbHVzQXJyYXkoZXBzaWxvbiwgeSk7XG4gICAgICAgIHZhciBsb2dPdXRwdXQgPSBtYXRoLmxvZyh5UGx1c0Vwcyk7XG4gICAgICAgIHZhciB0YXJMb2dPdXRwdXQgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHRhcmdldCwgbG9nT3V0cHV0KTtcbiAgICAgICAgdmFyIGNvc3RWZWN0b3IgPSBtYXRoLm5lZyh0YXJMb2dPdXRwdXQpO1xuICAgICAgICByZXR1cm4gbWF0aC5zdW0oY29zdFZlY3Rvcik7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyb3NzRW50cm9weUNvc3QgPSBjcm9zc0VudHJvcHlDb3N0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29mdG1heC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgU3VidHJhY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJ0cmFjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJ0cmFjdCh0MSwgdDIsIG91dFRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50MSA9IHQxO1xuICAgICAgICBfdGhpcy50MiA9IHQyO1xuICAgICAgICBfdGhpcy5vdXRUZW5zb3IgPSBvdXRUZW5zb3I7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodDEuc2hhcGUsIHQyLnNoYXBlKSwgJ09uZSBvZiB0MSBvciB0MiBtdXN0IGJlIGEgc2NhbGFyLCBvciB0MSBhbmQgdDIgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgJ3RoZSBzYW1lIHNoYXBlJyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3VidHJhY3QucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMudDEpO1xuICAgICAgICB2YXIgdDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMudDIpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0MS5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhck1pbnVzQXJyYXkodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmFycmF5TWludXNTY2FsYXIodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguc3VidHJhY3QodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMub3V0VGVuc29yLCBrZWVwKHJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN1YnRyYWN0LnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLm91dFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMudDEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZShfdGhpcy50MS5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IG1hdGguc3VtKGR5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmR5U2l6ZVNjYWxhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5keVNpemVTY2FsYXIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhkeS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMudDEsIG1hdGguZGl2aWRlKHN1bSwgX3RoaXMuZHlTaXplU2NhbGFyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMudDEsIG1hdGguY2xvbmUoZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy50MikpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKF90aGlzLnQyLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gbWF0aC5zdW0oZHkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmVnU3VtID0gbWF0aC5uZWcoc3VtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmR5U2l6ZVNjYWxhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5keVNpemVTY2FsYXIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhkeS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMudDIsIG1hdGguZGl2aWRlKG5lZ1N1bSwgX3RoaXMuZHlTaXplU2NhbGFyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMudDIsIG1hdGgubmVnKGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN1YnRyYWN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5keVNpemVTY2FsYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5keVNpemVTY2FsYXIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3VidHJhY3Q7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLlN1YnRyYWN0ID0gU3VidHJhY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJ0cmFjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgQWRhZGVsdGFPcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBZGFkZWx0YU9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGFkZWx0YU9wdGltaXplcihsZWFybmluZ1JhdGUsIGdhbW1hLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMuZ2FtbWEgPSBnYW1tYTtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLmVwcyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDFlLTYpO1xuICAgICAgICBfdGhpcy5nID0gbmRhcnJheV8xLlNjYWxhci5uZXcoX3RoaXMuZ2FtbWEpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkYWRlbHRhT3B0aW1pemVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoLmNhbGwodGhpcywgbWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRVcGRhdGVzLnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFkZWx0YU9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFyaWFibGUgPSBhY3RpdmF0aW9uQXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRDYWNoZSA9IF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRVcGRhdGVzID0gX3RoaXMuYWNjdW11bGF0ZWRVcGRhdGVzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50U3F1YXJlID0gbWF0aC5tdWx0aXBseShncmFkaWVudCwgZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuZywgb2xkQ2FjaGUsIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCBfdGhpcy5nKSwgZ3JhZGllbnRTcXVhcmUpO1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVzID0gbWF0aC5tdWx0aXBseShtYXRoLmRpdmlkZShtYXRoLnNxcnQobWF0aC5hZGQob2xkVXBkYXRlcywgX3RoaXMuZXBzKSksIG1hdGguc3FydChtYXRoLmFkZChvbGRDYWNoZSwgX3RoaXMuZXBzKSkpLCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5jLCB1cGRhdGVzLCBfdGhpcy5vbmUsIG9sZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlU3F1YXJlID0gbWF0aC5tdWx0aXBseSh1cGRhdGVzLCB1cGRhdGVzKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VXBkYXRlcyA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuZywgb2xkVXBkYXRlcywgbWF0aC5zdWJ0cmFjdChfdGhpcy5vbmUsIF90aGlzLmcpLCB1cGRhdGVTcXVhcmUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIGtlZXAoY2FjaGUpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMuc2V0KG5vZGUub3V0cHV0LCBrZWVwKG5ld1VwZGF0ZXMpKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZENhY2hlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRVcGRhdGVzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBBZGFkZWx0YU9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXBzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5nLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY3VtdWxhdGVkVXBkYXRlcy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQWRhZGVsdGFPcHRpbWl6ZXI7XG59KG9wdGltaXplcl8xLk9wdGltaXplcikpO1xuZXhwb3J0cy5BZGFkZWx0YU9wdGltaXplciA9IEFkYWRlbHRhT3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhZGVsdGFfb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBBZGFncmFkT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRhZ3JhZE9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGFncmFkT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMuZXBzID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMWUtNik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWRhZ3JhZE9wdGltaXplci5wcm90b3R5cGUuYmVmb3JlQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaC5jYWxsKHRoaXMsIG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKTtcbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFkYWdyYWRPcHRpbWl6ZXIucHJvdG90eXBlLmFmdGVyQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkQ2FjaGUgPSBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnRTcXVhcmUgPSBtYXRoLm11bHRpcGx5KGdyYWRpZW50LCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gbWF0aC5hZGQob2xkQ2FjaGUsIGdyYWRpZW50U3F1YXJlKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmMsIG1hdGguZGl2aWRlKGdyYWRpZW50LCBtYXRoLmFkZChtYXRoLnNxcnQoY2FjaGUpLCBfdGhpcy5lcHMpKSwgX3RoaXMub25lLCBvbGRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwga2VlcChjYWNoZSkpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25BcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIGtlZXAodmFyaWFibGUpKTtcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSB2YXJpYWJsZTtcbiAgICAgICAgICAgICAgICBvbGRWYXJpYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkQ2FjaGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICB9O1xuICAgIEFkYWdyYWRPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmVwcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBBZGFncmFkT3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuQWRhZ3JhZE9wdGltaXplciA9IEFkYWdyYWRPcHRpbWl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGFncmFkX29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgQWRhbU9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkYW1PcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWRhbU9wdGltaXplcihsZWFybmluZ1JhdGUsIGJldGExLCBiZXRhMiwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLmJldGExID0gYmV0YTE7XG4gICAgICAgIF90aGlzLmJldGEyID0gYmV0YTI7XG4gICAgICAgIF90aGlzLmZpcnN0TW9tZW50ID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5zZWNvbmRNb21lbnQgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLmVwcyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDFlLTgpO1xuICAgICAgICBfdGhpcy5iMSA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmJldGExKTtcbiAgICAgICAgX3RoaXMuYjIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5iZXRhMik7XG4gICAgICAgIF90aGlzLmFjY0IxID0gbmRhcnJheV8xLlNjYWxhci5uZXcoX3RoaXMuYmV0YTEpO1xuICAgICAgICBfdGhpcy5hY2NCMiA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmJldGEyKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGFtT3B0aW1pemVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoLmNhbGwodGhpcywgbWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICBpZiAodGhpcy5maXJzdE1vbWVudC5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZmlyc3RNb21lbnQuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kTW9tZW50LnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWNvbmRNb21lbnQuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFkYW1PcHRpbWl6ZXIucHJvdG90eXBlLmFmdGVyQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkRmlyc3RNb21lbnQgPSBfdGhpcy5maXJzdE1vbWVudC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRTZWNvbmRNb21lbnQgPSBfdGhpcy5zZWNvbmRNb21lbnQuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Rmlyc3RNb21lbnQgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmIxLCBvbGRGaXJzdE1vbWVudCwgbWF0aC5zdWJ0cmFjdChfdGhpcy5vbmUsIF90aGlzLmIxKSwgZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudFNxdWFyZSA9IG1hdGgubXVsdGlwbHkoZ3JhZGllbnQsIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2Vjb25kTW9tZW50ID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5iMiwgb2xkU2Vjb25kTW9tZW50LCBtYXRoLnN1YnRyYWN0KF90aGlzLm9uZSwgX3RoaXMuYjIpLCBncmFkaWVudFNxdWFyZSk7XG4gICAgICAgICAgICAgICAgdmFyIGJpYXNDb3JyZWN0ZWRGaXJzdE1vbWVudCA9IG1hdGguZGl2aWRlKG5ld0ZpcnN0TW9tZW50LCBtYXRoLnN1YnRyYWN0KF90aGlzLm9uZSwgX3RoaXMuYWNjQjEpKTtcbiAgICAgICAgICAgICAgICB2YXIgYmlhc0NvcnJlY3RlZFNlY29uZE1vbWVudCA9IG1hdGguZGl2aWRlKG5ld1NlY29uZE1vbWVudCwgbWF0aC5zdWJ0cmFjdChfdGhpcy5vbmUsIF90aGlzLmFjY0IyKSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5jLCBtYXRoLmRpdmlkZShiaWFzQ29ycmVjdGVkRmlyc3RNb21lbnQsIG1hdGguYWRkKG1hdGguc3FydChiaWFzQ29ycmVjdGVkU2Vjb25kTW9tZW50KSwgX3RoaXMuZXBzKSksIF90aGlzLm9uZSwgb2xkVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25BcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIGtlZXAodmFyaWFibGUpKTtcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSB2YXJpYWJsZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5maXJzdE1vbWVudC5zZXQobm9kZS5vdXRwdXQsIGtlZXAobmV3Rmlyc3RNb21lbnQpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWNvbmRNb21lbnQuc2V0KG5vZGUub3V0cHV0LCBrZWVwKG5ld1NlY29uZE1vbWVudCkpO1xuICAgICAgICAgICAgICAgIG9sZFZhcmlhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkRmlyc3RNb21lbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZFNlY29uZE1vbWVudC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBvbGRBY2NCMSA9IF90aGlzLmFjY0IxO1xuICAgICAgICAgICAgdmFyIG9sZEFjY0IyID0gX3RoaXMuYWNjQjI7XG4gICAgICAgICAgICBfdGhpcy5hY2NCMSA9IGtlZXAobWF0aC5tdWx0aXBseShfdGhpcy5hY2NCMSwgX3RoaXMuYjEpKTtcbiAgICAgICAgICAgIF90aGlzLmFjY0IyID0ga2VlcChtYXRoLm11bHRpcGx5KF90aGlzLmFjY0IyLCBfdGhpcy5iMikpO1xuICAgICAgICAgICAgb2xkQWNjQjEuZGlzcG9zZSgpO1xuICAgICAgICAgICAgb2xkQWNjQjIuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBBZGFtT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5maXJzdE1vbWVudC5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuc2Vjb25kTW9tZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5lcHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmIxLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5iMi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYWNjQjEuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY0IyLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBBZGFtT3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuQWRhbU9wdGltaXplciA9IEFkYW1PcHRpbWl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGFtX29wdGltaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgQWRhbWF4T3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRhbWF4T3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkYW1heE9wdGltaXplcihsZWFybmluZ1JhdGUsIGJldGExLCBiZXRhMiwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLmJldGExID0gYmV0YTE7XG4gICAgICAgIF90aGlzLmJldGEyID0gYmV0YTI7XG4gICAgICAgIF90aGlzLmZpcnN0TW9tZW50ID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy53ZWlnaHRlZEluZk5vcm0gPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLmVwcyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDFlLTgpO1xuICAgICAgICBfdGhpcy5iMSA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmJldGExKTtcbiAgICAgICAgX3RoaXMuYjIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5iZXRhMik7XG4gICAgICAgIF90aGlzLmFjY0IxID0gbmRhcnJheV8xLlNjYWxhci5uZXcoX3RoaXMuYmV0YTEpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkYW1heE9wdGltaXplci5wcm90b3R5cGUuYmVmb3JlQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaC5jYWxsKHRoaXMsIG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKTtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RNb21lbnQuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmZpcnN0TW9tZW50LnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndlaWdodGVkSW5mTm9ybS5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2VpZ2h0ZWRJbmZOb3JtLnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFtYXhPcHRpbWl6ZXIucHJvdG90eXBlLmFmdGVyQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkRmlyc3RNb21lbnQgPSBfdGhpcy5maXJzdE1vbWVudC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRXZWlnaHRlZEluZk5vcm0gPSBfdGhpcy53ZWlnaHRlZEluZk5vcm0uZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Rmlyc3RNb21lbnQgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmIxLCBvbGRGaXJzdE1vbWVudCwgbWF0aC5zdWJ0cmFjdChfdGhpcy5vbmUsIF90aGlzLmIxKSwgZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciB1dDAgPSBtYXRoLm11bHRpcGx5KF90aGlzLmIyLCBvbGRXZWlnaHRlZEluZk5vcm0pO1xuICAgICAgICAgICAgICAgIHZhciB1dDEgPSBtYXRoLmFicyhncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1dlaWdodGVkSW5mTm9ybSA9IG1hdGguYWRkKG1hdGgucmVsdShtYXRoLnN1YnRyYWN0KHV0MCwgdXQxKSksIHV0MSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5vbmUsIG9sZFZhcmlhYmxlLCBtYXRoLmRpdmlkZShfdGhpcy5jLCBtYXRoLnN1YnRyYWN0KF90aGlzLm9uZSwgX3RoaXMuYWNjQjEpKSwgbWF0aC5kaXZpZGUobmV3Rmlyc3RNb21lbnQsIG1hdGguYWRkKF90aGlzLmVwcywgbmV3V2VpZ2h0ZWRJbmZOb3JtKSkpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25BcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIGtlZXAodmFyaWFibGUpKTtcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSB2YXJpYWJsZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5maXJzdE1vbWVudC5zZXQobm9kZS5vdXRwdXQsIGtlZXAobmV3Rmlyc3RNb21lbnQpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy53ZWlnaHRlZEluZk5vcm0uc2V0KG5vZGUub3V0cHV0LCBrZWVwKG5ld1dlaWdodGVkSW5mTm9ybSkpO1xuICAgICAgICAgICAgICAgIG9sZFZhcmlhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkRmlyc3RNb21lbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZFdlaWdodGVkSW5mTm9ybS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBvbGRBY2NCMSA9IF90aGlzLmFjY0IxO1xuICAgICAgICAgICAgX3RoaXMuYWNjQjEgPSBrZWVwKG1hdGgubXVsdGlwbHkoX3RoaXMuYWNjQjEsIF90aGlzLmIxKSk7XG4gICAgICAgICAgICBvbGRBY2NCMS5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICB9O1xuICAgIEFkYW1heE9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZmlyc3RNb21lbnQuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLndlaWdodGVkSW5mTm9ybS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZXBzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hY2NCMS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYjEuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmIyLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBBZGFtYXhPcHRpbWl6ZXI7XG59KG9wdGltaXplcl8xLk9wdGltaXplcikpO1xuZXhwb3J0cy5BZGFtYXhPcHRpbWl6ZXIgPSBBZGFtYXhPcHRpbWl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGFtYXhfb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBzZ2Rfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9zZ2Rfb3B0aW1pemVyXCIpO1xudmFyIE1vbWVudHVtT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW9tZW50dW1PcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9tZW50dW1PcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBtb21lbnR1bSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLm1vbWVudHVtID0gbW9tZW50dW07XG4gICAgICAgIF90aGlzLnZhcmlhYmxlVmVsb2NpdGllcyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMubSA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLm1vbWVudHVtKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNb21lbnR1bU9wdGltaXplci5wcm90b3R5cGUuYmVmb3JlQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaC5jYWxsKHRoaXMsIG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKTtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGVWZWxvY2l0aWVzLnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy52YXJpYWJsZVZlbG9jaXRpZXMuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vbWVudHVtT3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYXJpYWJsZSA9IGFjdGl2YXRpb25BcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZlbG9jaXR5ID0gX3RoaXMudmFyaWFibGVWZWxvY2l0aWVzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIHZlbG9jaXR5ID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5tLCBvbGRWZWxvY2l0eSwgX3RoaXMub25lLCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5jLCB2ZWxvY2l0eSwgX3RoaXMub25lLCBvbGRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMudmFyaWFibGVWZWxvY2l0aWVzLnNldChub2RlLm91dHB1dCwga2VlcCh2ZWxvY2l0eSkpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25BcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIGtlZXAodmFyaWFibGUpKTtcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSB2YXJpYWJsZTtcbiAgICAgICAgICAgICAgICBvbGRWYXJpYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkVmVsb2NpdHkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICB9O1xuICAgIE1vbWVudHVtT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5tLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZVZlbG9jaXRpZXMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgTW9tZW50dW1PcHRpbWl6ZXIucHJvdG90eXBlLnNldE1vbWVudHVtID0gZnVuY3Rpb24gKG1vbWVudHVtKSB7XG4gICAgICAgIHRoaXMubW9tZW50dW0gPSBtb21lbnR1bTtcbiAgICB9O1xuICAgIHJldHVybiBNb21lbnR1bU9wdGltaXplcjtcbn0oc2dkX29wdGltaXplcl8xLlNHRE9wdGltaXplcikpO1xuZXhwb3J0cy5Nb21lbnR1bU9wdGltaXplciA9IE1vbWVudHVtT3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9tZW50dW1fb3B0aW1pemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgc2Vzc2lvbl91dGlsID0gcmVxdWlyZShcIi4uL3Nlc3Npb25fdXRpbFwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBPcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wdGltaXplcihsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB0aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgdGhpcy5vbmUgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygxKTtcbiAgICAgICAgaWYgKHNwZWNpZmllZFZhcmlhYmxlTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllZFZhcmlhYmxlTm9kZXMgPSBzcGVjaWZpZWRWYXJpYWJsZUxpc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT3B0aW1pemVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMgPSB0aGlzLnNwZWNpZmllZFZhcmlhYmxlTm9kZXMgPT0gbnVsbCA/XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwuZ2V0VmFyaWFibGVOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0KHJ1bnRpbWUubm9kZXMpIDpcbiAgICAgICAgICAgIHRoaXMuc3BlY2lmaWVkVmFyaWFibGVOb2RlcztcbiAgICAgICAgaWYgKGJhdGNoU2l6ZSAhPT0gdGhpcy5wcmV2QmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmV2QmF0Y2hTaXplID0gYmF0Y2hTaXplO1xuICAgICAgICAgICAgdGhpcy5jID0gbmRhcnJheV8xLlNjYWxhci5uZXcoLXRoaXMubGVhcm5pbmdSYXRlIC8gYmF0Y2hTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpOyB9KTtcbiAgICB9O1xuICAgIE9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJFeGFtcGxlID0gZnVuY3Rpb24gKG1hdGgsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBncmFkaWVudEFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGFjY3VtdWxhdGVkR3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwga2VlcChtYXRoLmFkZChncmFkaWVudCwgYWNjdW11bGF0ZWRHcmFkaWVudCkpKTtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZEdyYWRpZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25lLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBPcHRpbWl6ZXI7XG59KCkpO1xuZXhwb3J0cy5PcHRpbWl6ZXIgPSBPcHRpbWl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpbWl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHRlbnNvcl9hcnJheV9tYXBfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JfYXJyYXlfbWFwXCIpO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVyXCIpO1xudmFyIFJNU1Byb3BPcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSTVNQcm9wT3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJNU1Byb3BPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBnYW1tYSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLmdhbW1hID0gZ2FtbWE7XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMuZXBzID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMWUtNik7XG4gICAgICAgIF90aGlzLmcgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5nYW1tYSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUk1TUHJvcE9wdGltaXplci5wcm90b3R5cGUuYmVmb3JlQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaC5jYWxsKHRoaXMsIG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKTtcbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJNU1Byb3BPcHRpbWl6ZXIucHJvdG90eXBlLmFmdGVyQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkQ2FjaGUgPSBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnRTcXVhcmUgPSBtYXRoLm11bHRpcGx5KGdyYWRpZW50LCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5nLCBvbGRDYWNoZSwgbWF0aC5zdWJ0cmFjdChfdGhpcy5vbmUsIF90aGlzLmcpLCBncmFkaWVudFNxdWFyZSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5jLCBtYXRoLmRpdmlkZShncmFkaWVudCwgbWF0aC5hZGQobWF0aC5zcXJ0KGNhY2hlKSwgX3RoaXMuZXBzKSksIF90aGlzLm9uZSwgb2xkVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIGtlZXAoY2FjaGUpKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZENhY2hlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBSTVNQcm9wT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lcHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmcuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gUk1TUHJvcE9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLlJNU1Byb3BPcHRpbWl6ZXIgPSBSTVNQcm9wT3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm1zcHJvcF9vcHRpbWl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBTR0RPcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTR0RPcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU0dET3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU0dET3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYXJpYWJsZSA9IGFjdGl2YXRpb25BcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5jLCBncmFkaWVudCwgX3RoaXMub25lLCBvbGRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvbkFycmF5TWFwLnNldChub2RlLm91dHB1dCwga2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIG9sZFZhcmlhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBTR0RPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgU0dET3B0aW1pemVyLnByb3RvdHlwZS5zZXRMZWFybmluZ1JhdGUgPSBmdW5jdGlvbiAobGVhcm5pbmdSYXRlKSB7XG4gICAgICAgIHRoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgIH07XG4gICAgcmV0dXJuIFNHRE9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLlNHRE9wdGltaXplciA9IFNHRE9wdGltaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNnZF9vcHRpbWl6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdENvbXBhcmUgPSBkZWZhdWx0Q29tcGFyZTtcbnZhciBQcmlvcml0eVF1ZXVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcmlvcml0eVF1ZXVlKGNvbXBhcmF0b3IsIGluZGV4T2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICAgICAgdGhpcy5pbmRleE9ic2VydmVyID0gaW5kZXhPYnNlcnZlcjtcbiAgICAgICAgdGhpcy5oZWFwID0gW107XG4gICAgfVxuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLmhlYXAucHVzaCh0KTtcbiAgICAgICAgdGhpcy5vbkluZGV4Q2hhbmdlZCh0LCB0aGlzLmhlYXAubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMuc2lmdFVwKHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGVxdWV1ZSBjYWxsZWQgb24gZW1wdHkgcHJpb3JpdHkgcXVldWUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQgPSB0aGlzLmhlYXBbMF07XG4gICAgICAgIHRoaXMuc3dhcCgwLCB0aGlzLmhlYXAubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMuaGVhcC5wb3AoKTtcbiAgICAgICAgdGhpcy5zaWZ0RG93bigwKTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobmV3VCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGxhc3QgPSAoaW5kZXggPT09IHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgICB0aGlzLnN3YXAoaW5kZXgsIHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYXAucG9wKCk7XG4gICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2lmdFVwSW5kZXgoaW5kZXgpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lmdFVwKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2lmdERvd25JbmRleChpbmRleCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWZ0RG93bihpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbnF1ZXVlKG5ld1QpO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYXAubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUub25JbmRleENoYW5nZWQgPSBmdW5jdGlvbiAodCwgbmV3SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5pbmRleE9ic2VydmVyKHQsIG5ld0luZGV4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZ2V0UGFyZW50SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGluZGV4IC0gMSkgLyAyKTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmdldExlZnRDaGlsZEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSBpbmRleCAqIDIgKyAxO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlIDwgdGhpcy5oZWFwLmxlbmd0aCA/IGNhbmRpZGF0ZSA6IC0xO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZ2V0UmlnaHRDaGlsZEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSBpbmRleCAqIDIgKyAyO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlIDwgdGhpcy5oZWFwLmxlbmd0aCA/IGNhbmRpZGF0ZSA6IC0xO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2lmdFVwSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIHBhcmVudEluZGV4ID0gdGhpcy5nZXRQYXJlbnRJbmRleChpbmRleCk7XG4gICAgICAgIGlmIChwYXJlbnRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb21wYXJlKHBhcmVudEluZGV4LCBpbmRleCkgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2lmdFVwID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBzaWZ0SW5kZXggPSB0aGlzLnNpZnRVcEluZGV4KGluZGV4KTtcbiAgICAgICAgd2hpbGUgKHNpZnRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhcChpbmRleCwgc2lmdEluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ID0gc2lmdEluZGV4O1xuICAgICAgICAgICAgc2lmdEluZGV4ID0gdGhpcy5zaWZ0VXBJbmRleChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpZnREb3duSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuaGVhcC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFyZ2VzdENoaWxkSW5kZXggPSBpbmRleDtcbiAgICAgICAgdmFyIGxlZnRDaGlsZEluZGV4ID0gdGhpcy5nZXRMZWZ0Q2hpbGRJbmRleChpbmRleCk7XG4gICAgICAgIGlmICgobGVmdENoaWxkSW5kZXggIT09IC0xKSAmJlxuICAgICAgICAgICAgKHRoaXMuY29tcGFyZShsZWZ0Q2hpbGRJbmRleCwgbGFyZ2VzdENoaWxkSW5kZXgpIDwgMCkpIHtcbiAgICAgICAgICAgIGxhcmdlc3RDaGlsZEluZGV4ID0gbGVmdENoaWxkSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJpZ2h0Q2hpbGRJbmRleCA9IHRoaXMuZ2V0UmlnaHRDaGlsZEluZGV4KGluZGV4KTtcbiAgICAgICAgaWYgKChyaWdodENoaWxkSW5kZXggIT09IC0xKSAmJlxuICAgICAgICAgICAgKHRoaXMuY29tcGFyZShyaWdodENoaWxkSW5kZXgsIGxhcmdlc3RDaGlsZEluZGV4KSA8IDApKSB7XG4gICAgICAgICAgICBsYXJnZXN0Q2hpbGRJbmRleCA9IHJpZ2h0Q2hpbGRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGxhcmdlc3RDaGlsZEluZGV4ID09PSBpbmRleCkgPyAtMSA6IGxhcmdlc3RDaGlsZEluZGV4O1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2lmdERvd24gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIHNpZnRJbmRleCA9IHRoaXMuc2lmdERvd25JbmRleChpbmRleCk7XG4gICAgICAgIHdoaWxlIChzaWZ0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnN3YXAoaW5kZXgsIHNpZnRJbmRleCk7XG4gICAgICAgICAgICBpbmRleCA9IHNpZnRJbmRleDtcbiAgICAgICAgICAgIHNpZnRJbmRleCA9IHRoaXMuc2lmdERvd25JbmRleChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYUluZGV4LCBiSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyYXRvcih0aGlzLmhlYXBbYUluZGV4XSwgdGhpcy5oZWFwW2JJbmRleF0pO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc3dhcCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciB0ZW1wID0gdGhpcy5oZWFwW2FdO1xuICAgICAgICB0aGlzLmhlYXBbYV0gPSB0aGlzLmhlYXBbYl07XG4gICAgICAgIHRoaXMuaGVhcFtiXSA9IHRlbXA7XG4gICAgICAgIHRoaXMub25JbmRleENoYW5nZWQodGhpcy5oZWFwW2FdLCBhKTtcbiAgICAgICAgdGhpcy5vbkluZGV4Q2hhbmdlZCh0aGlzLmhlYXBbYl0sIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIFByaW9yaXR5UXVldWU7XG59KCkpO1xuZXhwb3J0cy5Qcmlvcml0eVF1ZXVlID0gUHJpb3JpdHlRdWV1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByaW9yaXR5X3F1ZXVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl9lbWl0dGVyID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uX2VtaXR0ZXJcIik7XG52YXIgc2Vzc2lvbl91dGlsID0gcmVxdWlyZShcIi4vc2Vzc2lvbl91dGlsXCIpO1xudmFyIHRlbnNvcl9hcnJheV9tYXBfMSA9IHJlcXVpcmUoXCIuL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgRmVlZERpY3Rpb25hcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZlZWREaWN0aW9uYXJ5KGZlZWRFbnRyaWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGljdCA9IHt9O1xuICAgICAgICBpZiAoZmVlZEVudHJpZXMpIHtcbiAgICAgICAgICAgIGZlZWRFbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBfdGhpcy5kaWN0W2VudHJ5LnRlbnNvci5pZF0gPSBlbnRyeTsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEZlZWREaWN0aW9uYXJ5O1xufSgpKTtcbmV4cG9ydHMuRmVlZERpY3Rpb25hcnkgPSBGZWVkRGljdGlvbmFyeTtcbnZhciBDb3N0UmVkdWN0aW9uO1xuKGZ1bmN0aW9uIChDb3N0UmVkdWN0aW9uKSB7XG4gICAgQ29zdFJlZHVjdGlvbltDb3N0UmVkdWN0aW9uW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gICAgQ29zdFJlZHVjdGlvbltDb3N0UmVkdWN0aW9uW1wiU1VNXCJdID0gMV0gPSBcIlNVTVwiO1xuICAgIENvc3RSZWR1Y3Rpb25bQ29zdFJlZHVjdGlvbltcIk1FQU5cIl0gPSAyXSA9IFwiTUVBTlwiO1xufSkoQ29zdFJlZHVjdGlvbiA9IGV4cG9ydHMuQ29zdFJlZHVjdGlvbiB8fCAoZXhwb3J0cy5Db3N0UmVkdWN0aW9uID0ge30pKTtcbnZhciBTZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXNzaW9uKGdyYXBoLCBtYXRoKSB7XG4gICAgICAgIHRoaXMubWF0aCA9IG1hdGg7XG4gICAgICAgIHRoaXMuYWN0aXZhdGlvbkFycmF5TWFwID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICB0aGlzLnJ1bnRpbWVDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLm9uZVNjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDEpO1xuICAgICAgICB0aGlzLmdyYWRpZW50QXJyYXlNYXAgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlN1bW1lZFRlbnNvckFycmF5TWFwKHRoaXMubWF0aCk7XG4gICAgfVxuICAgIFNlc3Npb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYWN0aXZhdGlvbkFycmF5TWFwLmRpc3Bvc2UoKTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5ydW50aW1lQ2FjaGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHJ1bnRpbWUgPSBfdGhpcy5ydW50aW1lQ2FjaGVba2V5XTtcbiAgICAgICAgICAgIGlmIChydW50aW1lLm9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBydW50aW1lLm9wZXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJ1bnRpbWVDYWNoZSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5iYXRjaFNpemVTY2FsYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5iYXRjaFNpemVTY2FsYXIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25lU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmV2YWxBbGwgPSBmdW5jdGlvbiAodGVuc29ycywgZmVlZEVudHJpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmVlZCA9IG5ldyBGZWVkRGljdGlvbmFyeShmZWVkRW50cmllcyk7XG4gICAgICAgICAgICB2YXIgcnVudGltZSA9IF90aGlzLmdldE9yQ3JlYXRlUnVudGltZSh0ZW5zb3JzLCBmZWVkKTtcbiAgICAgICAgICAgIHZhciBhY3RpdmF0aW9ucyA9IF90aGlzLmFjdGl2YXRpb25BcnJheU1hcDtcbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5kaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbk91dHB1dHMocnVudGltZS5ub2RlcywgYWN0aXZhdGlvbnMpO1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmRpc3Bvc2VUcmFuc2llbnRPcGVyYXRpb25BcnJheXMocnVudGltZS5vcGVyYXRpb25zLCBfdGhpcy5hY3RpdmF0aW9uQXJyYXlNYXAsIF90aGlzLmdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmFkZFBlcnNpc3RlbnRBcnJheXNUb1RlbnNvckFycmF5TWFwKHJ1bnRpbWUubm9kZXMsIGFjdGl2YXRpb25zKTtcbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5sb2FkSW5wdXRzRnJvbUZlZWREaWN0aW9uYXJ5VG9UZW5zb3JBcnJheU1hcChmZWVkLCBhY3RpdmF0aW9ucywgX3RoaXMubWF0aCk7XG4gICAgICAgICAgICBydW50aW1lLm9wZXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLmZlZWRGb3J3YXJkKF90aGlzLm1hdGgsIGFjdGl2YXRpb25zKTsgfSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHRlbnNvcnMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBhY3RpdmF0aW9ucy5nZXQoeCk7IH0pO1xuICAgICAgICAgICAgdGVuc29ycy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7IHJldHVybiBhY3RpdmF0aW9ucy5kZWxldGUoeCk7IH0pO1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLnJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcChmZWVkLCBhY3RpdmF0aW9ucywgX3RoaXMubWF0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKHRlbnNvciwgZmVlZEVudHJpZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbEFsbChbdGVuc29yXSwgZmVlZEVudHJpZXMpWzBdO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUudHJhaW4gPSBmdW5jdGlvbiAoY29zdFRlbnNvciwgZmVlZEVudHJpZXMsIGJhdGNoU2l6ZSwgb3B0aW1pemVyLCBjb3N0UmVkdWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb3N0UmVkdWN0aW9uID09PSB2b2lkIDApIHsgY29zdFJlZHVjdGlvbiA9IENvc3RSZWR1Y3Rpb24uTk9ORTsgfVxuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzU2NhbGFyU2hhcGUoY29zdFRlbnNvci5zaGFwZSksICdDb3N0IHRlbnNvciBmb3IgdHJhaW5pbmcgbXVzdCBiZSBhIHNjYWxhciB2YWx1ZS4nKTtcbiAgICAgICAgaWYgKHRoaXMucHJldkJhdGNoU2l6ZSAhPT0gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZCYXRjaFNpemUgPSBiYXRjaFNpemU7XG4gICAgICAgICAgICB0aGlzLmJhdGNoU2l6ZVNjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KGJhdGNoU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZlZWQgPSBuZXcgRmVlZERpY3Rpb25hcnkoZmVlZEVudHJpZXMpO1xuICAgICAgICBzZXNzaW9uX3V0aWwudGhyb3dJZkZlZWREaWN0aW9uYXJ5Q29udGFpbnNOREFycmF5cyhmZWVkKTtcbiAgICAgICAgdmFyIHJ1bnRpbWUgPSB0aGlzLmdldE9yQ3JlYXRlUnVudGltZShbY29zdFRlbnNvcl0sIGZlZWQpO1xuICAgICAgICB2YXIgaW5mZXJlbmNlT3BlcmF0aW9ucyA9IHJ1bnRpbWUub3BlcmF0aW9ucztcbiAgICAgICAgdmFyIGJhY2tQcm9wT3BlcmF0aW9ucyA9IHJ1bnRpbWUub3BlcmF0aW9ucy5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgICAgdmFyIGFjdGl2YXRpb25zID0gdGhpcy5hY3RpdmF0aW9uQXJyYXlNYXA7XG4gICAgICAgIHZhciBncmFkaWVudHMgPSB0aGlzLmdyYWRpZW50QXJyYXlNYXA7XG4gICAgICAgIGdyYWRpZW50cy5udWxsaWZ5KGNvc3RUZW5zb3IpO1xuICAgICAgICBncmFkaWVudHMuYWRkKGNvc3RUZW5zb3IsIHRoaXMub25lU2NhbGFyKTtcbiAgICAgICAgc2Vzc2lvbl91dGlsLmFkZFBlcnNpc3RlbnRBcnJheXNUb1RlbnNvckFycmF5TWFwKHJ1bnRpbWUubm9kZXMsIGFjdGl2YXRpb25zKTtcbiAgICAgICAgb3B0aW1pemVyLmJlZm9yZUJhdGNoKHRoaXMubWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9ucywgZ3JhZGllbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCwgdHJhY2spIHtcbiAgICAgICAgICAgIHZhciBjb3N0ID0gdHJhY2sobmRhcnJheV8xLlNjYWxhci5uZXcoMCkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaFNpemU7ICsraSkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25fdXRpbC5kaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbk91dHB1dHMocnVudGltZS5ub2RlcywgYWN0aXZhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHNlc3Npb25fdXRpbC5kaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbklucHV0R3JhZGllbnRzKHJ1bnRpbWUubm9kZXMsIGdyYWRpZW50cyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmRpc3Bvc2VUcmFuc2llbnRPcGVyYXRpb25BcnJheXMocnVudGltZS5vcGVyYXRpb25zLCBhY3RpdmF0aW9ucywgZ3JhZGllbnRzKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uX3V0aWwubG9hZElucHV0c0Zyb21GZWVkRGljdGlvbmFyeVRvVGVuc29yQXJyYXlNYXAoZmVlZCwgYWN0aXZhdGlvbnMsIF90aGlzLm1hdGgpO1xuICAgICAgICAgICAgICAgIGluZmVyZW5jZU9wZXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLmZlZWRGb3J3YXJkKF90aGlzLm1hdGgsIGFjdGl2YXRpb25zKTsgfSk7XG4gICAgICAgICAgICAgICAgYmFja1Byb3BPcGVyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC5iYWNrUHJvcChfdGhpcy5tYXRoLCBhY3RpdmF0aW9ucywgZ3JhZGllbnRzKTsgfSk7XG4gICAgICAgICAgICAgICAgb3B0aW1pemVyLmFmdGVyRXhhbXBsZShfdGhpcy5tYXRoLCBydW50aW1lLCBhY3RpdmF0aW9ucywgZ3JhZGllbnRzKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uX3V0aWwucmVsZWFzZUZlZWREaWN0aW9uYXJ5SW5wdXRzRnJvbVRlbnNvckFycmF5TWFwKGZlZWQsIGFjdGl2YXRpb25zLCBfdGhpcy5tYXRoKTtcbiAgICAgICAgICAgICAgICBjb3N0ID0gX3RoaXMudXBkYXRlQ29zdEZvckV4YW1wbGUoY29zdCwgYWN0aXZhdGlvbnMuZ2V0KGNvc3RUZW5zb3IpLCBjb3N0UmVkdWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGltaXplci5hZnRlckJhdGNoKF90aGlzLm1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudXBkYXRlQ29zdEZvckJhdGNoKGNvc3QsIGNvc3RSZWR1Y3Rpb24pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnVwZGF0ZUNvc3RGb3JFeGFtcGxlID0gZnVuY3Rpb24gKHRvdGFsQ29zdCwgY3VyckNvc3QsIGNvc3RSZWR1Y3Rpb24pIHtcbiAgICAgICAgaWYgKGNvc3RSZWR1Y3Rpb24gPT09IENvc3RSZWR1Y3Rpb24uTUVBTiB8fFxuICAgICAgICAgICAgY29zdFJlZHVjdGlvbiA9PT0gQ29zdFJlZHVjdGlvbi5TVU0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGguYWRkKHRvdGFsQ29zdCwgY3VyckNvc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbENvc3Q7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS51cGRhdGVDb3N0Rm9yQmF0Y2ggPSBmdW5jdGlvbiAodG90YWxDb3N0LCBjb3N0UmVkdWN0aW9uKSB7XG4gICAgICAgIGlmIChjb3N0UmVkdWN0aW9uID09PSBDb3N0UmVkdWN0aW9uLk1FQU4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGguZGl2aWRlKHRvdGFsQ29zdCwgdGhpcy5iYXRjaFNpemVTY2FsYXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbENvc3Q7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5nZXRPckNyZWF0ZVJ1bnRpbWUgPSBmdW5jdGlvbiAodGVuc29ycywgZmVlZCkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5tYWtlUnVudGltZUNhY2hlS2V5KHRlbnNvcnMsIGZlZWQpO1xuICAgICAgICB2YXIgcnVudGltZSA9IHRoaXMucnVudGltZUNhY2hlW2tleV07XG4gICAgICAgIGlmIChydW50aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHNlc3Npb25fdXRpbC5nZXRPcmRlcmVkRXZhbHVhdGlvblNldEZyb21FdmFsVGVuc29yKHRlbnNvcnMsIGZlZWQpO1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLnJlbW92ZUZlZWREaWN0aW9uYXJ5Tm9kZXNGcm9tRXZhbHVhdGlvblNldChmZWVkLCBub2Rlcyk7XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwudGhyb3dFcnJvcklmRXZhbHVhdGlvblNldENvbnRhaW5zUGxhY2Vob2xkZXJOb2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICB2YXIgb3BlcmF0aW9ucyA9IG9wZXJhdGlvbl9lbWl0dGVyLmVtaXRGcm9tR3JhcGhOb2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICBydW50aW1lID0geyBub2Rlczogbm9kZXMsIG9wZXJhdGlvbnM6IG9wZXJhdGlvbnMgfTtcbiAgICAgICAgICAgIHRoaXMucnVudGltZUNhY2hlW2tleV0gPSBydW50aW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW50aW1lO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUubWFrZVJ1bnRpbWVDYWNoZUtleSA9IGZ1bmN0aW9uICh0ZW5zb3JzLCBmZWVkKSB7XG4gICAgICAgIHJldHVybiB0ZW5zb3JzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSkuc29ydCgpLmpvaW4oJ18nKSArICdfXycgK1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZmVlZC5kaWN0KS5zb3J0KCkuam9pbignXycpO1xuICAgIH07XG4gICAgcmV0dXJuIFNlc3Npb247XG59KCkpO1xuZXhwb3J0cy5TZXNzaW9uID0gU2Vzc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlc3Npb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgZ3JhcGhfMSA9IHJlcXVpcmUoXCIuL2dyYXBoXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi9ncmFwaF91dGlsXCIpO1xuZnVuY3Rpb24gZ2V0VGVybWluYXRpbmdOb2Rlc0Zyb21GZWVkRGljdGlvbmFyeShmZWVkRGljdGlvbmFyeSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhmZWVkRGljdGlvbmFyeS5kaWN0KVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh0ZW5zb3JJRCkgeyByZXR1cm4gZmVlZERpY3Rpb25hcnkuZGljdFsrdGVuc29ySURdLnRlbnNvci5ub2RlOyB9KTtcbn1cbmV4cG9ydHMuZ2V0VGVybWluYXRpbmdOb2Rlc0Zyb21GZWVkRGljdGlvbmFyeSA9IGdldFRlcm1pbmF0aW5nTm9kZXNGcm9tRmVlZERpY3Rpb25hcnk7XG5mdW5jdGlvbiBnZXRPcmRlcmVkRXZhbHVhdGlvblNldEZyb21FdmFsVGVuc29yKGV2YWxUZW5zb3JzLCBmZWVkRGljdGlvbmFyeSkge1xuICAgIHZhciB0ZXJtaW5hdGluZ05vZGVzID0gZ2V0VGVybWluYXRpbmdOb2Rlc0Zyb21GZWVkRGljdGlvbmFyeShmZWVkRGljdGlvbmFyeSk7XG4gICAgdmFyIGV2YWxOb2RlcyA9IGV2YWxUZW5zb3JzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5ub2RlOyB9KTtcbiAgICB2YXIgdW5vcmRlcmVkRXZhbHVhdGlvblNldCA9IGdyYXBoX3V0aWwuZ2V0VW5vcmRlcmVkRXZhbHVhdGlvblNldChldmFsTm9kZXMsIHRlcm1pbmF0aW5nTm9kZXMpO1xuICAgIHZhciBvcmRlcmVkRXZhbHVhdGlvblNldCA9IGdyYXBoX3V0aWwuZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXQodW5vcmRlcmVkRXZhbHVhdGlvblNldCk7XG4gICAgcmV0dXJuIG9yZGVyZWRFdmFsdWF0aW9uU2V0O1xufVxuZXhwb3J0cy5nZXRPcmRlcmVkRXZhbHVhdGlvblNldEZyb21FdmFsVGVuc29yID0gZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXRGcm9tRXZhbFRlbnNvcjtcbmZ1bmN0aW9uIGFkZFBlcnNpc3RlbnRBcnJheXNUb1RlbnNvckFycmF5TWFwKGV2YWx1YXRpb25TZXQsIHRlbnNvckFycmF5TWFwKSB7XG4gICAgZXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5WYXJpYWJsZU5vZGUgfHwgbm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQ29uc3RhbnROb2RlKSB7XG4gICAgICAgICAgICB0ZW5zb3JBcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIG5vZGUuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuYWRkUGVyc2lzdGVudEFycmF5c1RvVGVuc29yQXJyYXlNYXAgPSBhZGRQZXJzaXN0ZW50QXJyYXlzVG9UZW5zb3JBcnJheU1hcDtcbmZ1bmN0aW9uIGdldFZhcmlhYmxlTm9kZXNGcm9tRXZhbHVhdGlvblNldChldmFsdWF0aW9uU2V0KSB7XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgZXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5WYXJpYWJsZU5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZXM7XG59XG5leHBvcnRzLmdldFZhcmlhYmxlTm9kZXNGcm9tRXZhbHVhdGlvblNldCA9IGdldFZhcmlhYmxlTm9kZXNGcm9tRXZhbHVhdGlvblNldDtcbmZ1bmN0aW9uIHRocm93SWZGZWVkRGljdGlvbmFyeUNvbnRhaW5zTkRBcnJheXMoZmVlZERpY3Rpb25hcnkpIHtcbiAgICBPYmplY3Qua2V5cyhmZWVkRGljdGlvbmFyeS5kaWN0KS5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3JJRCkge1xuICAgICAgICBpZiAoZmVlZERpY3Rpb25hcnkuZGljdFsrdGVuc29ySURdLmRhdGEgaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFpbmluZyByZXF1aXJlcyBGZWVkRGljdGlvbmFyeSBlbnRyaWVzIHRvIGJlIElucHV0UHJvdmlkZXJzJyArXG4gICAgICAgICAgICAgICAgJ2FuZCBub3QgTkRBcnJheXMuJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMudGhyb3dJZkZlZWREaWN0aW9uYXJ5Q29udGFpbnNOREFycmF5cyA9IHRocm93SWZGZWVkRGljdGlvbmFyeUNvbnRhaW5zTkRBcnJheXM7XG5mdW5jdGlvbiBsb2FkSW5wdXRzRnJvbUZlZWREaWN0aW9uYXJ5VG9UZW5zb3JBcnJheU1hcChiYXRjaEZlZWQsIGFjdGl2YXRpb25zLCBtYXRoKSB7XG4gICAgT2JqZWN0LmtleXMoYmF0Y2hGZWVkLmRpY3QpLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcklEKSB7XG4gICAgICAgIHZhciBmZWVkRW50cnkgPSBiYXRjaEZlZWQuZGljdFsrdGVuc29ySURdO1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGZlZWRFbnRyeS5kYXRhIGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBmZWVkRW50cnkuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IGZlZWRFbnRyeS5kYXRhO1xuICAgICAgICAgICAgZGF0YSA9IHByb3ZpZGVyLmdldE5leHRDb3B5KG1hdGgpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuYXJyYXlzRXF1YWwoZmVlZEVudHJ5LnRlbnNvci5zaGFwZSwgZGF0YS5zaGFwZSksIFwiRXJyb3IgbG9hZGluZyBGZWVkRW50cnk6IGZlZWRpbmcgTkRBcnJheSBvZiBzaGFwZSBcIiArIGRhdGEuc2hhcGUgKyBcIiBcIiArXG4gICAgICAgICAgICAoXCJkb2VzIG5vdCBtYXRjaCBUZW5zb3IgKGlkOiBcIiArIGZlZWRFbnRyeS50ZW5zb3IuaWQgKyBcIikgc2hhcGU6IFwiKSArXG4gICAgICAgICAgICAoZmVlZEVudHJ5LnRlbnNvci5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIGFjdGl2YXRpb25zLnNldChmZWVkRW50cnkudGVuc29yLCBkYXRhKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9hZElucHV0c0Zyb21GZWVkRGljdGlvbmFyeVRvVGVuc29yQXJyYXlNYXAgPSBsb2FkSW5wdXRzRnJvbUZlZWREaWN0aW9uYXJ5VG9UZW5zb3JBcnJheU1hcDtcbmZ1bmN0aW9uIHJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcChiYXRjaEZlZWQsIGFjdGl2YXRpb25zLCBtYXRoKSB7XG4gICAgT2JqZWN0LmtleXMoYmF0Y2hGZWVkLmRpY3QpLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcklEKSB7XG4gICAgICAgIHZhciBmZWVkRW50cnkgPSBiYXRjaEZlZWQuZGljdFsrdGVuc29ySURdO1xuICAgICAgICBpZiAoIShmZWVkRW50cnkuZGF0YSBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSkge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gZmVlZEVudHJ5LmRhdGE7XG4gICAgICAgICAgICB2YXIgZmVlZEVudHJ5QXJyYXkgPSBhY3RpdmF0aW9ucy5nZXQoZmVlZEVudHJ5LnRlbnNvcik7XG4gICAgICAgICAgICBwcm92aWRlci5kaXNwb3NlQ29weShtYXRoLCBmZWVkRW50cnlBcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZhdGlvbnMuZGVsZXRlKGZlZWRFbnRyeS50ZW5zb3IpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5yZWxlYXNlRmVlZERpY3Rpb25hcnlJbnB1dHNGcm9tVGVuc29yQXJyYXlNYXAgPSByZWxlYXNlRmVlZERpY3Rpb25hcnlJbnB1dHNGcm9tVGVuc29yQXJyYXlNYXA7XG5mdW5jdGlvbiByZW1vdmVGZWVkRGljdGlvbmFyeU5vZGVzRnJvbUV2YWx1YXRpb25TZXQoZmVlZERpY3Rpb25hcnksIGV2YWx1YXRpb25TZXQpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBldmFsdWF0aW9uU2V0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgbm9kZSA9IGV2YWx1YXRpb25TZXRbaV07XG4gICAgICAgIGlmIChmZWVkRGljdGlvbmFyeS5kaWN0W25vZGUub3V0cHV0LmlkXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBldmFsdWF0aW9uU2V0LnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMucmVtb3ZlRmVlZERpY3Rpb25hcnlOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0ID0gcmVtb3ZlRmVlZERpY3Rpb25hcnlOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0O1xuZnVuY3Rpb24gZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25PdXRwdXRzKGV2YWx1YXRpb25TZXQsIHRlbnNvckFycmF5TWFwKSB7XG4gICAgZXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghZ3JhcGhfdXRpbC5pc0lucHV0Tm9kZShub2RlKSkge1xuICAgICAgICAgICAgaWYgKCFncmFwaF91dGlsLmlzUGFzc3Rocm91Z2hOb2RlKG5vZGUsIHRlbnNvckFycmF5TWFwKSkge1xuICAgICAgICAgICAgICAgIHRlbnNvckFycmF5TWFwLmRpc3Bvc2VBcnJheShub2RlLm91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW5zb3JBcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uT3V0cHV0cyA9IGRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uT3V0cHV0cztcbmZ1bmN0aW9uIGRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uSW5wdXRHcmFkaWVudHMoZXZhbHVhdGlvblNldCwgZ3JhZGllbnRzKSB7XG4gICAgZXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG5vZGUuaW5wdXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IG5vZGUuaW5wdXRzW2lucHV0TmFtZV07XG4gICAgICAgICAgICBpZiAoZ3JhZGllbnRzLmdldChpbnB1dCwgdHJ1ZSkgIT09IGdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRzLmRpc3Bvc2VBcnJheShpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFkaWVudHMubnVsbGlmeShpbnB1dCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbklucHV0R3JhZGllbnRzID0gZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25JbnB1dEdyYWRpZW50cztcbmZ1bmN0aW9uIGRpc3Bvc2VUcmFuc2llbnRPcGVyYXRpb25BcnJheXMob3BlcmF0aW9ucywgYWN0aXZhdGlvbnMsIGdyYWRpZW50cykge1xuICAgIG9wZXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLmRpc3Bvc2VUcmFuc2llbnRBcnJheXMoYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7IH0pO1xufVxuZXhwb3J0cy5kaXNwb3NlVHJhbnNpZW50T3BlcmF0aW9uQXJyYXlzID0gZGlzcG9zZVRyYW5zaWVudE9wZXJhdGlvbkFycmF5cztcbmZ1bmN0aW9uIHRocm93RXJyb3JJZkV2YWx1YXRpb25TZXRDb250YWluc1BsYWNlaG9sZGVyTm9kZXMoZXZhbHVhdGlvblNldCkge1xuICAgIGV2YWx1YXRpb25TZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuUGxhY2Vob2xkZXJOb2RlKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSAnWycgKyBub2RlLm91dHB1dC5zaGFwZS5qb2luKCcsICcpICsgJ10nO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGFjZWhvbGRlciBub2RlIFwiJyArIG5vZGUubmFtZSArICdcIiAnICsgc2hhcGUgK1xuICAgICAgICAgICAgICAgICcgbm90IHByZXNlbnQgaW4gZmVlZCBkaWN0aW9uYXJ5LicpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnRocm93RXJyb3JJZkV2YWx1YXRpb25TZXRDb250YWluc1BsYWNlaG9sZGVyTm9kZXMgPSB0aHJvd0Vycm9ySWZFdmFsdWF0aW9uU2V0Q29udGFpbnNQbGFjZWhvbGRlck5vZGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Vzc2lvbl91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVGVuc29yQXJyYXlNYXBCYXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW5zb3JBcnJheU1hcEJhc2UoKSB7XG4gICAgICAgIHRoaXMuZGljdCA9IHt9O1xuICAgIH1cbiAgICBUZW5zb3JBcnJheU1hcEJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0ZW5zb3IsIHNraXBDaGVja3MpIHtcbiAgICAgICAgaWYgKHNraXBDaGVja3MgPT09IHZvaWQgMCkgeyBza2lwQ2hlY2tzID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKCFza2lwQ2hlY2tzICYmIHRoaXMuZGljdFt0ZW5zb3IuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRlbnNvciBcIiArIHRlbnNvci5pZCArIFwiIG5vdCBpbiBhcnJheSBtYXAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZGEgPSB0aGlzLmRpY3RbdGVuc29yLmlkXTtcbiAgICAgICAgaWYgKCFza2lwQ2hlY2tzICYmIG5kYSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGVuc29yIFwiICsgdGVuc29yLmlkICsgXCIgaGFzIG51bGwgYXJyYXkuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGE7XG4gICAgfTtcbiAgICBUZW5zb3JBcnJheU1hcEJhc2UucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGljdFt0ZW5zb3IuaWRdO1xuICAgIH07XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5udWxsaWZ5ID0gZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICB0aGlzLmRpY3RbdGVuc29yLmlkXSA9IG51bGw7XG4gICAgfTtcbiAgICBUZW5zb3JBcnJheU1hcEJhc2UucHJvdG90eXBlLmRpc3Bvc2VBcnJheSA9IGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuZGljdFt0ZW5zb3IuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmRhID0gdGhpcy5kaWN0W3RlbnNvci5pZF07XG4gICAgICAgIGlmIChuZGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZGEuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmRpY3RbdGVuc29yLmlkXSA9IG51bGw7XG4gICAgfTtcbiAgICBUZW5zb3JBcnJheU1hcEJhc2UucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmRpY3QpLmxlbmd0aDtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5kaWN0KS5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3JJRCkge1xuICAgICAgICAgICAgdmFyIG5kYSA9IF90aGlzLmRpY3RbK3RlbnNvcklEXTtcbiAgICAgICAgICAgIGlmIChuZGEpIHtcbiAgICAgICAgICAgICAgICBuZGEuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaWN0ID0ge307XG4gICAgfTtcbiAgICBUZW5zb3JBcnJheU1hcEJhc2UucHJvdG90eXBlLmhhc051bGxBcnJheSA9IGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuZGljdFt0ZW5zb3IuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRlbnNvciBcIiArIHRlbnNvci5pZCArIFwiIG5vdCBpbiBhcnJheSBtYXAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRpY3RbdGVuc29yLmlkXSA9PT0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBUZW5zb3JBcnJheU1hcEJhc2U7XG59KCkpO1xuZXhwb3J0cy5UZW5zb3JBcnJheU1hcEJhc2UgPSBUZW5zb3JBcnJheU1hcEJhc2U7XG52YXIgVGVuc29yQXJyYXlNYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUZW5zb3JBcnJheU1hcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZW5zb3JBcnJheU1hcCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUZW5zb3JBcnJheU1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHRlbnNvciwgYXJyYXkpIHtcbiAgICAgICAgdGhpcy5kaWN0W3RlbnNvci5pZF0gPSBhcnJheTtcbiAgICB9O1xuICAgIHJldHVybiBUZW5zb3JBcnJheU1hcDtcbn0oVGVuc29yQXJyYXlNYXBCYXNlKSk7XG5leHBvcnRzLlRlbnNvckFycmF5TWFwID0gVGVuc29yQXJyYXlNYXA7XG52YXIgU3VtbWVkVGVuc29yQXJyYXlNYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdW1tZWRUZW5zb3JBcnJheU1hcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdW1tZWRUZW5zb3JBcnJheU1hcChtYXRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1hdGggPSBtYXRoO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN1bW1lZFRlbnNvckFycmF5TWFwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGVuc29yLCBhcnJheSkge1xuICAgICAgICBpZiAodGhpcy5kaWN0W3RlbnNvci5pZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kaWN0W3RlbnNvci5pZF0gPSB0aGlzLm1hdGgua2VlcChhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLmdldCh0ZW5zb3IpO1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5tYXRoLmtlZXAodGhpcy5tYXRoLmFkZFN0cmljdChvbGRWYWx1ZSwgYXJyYXkpKTtcbiAgICAgICAgICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBvbGRWYWx1ZS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdW1tZWRUZW5zb3JBcnJheU1hcDtcbn0oVGVuc29yQXJyYXlNYXBCYXNlKSk7XG5leHBvcnRzLlN1bW1lZFRlbnNvckFycmF5TWFwID0gU3VtbWVkVGVuc29yQXJyYXlNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW5zb3JfYXJyYXlfbWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNlc3Npb25fMSA9IHJlcXVpcmUoXCIuL2dyYXBoL3Nlc3Npb25cIik7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIERFRkFVTFRfRVZBTF9JTlRFUlZBTF9NUyA9IDE1MDA7XG52YXIgREVGQVVMVF9DT1NUX0lOVEVSVkFMX01TID0gNTAwO1xudmFyIERFRkFVTFRfSU5GRVJFTkNFX0VYQU1QTEVfSU5URVJWQUxfTVMgPSAzMDAwO1xudmFyIE1ldHJpY1JlZHVjdGlvbjtcbihmdW5jdGlvbiAoTWV0cmljUmVkdWN0aW9uKSB7XG4gICAgTWV0cmljUmVkdWN0aW9uW01ldHJpY1JlZHVjdGlvbltcIlNVTVwiXSA9IDBdID0gXCJTVU1cIjtcbiAgICBNZXRyaWNSZWR1Y3Rpb25bTWV0cmljUmVkdWN0aW9uW1wiTUVBTlwiXSA9IDFdID0gXCJNRUFOXCI7XG59KShNZXRyaWNSZWR1Y3Rpb24gPSBleHBvcnRzLk1ldHJpY1JlZHVjdGlvbiB8fCAoZXhwb3J0cy5NZXRyaWNSZWR1Y3Rpb24gPSB7fSkpO1xudmFyIEdyYXBoUnVubmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmFwaFJ1bm5lcihtYXRoLCBzZXNzaW9uLCBldmVudE9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMubWF0aCA9IG1hdGg7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlciA9IGV2ZW50T2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMubGFzdENvc3RUaW1lc3RhbXAgPSAwO1xuICAgICAgICB0aGlzLmxhc3RFdmFsVGltZXN0YW1wID0gMDtcbiAgICAgICAgdGhpcy50b3RhbElkbGVUaW1lTXMgPSAwO1xuICAgICAgICB0aGlzLnJlc2V0U3RhdGlzdGljcygpO1xuICAgICAgICB0aGlzLnplcm9TY2FsYXIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygwKTtcbiAgICB9XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnJlc2V0U3RhdGlzdGljcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50b3RhbEJhdGNoZXNUcmFpbmVkID0gMDtcbiAgICAgICAgdGhpcy50b3RhbElkbGVUaW1lTXMgPSAwO1xuICAgICAgICB0aGlzLmxhc3RTdG9wVGltZXN0YW1wID0gbnVsbDtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS50cmFpbiA9IGZ1bmN0aW9uIChjb3N0VGVuc29yLCB0cmFpbkZlZWRFbnRyaWVzLCBiYXRjaFNpemUsIG9wdGltaXplciwgbnVtQmF0Y2hlcywgbWV0cmljVGVuc29yLCBtZXRyaWNGZWVkRW50cmllcywgbWV0cmljQmF0Y2hTaXplLCBtZXRyaWNSZWR1Y3Rpb24sIGV2YWxJbnRlcnZhbE1zLCBjb3N0SW50ZXJ2YWxNcykge1xuICAgICAgICBpZiAobWV0cmljUmVkdWN0aW9uID09PSB2b2lkIDApIHsgbWV0cmljUmVkdWN0aW9uID0gTWV0cmljUmVkdWN0aW9uLk1FQU47IH1cbiAgICAgICAgaWYgKGV2YWxJbnRlcnZhbE1zID09PSB2b2lkIDApIHsgZXZhbEludGVydmFsTXMgPSBERUZBVUxUX0VWQUxfSU5URVJWQUxfTVM7IH1cbiAgICAgICAgaWYgKGNvc3RJbnRlcnZhbE1zID09PSB2b2lkIDApIHsgY29zdEludGVydmFsTXMgPSBERUZBVUxUX0NPU1RfSU5URVJWQUxfTVM7IH1cbiAgICAgICAgdGhpcy5jb3N0VGVuc29yID0gY29zdFRlbnNvcjtcbiAgICAgICAgdGhpcy50cmFpbkZlZWRFbnRyaWVzID0gdHJhaW5GZWVkRW50cmllcztcbiAgICAgICAgdGhpcy5tZXRyaWNUZW5zb3IgPSBtZXRyaWNUZW5zb3I7XG4gICAgICAgIHRoaXMubWV0cmljRmVlZEVudHJpZXMgPSBtZXRyaWNGZWVkRW50cmllcztcbiAgICAgICAgaWYgKG1ldHJpY0JhdGNoU2l6ZSAhPSBudWxsICYmIHRoaXMubWV0cmljQmF0Y2hTaXplICE9PSBtZXRyaWNCYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1ldHJpY0JhdGNoU2l6ZVNjYWxhciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRyaWNCYXRjaFNpemVTY2FsYXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZXRyaWNCYXRjaFNpemVTY2FsYXIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhtZXRyaWNCYXRjaFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWV0cmljQmF0Y2hTaXplID0gbWV0cmljQmF0Y2hTaXplO1xuICAgICAgICB0aGlzLm1ldHJpY1JlZHVjdGlvbiA9IG1ldHJpY1JlZHVjdGlvbjtcbiAgICAgICAgdGhpcy5iYXRjaFNpemUgPSBiYXRjaFNpemU7XG4gICAgICAgIHRoaXMub3B0aW1pemVyID0gb3B0aW1pemVyO1xuICAgICAgICB0aGlzLm1ldHJpY0ludGVydmFsTXMgPSBldmFsSW50ZXJ2YWxNcztcbiAgICAgICAgdGhpcy5jb3N0SW50ZXJ2YWxNcyA9IGNvc3RJbnRlcnZhbE1zO1xuICAgICAgICB0aGlzLmN1cnJlbnRUcmFpbkxvb3BOdW1CYXRjaGVzID0gbnVtQmF0Y2hlcztcbiAgICAgICAgdGhpcy5iYXRjaGVzVHJhaW5lZFRoaXNSdW4gPSAwO1xuICAgICAgICB0aGlzLmlzVHJhaW5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyYWluU3RhcnRUaW1lc3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy50cmFpbk5ldHdvcmsoKTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5zdG9wVHJhaW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNUcmFpbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RTdG9wVGltZXN0YW1wID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUucmVzdW1lVHJhaW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNUcmFpbmluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmxhc3RTdG9wVGltZXN0YW1wICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudG90YWxJZGxlVGltZU1zICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5sYXN0U3RvcFRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWluTmV0d29yaygpO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnRyYWluTmV0d29yayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2hlc1RyYWluZWRUaGlzUnVuID09PSB0aGlzLmN1cnJlbnRUcmFpbkxvb3BOdW1CYXRjaGVzKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BUcmFpbmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1RyYWluaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudE9ic2VydmVyLmRvbmVUcmFpbmluZ0NhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXIuZG9uZVRyYWluaW5nQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdmFyIHNob3VsZENvbXB1dGVDb3N0ID0gdGhpcy5ldmVudE9ic2VydmVyLmF2Z0Nvc3RDYWxsYmFjayAhPSBudWxsICYmXG4gICAgICAgICAgICAoc3RhcnQgLSB0aGlzLmxhc3RDb3N0VGltZXN0YW1wID4gdGhpcy5jb3N0SW50ZXJ2YWxNcyk7XG4gICAgICAgIGlmIChzaG91bGRDb21wdXRlQ29zdCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29zdFRpbWVzdGFtcCA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3N0UmVkdWN0aW9uID0gc2hvdWxkQ29tcHV0ZUNvc3QgPyBzZXNzaW9uXzEuQ29zdFJlZHVjdGlvbi5NRUFOIDogc2Vzc2lvbl8xLkNvc3RSZWR1Y3Rpb24uTk9ORTtcbiAgICAgICAgdGhpcy5tYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICB2YXIgYXZnQ29zdCA9IF90aGlzLnNlc3Npb24udHJhaW4oX3RoaXMuY29zdFRlbnNvciwgX3RoaXMudHJhaW5GZWVkRW50cmllcywgX3RoaXMuYmF0Y2hTaXplLCBfdGhpcy5vcHRpbWl6ZXIsIGNvc3RSZWR1Y3Rpb24pO1xuICAgICAgICAgICAgaWYgKHNob3VsZENvbXB1dGVDb3N0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWluVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci5hdmdDb3N0Q2FsbGJhY2soYXZnQ29zdCk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmV2ZW50T2JzZXJ2ZXIudHJhaW5FeGFtcGxlc1BlclNlY0NhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4YW1wbGVzUGVyU2VjID0gKF90aGlzLmJhdGNoU2l6ZSAqIDEwMDAgLyB0cmFpblRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudE9ic2VydmVyLnRyYWluRXhhbXBsZXNQZXJTZWNDYWxsYmFjayhleGFtcGxlc1BlclNlYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmV2ZW50T2JzZXJ2ZXIubWV0cmljQ2FsbGJhY2sgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIF90aGlzLm1ldHJpY0ZlZWRFbnRyaWVzICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBzdGFydCAtIF90aGlzLmxhc3RFdmFsVGltZXN0YW1wID4gX3RoaXMubWV0cmljSW50ZXJ2YWxNcykge1xuICAgICAgICAgICAgICAgIF90aGlzLmxhc3RFdmFsVGltZXN0YW1wID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmxhc3RDb21wdXRlZE1ldHJpYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxhc3RDb21wdXRlZE1ldHJpYy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmxhc3RDb21wdXRlZE1ldHJpYyA9IF90aGlzLmNvbXB1dGVNZXRyaWMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudE9ic2VydmVyLm1ldHJpY0NhbGxiYWNrKF90aGlzLmxhc3RDb21wdXRlZE1ldHJpYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuZXZlbnRPYnNlcnZlci50b3RhbFRpbWVDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci50b3RhbFRpbWVDYWxsYmFjaygoc3RhcnQgLSBfdGhpcy50cmFpblN0YXJ0VGltZXN0YW1wKSAvIDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuYmF0Y2hlc1RyYWluZWRUaGlzUnVuKys7XG4gICAgICAgICAgICBfdGhpcy50b3RhbEJhdGNoZXNUcmFpbmVkKys7XG4gICAgICAgICAgICBpZiAoX3RoaXMuZXZlbnRPYnNlcnZlci5iYXRjaGVzVHJhaW5lZENhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudE9ic2VydmVyLmJhdGNoZXNUcmFpbmVkQ2FsbGJhY2soX3RoaXMudG90YWxCYXRjaGVzVHJhaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudHJhaW5OZXR3b3JrKCk7IH0pO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLmluZmVyID0gZnVuY3Rpb24gKGluZmVyZW5jZVRlbnNvciwgaW5mZXJlbmNlRmVlZEVudHJpZXMsIGluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zLCBpbmZlcmVuY2VFeGFtcGxlQ291bnQsIG51bVBhc3Nlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXMgPT09IHZvaWQgMCkgeyBpbmZlcmVuY2VFeGFtcGxlSW50ZXJ2YWxNcyA9IERFRkFVTFRfSU5GRVJFTkNFX0VYQU1QTEVfSU5URVJWQUxfTVM7IH1cbiAgICAgICAgaWYgKGluZmVyZW5jZUV4YW1wbGVDb3VudCA9PT0gdm9pZCAwKSB7IGluZmVyZW5jZUV4YW1wbGVDb3VudCA9IDU7IH1cbiAgICAgICAgaWYgKHRoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc0NhbGxiYWNrID09IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc1BlclNlY0NhbGxiYWNrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN0YXJ0IGluZmVyZW5jZSBsb29wLCBubyBpbmZlcmVuY2UgZXhhbXBsZSBvciAnICtcbiAgICAgICAgICAgICAgICAnZXhhbXBsZXMvc2VjIG9ic2VydmVyIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5mZXJlbmNlRmVlZEVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmZWVkRW50cnkgPSBpbmZlcmVuY2VGZWVkRW50cmllc1tpXTtcbiAgICAgICAgICAgIGlmIChmZWVkRW50cnkuZGF0YSBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3RhcnQgaW5mZXJlbmNlIG9uIHRoZSBtb2RlbCBydW5uZXIgd2l0aCBmZWVkIGVudHJpZXMgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgICd0eXBlIE5EQXJyYXkuIFBsZWFzZSB1c2UgSW5wdXRQcm92aWRlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmZlcmVuY2VFeGFtcGxlSW50ZXJ2YWxNcyA9IGluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zO1xuICAgICAgICB0aGlzLmluZmVyZW5jZVRlbnNvciA9IGluZmVyZW5jZVRlbnNvcjtcbiAgICAgICAgdGhpcy5pbmZlcmVuY2VGZWVkRW50cmllcyA9IGluZmVyZW5jZUZlZWRFbnRyaWVzO1xuICAgICAgICB0aGlzLmluZmVyZW5jZUV4YW1wbGVDb3VudCA9IGluZmVyZW5jZUV4YW1wbGVDb3VudDtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5mZXJlbmNlTG9vcE51bVBhc3NlcyA9IG51bVBhc3NlcztcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5mZXJyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmluZmVyZW5jZVBhc3Nlc1RoaXNSdW4gPSAwO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmluZmVyTmV0d29yaygpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzSW5mZXJyaW5nID0gdHJ1ZTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5pbmZlck5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5pc0luZmVycmluZyB8fFxuICAgICAgICAgICAgdGhpcy5pbmZlcmVuY2VQYXNzZXNUaGlzUnVuID09PSB0aGlzLmN1cnJlbnRJbmZlcmVuY2VMb29wTnVtUGFzc2VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwLCB0cmFjaykge1xuICAgICAgICAgICAgdmFyIGZlZWRzID0gW107XG4gICAgICAgICAgICB2YXIgaW5mZXJlbmNlVmFsdWVzID0gW107XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuaW5mZXJlbmNlRXhhbXBsZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmRhcnJheUZlZWRFbnRyaWVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfdGhpcy5pbmZlcmVuY2VGZWVkRW50cmllcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmVlZEVudHJ5ID0gX3RoaXMuaW5mZXJlbmNlRmVlZEVudHJpZXNbal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q29weSA9IGZlZWRFbnRyeS5kYXRhLmdldE5leHRDb3B5KF90aGlzLm1hdGgpO1xuICAgICAgICAgICAgICAgICAgICBuZGFycmF5RmVlZEVudHJpZXMucHVzaCh7IHRlbnNvcjogZmVlZEVudHJ5LnRlbnNvciwgZGF0YTogdHJhY2sobmV4dENvcHkpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmZWVkcy5wdXNoKG5kYXJyYXlGZWVkRW50cmllcyk7XG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlVmFsdWVzLnB1c2goX3RoaXMuc2Vzc2lvbi5ldmFsKF90aGlzLmluZmVyZW5jZVRlbnNvciwgbmRhcnJheUZlZWRFbnRyaWVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc1BlclNlY0NhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmZlcmVuY2VWYWx1ZXNbaW5mZXJlbmNlVmFsdWVzLmxlbmd0aCAtIDFdLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgICAgIHZhciBpbmZlcmVuY2VFeGFtcGxlc1BlclNlY1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIHZhciBleGFtcGxlc1BlclNlYyA9IChfdGhpcy5pbmZlcmVuY2VFeGFtcGxlQ291bnQgKiAxMDAwIC8gaW5mZXJlbmNlRXhhbXBsZXNQZXJTZWNUaW1lKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzUGVyU2VjQ2FsbGJhY2soZXhhbXBsZXNQZXJTZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc0NhbGxiYWNrKGZlZWRzLCBpbmZlcmVuY2VWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaW5mZXJlbmNlUGFzc2VzVGhpc1J1bisrO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sYXN0SW5mZXJUaW1lb3V0SUQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5pbmZlck5ldHdvcmsoKTsgfSwgdGhpcy5pbmZlcmVuY2VFeGFtcGxlSW50ZXJ2YWxNcyk7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuc3RvcEluZmVycmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0luZmVycmluZyA9IGZhbHNlO1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMubGFzdEluZmVyVGltZW91dElEKTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5pc0luZmVyZW5jZVJ1bm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSW5mZXJyaW5nO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLmNvbXB1dGVNZXRyaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLm1ldHJpY0ZlZWRFbnRyaWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXB1dGUgbWV0cmljLCBubyBtZXRyaWMgRmVlZEVudHJpZXMgcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldHJpYyA9IHRoaXMuemVyb1NjYWxhcjtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5tZXRyaWNCYXRjaFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBtZXRyaWNWYWx1ZSA9IF90aGlzLnNlc3Npb24uZXZhbChfdGhpcy5tZXRyaWNUZW5zb3IsIF90aGlzLm1ldHJpY0ZlZWRFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICBtZXRyaWMgPSBfdGhpcy5tYXRoLmFkZChtZXRyaWMsIG1ldHJpY1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5tZXRyaWNSZWR1Y3Rpb24gPT09IE1ldHJpY1JlZHVjdGlvbi5NRUFOKSB7XG4gICAgICAgICAgICAgICAgbWV0cmljID0gX3RoaXMubWF0aC5kaXZpZGUobWV0cmljLCBfdGhpcy5tZXRyaWNCYXRjaFNpemVTY2FsYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ldHJpYztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuZ2V0VG90YWxCYXRjaGVzVHJhaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG90YWxCYXRjaGVzVHJhaW5lZDtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5nZXRMYXN0Q29tcHV0ZWRNZXRyaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDb21wdXRlZE1ldHJpYztcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5zZXRNYXRoID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgICAgICAgdGhpcy5tYXRoID0gbWF0aDtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5zZXRTZXNzaW9uID0gZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5zZXRJbmZlcmVuY2VUZW5zb3IgPSBmdW5jdGlvbiAoaW5mZXJlbmNlVGVuc29yKSB7XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlVGVuc29yID0gaW5mZXJlbmNlVGVuc29yO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnNldEluZmVyZW5jZUV4YW1wbGVDb3VudCA9IGZ1bmN0aW9uIChpbmZlcmVuY2VFeGFtcGxlQ291bnQpIHtcbiAgICAgICAgdGhpcy5pbmZlcmVuY2VFeGFtcGxlQ291bnQgPSBpbmZlcmVuY2VFeGFtcGxlQ291bnQ7XG4gICAgfTtcbiAgICByZXR1cm4gR3JhcGhSdW5uZXI7XG59KCkpO1xuZXhwb3J0cy5HcmFwaFJ1bm5lciA9IEdyYXBoUnVubmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhcGhfcnVubmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHhocl9kYXRhc2V0ID0gcmVxdWlyZShcIi4vZGF0YS94aHItZGF0YXNldFwiKTtcbmV4cG9ydHMueGhyX2RhdGFzZXQgPSB4aHJfZGF0YXNldDtcbnZhciBlbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xuZXhwb3J0cy5lbnZpcm9ubWVudCA9IGVudmlyb25tZW50O1xudmFyIGNvbnZfdXRpbCA9IHJlcXVpcmUoXCIuL21hdGgvY29udl91dGlsXCIpO1xuZXhwb3J0cy5jb252X3V0aWwgPSBjb252X3V0aWw7XG52YXIgZ3BncHVfdXRpbCA9IHJlcXVpcmUoXCIuL21hdGgvd2ViZ2wvZ3BncHVfdXRpbFwiKTtcbmV4cG9ydHMuZ3BncHVfdXRpbCA9IGdwZ3B1X3V0aWw7XG52YXIgcmVuZGVyX25kYXJyYXlfZ3B1X3V0aWwgPSByZXF1aXJlKFwiLi9tYXRoL3dlYmdsL3JlbmRlcl9uZGFycmF5X2dwdV91dGlsXCIpO1xuZXhwb3J0cy5yZW5kZXJfbmRhcnJheV9ncHVfdXRpbCA9IHJlbmRlcl9uZGFycmF5X2dwdV91dGlsO1xudmFyIHdlYmdsX3V0aWwgPSByZXF1aXJlKFwiLi9tYXRoL3dlYmdsL3dlYmdsX3V0aWxcIik7XG5leHBvcnRzLndlYmdsX3V0aWwgPSB3ZWJnbF91dGlsO1xudmFyIHRlc3RfdXRpbCA9IHJlcXVpcmUoXCIuL3Rlc3RfdXRpbFwiKTtcbmV4cG9ydHMudGVzdF91dGlsID0gdGVzdF91dGlsO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZXhwb3J0cy51dGlsID0gdXRpbDtcbnZhciB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbl8xLnZlcnNpb247XG52YXIgY2hlY2twb2ludF9sb2FkZXJfMSA9IHJlcXVpcmUoXCIuL2RhdGEvY2hlY2twb2ludF9sb2FkZXJcIik7XG5leHBvcnRzLkNoZWNrcG9pbnRMb2FkZXIgPSBjaGVja3BvaW50X2xvYWRlcl8xLkNoZWNrcG9pbnRMb2FkZXI7XG52YXIgZGF0YXNldF8xID0gcmVxdWlyZShcIi4vZGF0YS9kYXRhc2V0XCIpO1xuZXhwb3J0cy5Jbk1lbW9yeURhdGFzZXQgPSBkYXRhc2V0XzEuSW5NZW1vcnlEYXRhc2V0O1xudmFyIGlucHV0X3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9kYXRhL2lucHV0X3Byb3ZpZGVyXCIpO1xuZXhwb3J0cy5JbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSBpbnB1dF9wcm92aWRlcl8xLkluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbmV4cG9ydHMuSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gaW5wdXRfcHJvdmlkZXJfMS5JbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG52YXIgeGhyX2RhdGFzZXRfMSA9IHJlcXVpcmUoXCIuL2RhdGEveGhyLWRhdGFzZXRcIik7XG5leHBvcnRzLlhockRhdGFzZXQgPSB4aHJfZGF0YXNldF8xLlhockRhdGFzZXQ7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xuZXhwb3J0cy5FTlYgPSBlbnZpcm9ubWVudF8xLkVOVjtcbmV4cG9ydHMuRW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudF8xLkVudmlyb25tZW50O1xudmFyIGdyYXBoXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9ncmFwaFwiKTtcbmV4cG9ydHMuR3JhcGggPSBncmFwaF8xLkdyYXBoO1xuZXhwb3J0cy5UZW5zb3IgPSBncmFwaF8xLlRlbnNvcjtcbnZhciBhZGFkZWx0YV9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL29wdGltaXplcnMvYWRhZGVsdGFfb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5BZGFkZWx0YU9wdGltaXplciA9IGFkYWRlbHRhX29wdGltaXplcl8xLkFkYWRlbHRhT3B0aW1pemVyO1xudmFyIGFkYWdyYWRfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9vcHRpbWl6ZXJzL2FkYWdyYWRfb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5BZGFncmFkT3B0aW1pemVyID0gYWRhZ3JhZF9vcHRpbWl6ZXJfMS5BZGFncmFkT3B0aW1pemVyO1xudmFyIGFkYW1fb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9vcHRpbWl6ZXJzL2FkYW1fb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5BZGFtT3B0aW1pemVyID0gYWRhbV9vcHRpbWl6ZXJfMS5BZGFtT3B0aW1pemVyO1xudmFyIGFkYW1heF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL29wdGltaXplcnMvYWRhbWF4X29wdGltaXplclwiKTtcbmV4cG9ydHMuQWRhbWF4T3B0aW1pemVyID0gYWRhbWF4X29wdGltaXplcl8xLkFkYW1heE9wdGltaXplcjtcbnZhciBtb21lbnR1bV9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL29wdGltaXplcnMvbW9tZW50dW1fb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5Nb21lbnR1bU9wdGltaXplciA9IG1vbWVudHVtX29wdGltaXplcl8xLk1vbWVudHVtT3B0aW1pemVyO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvb3B0aW1pemVycy9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLk9wdGltaXplciA9IG9wdGltaXplcl8xLk9wdGltaXplcjtcbnZhciBybXNwcm9wX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvb3B0aW1pemVycy9ybXNwcm9wX29wdGltaXplclwiKTtcbmV4cG9ydHMuUk1TUHJvcE9wdGltaXplciA9IHJtc3Byb3Bfb3B0aW1pemVyXzEuUk1TUHJvcE9wdGltaXplcjtcbnZhciBzZ2Rfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9vcHRpbWl6ZXJzL3NnZF9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLlNHRE9wdGltaXplciA9IHNnZF9vcHRpbWl6ZXJfMS5TR0RPcHRpbWl6ZXI7XG52YXIgc2Vzc2lvbl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvc2Vzc2lvblwiKTtcbmV4cG9ydHMuQ29zdFJlZHVjdGlvbiA9IHNlc3Npb25fMS5Db3N0UmVkdWN0aW9uO1xuZXhwb3J0cy5TZXNzaW9uID0gc2Vzc2lvbl8xLlNlc3Npb247XG52YXIgZ3JhcGhfcnVubmVyXzEgPSByZXF1aXJlKFwiLi9ncmFwaF9ydW5uZXJcIik7XG5leHBvcnRzLkdyYXBoUnVubmVyID0gZ3JhcGhfcnVubmVyXzEuR3JhcGhSdW5uZXI7XG5leHBvcnRzLk1ldHJpY1JlZHVjdGlvbiA9IGdyYXBoX3J1bm5lcl8xLk1ldHJpY1JlZHVjdGlvbjtcbnZhciBpbml0aWFsaXplcnNfMSA9IHJlcXVpcmUoXCIuL2luaXRpYWxpemVyc1wiKTtcbmV4cG9ydHMuQ29uc3RhbnRJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLkNvbnN0YW50SW5pdGlhbGl6ZXI7XG5leHBvcnRzLk5EQXJyYXlJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLk5EQXJyYXlJbml0aWFsaXplcjtcbmV4cG9ydHMuT25lc0luaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuT25lc0luaXRpYWxpemVyO1xuZXhwb3J0cy5SYW5kb21Ob3JtYWxJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLlJhbmRvbU5vcm1hbEluaXRpYWxpemVyO1xuZXhwb3J0cy5SYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLlJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyO1xuZXhwb3J0cy5SYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5SYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXI7XG5leHBvcnRzLlZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXI7XG5leHBvcnRzLlplcm9zSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5aZXJvc0luaXRpYWxpemVyO1xudmFyIG1hdGhfMSA9IHJlcXVpcmUoXCIuL21hdGgvbWF0aFwiKTtcbmV4cG9ydHMuTWF0cml4T3JpZW50YXRpb24gPSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb247XG5leHBvcnRzLk5EQXJyYXlNYXRoID0gbWF0aF8xLk5EQXJyYXlNYXRoO1xudmFyIG1hdGhfY3B1XzEgPSByZXF1aXJlKFwiLi9tYXRoL21hdGhfY3B1XCIpO1xuZXhwb3J0cy5OREFycmF5TWF0aENQVSA9IG1hdGhfY3B1XzEuTkRBcnJheU1hdGhDUFU7XG52YXIgbWF0aF9ncHVfMSA9IHJlcXVpcmUoXCIuL21hdGgvbWF0aF9ncHVcIik7XG5leHBvcnRzLk5EQXJyYXlNYXRoR1BVID0gbWF0aF9ncHVfMS5OREFycmF5TWF0aEdQVTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9tYXRoL25kYXJyYXlcIik7XG5leHBvcnRzLmluaXRpYWxpemVHUFUgPSBuZGFycmF5XzEuaW5pdGlhbGl6ZUdQVTtcbnZhciBuZGFycmF5XzIgPSByZXF1aXJlKFwiLi9tYXRoL25kYXJyYXlcIik7XG5leHBvcnRzLkFycmF5MUQgPSBuZGFycmF5XzIuQXJyYXkxRDtcbmV4cG9ydHMuQXJyYXkyRCA9IG5kYXJyYXlfMi5BcnJheTJEO1xuZXhwb3J0cy5BcnJheTNEID0gbmRhcnJheV8yLkFycmF5M0Q7XG5leHBvcnRzLkFycmF5NEQgPSBuZGFycmF5XzIuQXJyYXk0RDtcbmV4cG9ydHMuTkRBcnJheSA9IG5kYXJyYXlfMi5OREFycmF5O1xuZXhwb3J0cy5TY2FsYXIgPSBuZGFycmF5XzIuU2NhbGFyO1xudmFyIGdwZ3B1X2NvbnRleHRfMSA9IHJlcXVpcmUoXCIuL21hdGgvd2ViZ2wvZ3BncHVfY29udGV4dFwiKTtcbmV4cG9ydHMuR1BHUFVDb250ZXh0ID0gZ3BncHVfY29udGV4dF8xLkdQR1BVQ29udGV4dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuL21hdGgvbmRhcnJheVwiKTtcbnZhciBWYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXIoc2NhbGUsIG1vZGUsIGRpc3RyaWJ1dGlvbikge1xuICAgICAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkgeyBzY2FsZSA9IDEuMDsgfVxuICAgICAgICBpZiAobW9kZSA9PT0gdm9pZCAwKSB7IG1vZGUgPSAnZmFuX2luJzsgfVxuICAgICAgICBpZiAoZGlzdHJpYnV0aW9uID09PSB2b2lkIDApIHsgZGlzdHJpYnV0aW9uID0gJ25vcm1hbCc7IH1cbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbiA9IGRpc3RyaWJ1dGlvbjtcbiAgICB9XG4gICAgVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdmYW5faW4nKSB7XG4gICAgICAgICAgICBuID0gaW5wdXRVbml0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1vZGUgPT09ICdmYW5fb3V0Jykge1xuICAgICAgICAgICAgbiA9IG91dHB1dFVuaXRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2Zhbl9hdmcnKSB7XG4gICAgICAgICAgICBuID0gKGlucHV0VW5pdHMgKyBvdXRwdXRVbml0cykgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtb2RlIGZvciB2YXJpYW5jZSBzY2FsaW5nIGluaXRpYWxpemVyOiBcIiArIHRoaXMubW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlzdHJpYnV0aW9uID09PSAnbm9ybWFsJykge1xuICAgICAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5LnJhbmRUcnVuY2F0ZWROb3JtYWwod2VpZ2h0c1NoYXBlLCAwLjAsIE1hdGguc3FydCh0aGlzLnNjYWxlIC8gbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlzdHJpYnV0aW9uID09PSAndW5pZm9ybScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5yYW5kVW5pZm9ybSh3ZWlnaHRzU2hhcGUsIDAuMCwgTWF0aC5zcXJ0KDMgKiB0aGlzLnNjYWxlIC8gbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBkaXN0cmlidXRpb24gZm9yIHZhcmlhbmNlIHNjYWxpbmcgaW5pdGlhbGl6ZXI6IFwiICtcbiAgICAgICAgICAgICAgICAoXCJcIiArIHRoaXMuZGlzdHJpYnV0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBWYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLlZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyID0gVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXI7XG52YXIgWmVyb3NJbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWmVyb3NJbml0aWFsaXplcigpIHtcbiAgICB9XG4gICAgWmVyb3NJbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyh3ZWlnaHRzU2hhcGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFplcm9zSW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5aZXJvc0luaXRpYWxpemVyID0gWmVyb3NJbml0aWFsaXplcjtcbnZhciBPbmVzSW5pdGlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9uZXNJbml0aWFsaXplcigpIHtcbiAgICB9XG4gICAgT25lc0luaXRpYWxpemVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSwgaW5wdXRVbml0cywgb3V0cHV0VW5pdHMpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKHdlaWdodHNTaGFwZSk7XG4gICAgICAgIHZhbHVlcy5maWxsKDEpO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgcmV0dXJuIE9uZXNJbml0aWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLk9uZXNJbml0aWFsaXplciA9IE9uZXNJbml0aWFsaXplcjtcbnZhciBDb25zdGFudEluaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25zdGFudEluaXRpYWxpemVyKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gMDsgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIENvbnN0YW50SW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mod2VpZ2h0c1NoYXBlKTtcbiAgICAgICAgdmFsdWVzLmZpbGwodGhpcy52YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uc3RhbnRJbml0aWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLkNvbnN0YW50SW5pdGlhbGl6ZXIgPSBDb25zdGFudEluaXRpYWxpemVyO1xudmFyIE5EQXJyYXlJbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTkRBcnJheUluaXRpYWxpemVyKG5kYXJyYXkpIHtcbiAgICAgICAgdGhpcy5uZGFycmF5ID0gbmRhcnJheTtcbiAgICB9XG4gICAgTkRBcnJheUluaXRpYWxpemVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSwgaW5wdXRVbml0cywgb3V0cHV0VW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmRhcnJheTtcbiAgICB9O1xuICAgIHJldHVybiBOREFycmF5SW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5OREFycmF5SW5pdGlhbGl6ZXIgPSBOREFycmF5SW5pdGlhbGl6ZXI7XG52YXIgUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJhbmRvbU5vcm1hbEluaXRpYWxpemVyKG1lYW4sIHN0ZGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZGV2ID09PSB2b2lkIDApIHsgc3RkZXYgPSAuMDU7IH1cbiAgICAgICAgdGhpcy5tZWFuID0gbWVhbjtcbiAgICAgICAgdGhpcy5zdGRldiA9IHN0ZGV2O1xuICAgIH1cbiAgICBSYW5kb21Ob3JtYWxJbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5yYW5kTm9ybWFsKHdlaWdodHNTaGFwZSwgdGhpcy5tZWFuLCB0aGlzLnN0ZGV2KTtcbiAgICB9O1xuICAgIHJldHVybiBSYW5kb21Ob3JtYWxJbml0aWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLlJhbmRvbU5vcm1hbEluaXRpYWxpemVyID0gUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXI7XG52YXIgUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyKG1lYW4sIHN0ZGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZGV2ID09PSB2b2lkIDApIHsgc3RkZXYgPSAuMDU7IH1cbiAgICAgICAgdGhpcy5tZWFuID0gbWVhbjtcbiAgICAgICAgdGhpcy5zdGRldiA9IHN0ZGV2O1xuICAgIH1cbiAgICBSYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5yYW5kVHJ1bmNhdGVkTm9ybWFsKHdlaWdodHNTaGFwZSwgdGhpcy5tZWFuLCB0aGlzLnN0ZGV2KTtcbiAgICB9O1xuICAgIHJldHVybiBSYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLlJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyID0gUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXI7XG52YXIgUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXIobWludmFsLCBtYXh2YWwpIHtcbiAgICAgICAgaWYgKG1pbnZhbCA9PT0gdm9pZCAwKSB7IG1pbnZhbCA9IC0uMDU7IH1cbiAgICAgICAgaWYgKG1heHZhbCA9PT0gdm9pZCAwKSB7IG1heHZhbCA9IC4wNTsgfVxuICAgICAgICB0aGlzLm1pbnZhbCA9IG1pbnZhbDtcbiAgICAgICAgdGhpcy5tYXh2YWwgPSBtYXh2YWw7XG4gICAgfVxuICAgIFJhbmRvbVVuaWZvcm1Jbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5yYW5kVW5pZm9ybSh3ZWlnaHRzU2hhcGUsIHRoaXMubWludmFsLCB0aGlzLm1heHZhbCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyID0gUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdGlhbGl6ZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuL25kYXJyYXlcIik7XG52YXIgVGFuSEZ1bmMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhbkhGdW5jKCkge1xuICAgIH1cbiAgICBUYW5IRnVuYy5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24gKG1hdGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGgudGFuaCh4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUYW5IRnVuYy5wcm90b3R5cGUuZGVyID0gZnVuY3Rpb24gKG1hdGgsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHlTcXVhcmVkID0gbWF0aC5lbGVtZW50V2lzZU11bCh5LCB5KTtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLnNjYWxhck1pbnVzQXJyYXkobmRhcnJheV8xLlNjYWxhci5PTkUsIHlTcXVhcmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUYW5IRnVuYy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gVGFuSEZ1bmM7XG59KCkpO1xuZXhwb3J0cy5UYW5IRnVuYyA9IFRhbkhGdW5jO1xudmFyIFJlTFVGdW5jID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZUxVRnVuYygpIHtcbiAgICB9XG4gICAgUmVMVUZ1bmMucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uIChtYXRoLCB4KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLnJlbHUoeCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVMVUZ1bmMucHJvdG90eXBlLmRlciA9IGZ1bmN0aW9uIChtYXRoLCB4LCB5KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLnN0ZXAoeCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVMVUZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIFJlTFVGdW5jO1xufSgpKTtcbmV4cG9ydHMuUmVMVUZ1bmMgPSBSZUxVRnVuYztcbnZhciBMZWFreVJlbHVGdW5jID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZWFreVJlbHVGdW5jKGFscGhhKSB7XG4gICAgICAgIHRoaXMuYWxwaGEgPSBhbHBoYTtcbiAgICB9XG4gICAgTGVha3lSZWx1RnVuYy5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24gKG1hdGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIG1hdGgubGVha3lSZWx1KHgsIHRoaXMuYWxwaGEpO1xuICAgIH07XG4gICAgTGVha3lSZWx1RnVuYy5wcm90b3R5cGUuZGVyID0gZnVuY3Rpb24gKG1hdGgsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguc3RlcCh4LCB0aGlzLmFscGhhKTtcbiAgICB9O1xuICAgIExlYWt5UmVsdUZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIExlYWt5UmVsdUZ1bmM7XG59KCkpO1xuZXhwb3J0cy5MZWFreVJlbHVGdW5jID0gTGVha3lSZWx1RnVuYztcbnZhciBTaWdtb2lkRnVuYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2lnbW9pZEZ1bmMoKSB7XG4gICAgfVxuICAgIFNpZ21vaWRGdW5jLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbiAobWF0aCwgeCkge1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5zaWdtb2lkKHgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNpZ21vaWRGdW5jLnByb3RvdHlwZS5kZXIgPSBmdW5jdGlvbiAobWF0aCwgeCwgeSkge1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeVNxdWFyZWQgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHksIHkpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGguc3ViU3RyaWN0KHksIHlTcXVhcmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTaWdtb2lkRnVuYy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gU2lnbW9pZEZ1bmM7XG59KCkpO1xuZXhwb3J0cy5TaWdtb2lkRnVuYyA9IFNpZ21vaWRGdW5jO1xudmFyIFNxdWFyZUZ1bmMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNxdWFyZUZ1bmMoKSB7XG4gICAgfVxuICAgIFNxdWFyZUZ1bmMucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uIChtYXRoLCB4KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLmVsZW1lbnRXaXNlTXVsKHgsIHgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNxdWFyZUZ1bmMucHJvdG90eXBlLmRlciA9IGZ1bmN0aW9uIChtYXRoLCB4LCB5KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLnNjYWxhclRpbWVzQXJyYXkobmRhcnJheV8xLlNjYWxhci5UV08sIHgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNxdWFyZUZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIFNxdWFyZUZ1bmM7XG59KCkpO1xuZXhwb3J0cy5TcXVhcmVGdW5jID0gU3F1YXJlRnVuYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGl2YXRpb25fZnVuY3Rpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gYXhlc0FyZUlubmVyTW9zdERpbXMoYXhlcywgcmFuaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYXhlc1theGVzLmxlbmd0aCAtIGkgLSAxXSAhPT0gcmFuayAtIDEgLSBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmF4ZXNBcmVJbm5lck1vc3REaW1zID0gYXhlc0FyZUlubmVyTW9zdERpbXM7XG5mdW5jdGlvbiBjb21iaW5lTG9jYXRpb25zKG91dHB1dExvYywgcmVkdWNlTG9jLCBheGVzKSB7XG4gICAgdmFyIHJhbmsgPSBvdXRwdXRMb2MubGVuZ3RoICsgcmVkdWNlTG9jLmxlbmd0aDtcbiAgICB2YXIgbG9jID0gW107XG4gICAgdmFyIG91dElkeCA9IDA7XG4gICAgdmFyIHJlZHVjZUlkeCA9IDA7XG4gICAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgcmFuazsgZGltKyspIHtcbiAgICAgICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xuICAgICAgICAgICAgbG9jLnB1c2gob3V0cHV0TG9jW291dElkeCsrXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2MucHVzaChyZWR1Y2VMb2NbcmVkdWNlSWR4KytdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9jO1xufVxuZXhwb3J0cy5jb21iaW5lTG9jYXRpb25zID0gY29tYmluZUxvY2F0aW9ucztcbmZ1bmN0aW9uIGNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoYVNoYXBlLCBheGVzKSB7XG4gICAgdmFyIG91dFNoYXBlID0gW107XG4gICAgdmFyIHJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICAgIGZvciAodmFyIGRpbSA9IDA7IGRpbSA8IHJhbms7IGRpbSsrKSB7XG4gICAgICAgIGlmIChheGVzLmluZGV4T2YoZGltKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG91dFNoYXBlLnB1c2goYVNoYXBlW2RpbV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciByZWR1Y2VTaGFwZSA9IGF4ZXMubWFwKGZ1bmN0aW9uIChkaW0pIHsgcmV0dXJuIGFTaGFwZVtkaW1dOyB9KTtcbiAgICByZXR1cm4gW291dFNoYXBlLCByZWR1Y2VTaGFwZV07XG59XG5leHBvcnRzLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMgPSBjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzO1xuZnVuY3Rpb24gZXhwYW5kU2hhcGVUb0tlZXBEaW0oc2hhcGUsIGF4ZXMpIHtcbiAgICB2YXIgcmVkdWNlU3ViU2hhcGUgPSBheGVzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gMTsgfSk7XG4gICAgcmV0dXJuIGNvbWJpbmVMb2NhdGlvbnMoc2hhcGUsIHJlZHVjZVN1YlNoYXBlLCBheGVzKTtcbn1cbmV4cG9ydHMuZXhwYW5kU2hhcGVUb0tlZXBEaW0gPSBleHBhbmRTaGFwZVRvS2VlcERpbTtcbmZ1bmN0aW9uIHBhcnNlQXhpc1BhcmFtKGF4aXMsIHNoYXBlKSB7XG4gICAgaWYgKGF4aXMgPT0gbnVsbCkge1xuICAgICAgICBheGlzID0gc2hhcGUubWFwKGZ1bmN0aW9uIChzLCBpKSB7IHJldHVybiBpOyB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChheGlzKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYXhpcyA9IFtheGlzXTtcbiAgICB9XG4gICAgcmV0dXJuIGF4aXM7XG59XG5leHBvcnRzLnBhcnNlQXhpc1BhcmFtID0gcGFyc2VBeGlzUGFyYW07XG5mdW5jdGlvbiBhc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhtc2csIGF4ZXMsIHJhbmspIHtcbiAgICBpZiAoIWF4ZXNBcmVJbm5lck1vc3REaW1zKGF4ZXMsIHJhbmspKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cgKyBcIiBzdXBwb3J0cyBvbmx5IGlubmVyLW1vc3QgYXhlcyBmb3Igbm93LiBcIiArXG4gICAgICAgICAgICAoXCJHb3QgYXhlcyBcIiArIGF4ZXMgKyBcIiBhbmQgcmFuay1cIiArIHJhbmsgKyBcIiBpbnB1dC5cIikpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMgPSBhc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcztcbmZ1bmN0aW9uIGdldFBlcm11dGVkQXhlcyhheGVzLCByYW5rKSB7XG4gICAgaWYgKGF4ZXNBcmVJbm5lck1vc3REaW1zKGF4ZXMsIHJhbmspKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICAgICAgaWYgKGF4ZXMuaW5kZXhPZihpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXhpcykgeyByZXR1cm4gcmVzdWx0LnB1c2goYXhpcyk7IH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmdldFBlcm11dGVkQXhlcyA9IGdldFBlcm11dGVkQXhlcztcbmZ1bmN0aW9uIGdldElubmVyTW9zdEF4ZXMobnVtQXhlcywgcmFuaykge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gcmFuayAtIG51bUF4ZXM7IGkgPCByYW5rOyArK2kpIHtcbiAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmdldElubmVyTW9zdEF4ZXMgPSBnZXRJbm5lck1vc3RBeGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXhpc191dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZ2V0QnJvYWRjYXN0RGltcyhpblNoYXBlLCBvdXRTaGFwZSkge1xuICAgIHZhciBpblJhbmsgPSBpblNoYXBlLmxlbmd0aDtcbiAgICB2YXIgZGltcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5SYW5rOyBpKyspIHtcbiAgICAgICAgdmFyIGRpbSA9IGluUmFuayAtIDEgLSBpO1xuICAgICAgICB2YXIgYSA9IGluU2hhcGVbZGltXSB8fCAxO1xuICAgICAgICB2YXIgYiA9IG91dFNoYXBlW291dFNoYXBlLmxlbmd0aCAtIDEgLSBpXSB8fCAxO1xuICAgICAgICBpZiAoYiA+IDEgJiYgYSA9PT0gMSkge1xuICAgICAgICAgICAgZGltcy51bnNoaWZ0KGRpbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpbXM7XG59XG5leHBvcnRzLmdldEJyb2FkY2FzdERpbXMgPSBnZXRCcm9hZGNhc3REaW1zO1xuZnVuY3Rpb24gYnJvYWRjYXN0RGltc0FyZU91dGVyKGRpbXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRpbXNbaV0gIT09IGkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuYnJvYWRjYXN0RGltc0FyZU91dGVyID0gYnJvYWRjYXN0RGltc0FyZU91dGVyO1xuZnVuY3Rpb24gYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoc2hhcGVBLCBzaGFwZUIpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGVyck1zZyA9IFwiT3BlcmFuZHMgY291bGQgbm90IGJlIGJyb2FkY2FzdCB0b2dldGhlciB3aXRoIHNoYXBlcyBcIiArXG4gICAgICAgIChzaGFwZUEgKyBcIiBhbmQgXCIgKyBzaGFwZUIgKyBcIi5cIik7XG4gICAgdmFyIGwgPSBNYXRoLm1heChzaGFwZUEubGVuZ3RoLCBzaGFwZUIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgYSA9IHNoYXBlQVtzaGFwZUEubGVuZ3RoIC0gaSAtIDFdIHx8IDE7XG4gICAgICAgIHZhciBiID0gc2hhcGVCW3NoYXBlQi5sZW5ndGggLSBpIC0gMV0gfHwgMTtcbiAgICAgICAgaWYgKGEgPiAxICYmIGIgPiAxICYmIGEgIT09IGIpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGVyck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoTWF0aC5tYXgoYSwgYikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSA9IGFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvYWRjYXN0X3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzZXJ0UGFyYW1zKGFTaGFwZSwgYlNoYXBlLCBheGlzKSB7XG4gICAgdmFyIGFSYW5rID0gYVNoYXBlLmxlbmd0aDtcbiAgICB2YXIgYlJhbmsgPSBiU2hhcGUubGVuZ3RoO1xuICAgIHV0aWwuYXNzZXJ0KGFTaGFwZS5sZW5ndGggPT09IGJTaGFwZS5sZW5ndGgsIFwiRXJyb3IgaW4gY29uY2F0XCIgKyBhUmFuayArIFwiRDogcmFuayBvZiB4MSAoXCIgKyBhUmFuayArIFwiKSBhbmQgeDIgKFwiICsgYlJhbmsgKyBcIikgXCIgK1xuICAgICAgICBcIm11c3QgYmUgdGhlIHNhbWUuXCIpO1xuICAgIHV0aWwuYXNzZXJ0KGF4aXMgPj0gMCAmJiBheGlzIDwgYVJhbmssIFwiRXJyb3IgaW4gY29uY2F0XCIgKyBhUmFuayArIFwiRDogYXhpcyBtdXN0IGJlIFwiICtcbiAgICAgICAgKFwiYmV0d2VlbiAwIGFuZCBcIiArIChhUmFuayAtIDEpICsgXCIuXCIpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFSYW5rOyBpKyspIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoKGkgPT09IGF4aXMpIHx8IChhU2hhcGVbaV0gPT09IGJTaGFwZVtpXSksIFwiRXJyb3IgaW4gY29uY2F0XCIgKyBhUmFuayArIFwiRDogU2hhcGUgKFwiICsgYVNoYXBlICsgXCIpIGRvZXMgbm90IG1hdGNoIFwiICtcbiAgICAgICAgICAgIChcIihcIiArIGJTaGFwZSArIFwiKSBhbG9uZyB0aGUgbm9uLWNvbmNhdGVuYXRlZCBheGlzIFwiICsgaSArIFwiLlwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRQYXJhbXMgPSBhc3NlcnRQYXJhbXM7XG5mdW5jdGlvbiBjb21wdXRlT3V0U2hhcGUoeDFTaGFwZSwgeDJTaGFwZSwgYXhpcykge1xuICAgIHV0aWwuYXNzZXJ0KHgxU2hhcGUubGVuZ3RoID09PSB4MlNoYXBlLmxlbmd0aCwgJ3gxIGFuZCB4MiBzaG91bGQgaGF2ZSB0aGUgc2FtZSByYW5rLicpO1xuICAgIHZhciBvdXRwdXRTaGFwZSA9IHgxU2hhcGUuc2xpY2UoKTtcbiAgICBvdXRwdXRTaGFwZVtheGlzXSArPSB4MlNoYXBlW2F4aXNdO1xuICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbn1cbmV4cG9ydHMuY29tcHV0ZU91dFNoYXBlID0gY29tcHV0ZU91dFNoYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0X3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gY29tcHV0ZURlcHRod2lzZUNvbnYyREluZm8oaW5TaGFwZSwgZmlsdGVyU2hhcGUsIHN0cmlkZXMsIHBhZCkge1xuICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBmaWx0ZXJTaGFwZVswXSwgZmlsdGVyV2lkdGggPSBmaWx0ZXJTaGFwZVsxXSwgaW5DaGFubmVscyA9IGZpbHRlclNoYXBlWzJdLCBjaGFubmVsTXVsID0gZmlsdGVyU2hhcGVbM107XG4gICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKHN0cmlkZXMpLCBzdHJpZGVIZWlnaHQgPSBfYVswXSwgc3RyaWRlV2lkdGggPSBfYVsxXTtcbiAgICB2YXIgaW5IZWlnaHQgPSBpblNoYXBlWzFdO1xuICAgIHZhciBpbldpZHRoID0gaW5TaGFwZVsyXTtcbiAgICB2YXIgYmF0Y2hTaXplID0gaW5TaGFwZVswXTtcbiAgICB2YXIgX2IgPSBnZXRQYWRBbmRPdXRJbmZvKHBhZCwgaW5IZWlnaHQsIGluV2lkdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgpLCBwYWRJbmZvID0gX2IucGFkSW5mbywgb3V0SGVpZ2h0ID0gX2Iub3V0SGVpZ2h0LCBvdXRXaWR0aCA9IF9iLm91dFdpZHRoO1xuICAgIHZhciBvdXRDaGFubmVscyA9IGluQ2hhbm5lbHMgKiBjaGFubmVsTXVsO1xuICAgIHZhciBvdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dEhlaWdodCwgb3V0V2lkdGgsIG91dENoYW5uZWxzXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpblNoYXBlOiBpblNoYXBlLFxuICAgICAgICBvdXRTaGFwZTogb3V0U2hhcGUsXG4gICAgICAgIGNoYW5uZWxNdWw6IGNoYW5uZWxNdWwsXG4gICAgICAgIHN0cmlkZUhlaWdodDogc3RyaWRlSGVpZ2h0LFxuICAgICAgICBzdHJpZGVXaWR0aDogc3RyaWRlV2lkdGgsXG4gICAgICAgIGZpbHRlckhlaWdodDogZmlsdGVySGVpZ2h0LFxuICAgICAgICBmaWx0ZXJXaWR0aDogZmlsdGVyV2lkdGgsXG4gICAgICAgIHBhZEluZm86IHBhZEluZm9cbiAgICB9O1xufVxuZXhwb3J0cy5jb21wdXRlRGVwdGh3aXNlQ29udjJESW5mbyA9IGNvbXB1dGVEZXB0aHdpc2VDb252MkRJbmZvO1xuZnVuY3Rpb24gY29tcHV0ZUNvbnYyREluZm8oaW5TaGFwZSwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgb3V0RGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIHBhZCkge1xuICAgIHZhciBpbkhlaWdodCA9IGluU2hhcGVbMF07XG4gICAgdmFyIGluV2lkdGggPSBpblNoYXBlWzFdO1xuICAgIHZhciBfYSA9IGdldFBhZEFuZE91dEluZm8ocGFkLCBpbkhlaWdodCwgaW5XaWR0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCksIHBhZEluZm8gPSBfYS5wYWRJbmZvLCBvdXRIZWlnaHQgPSBfYS5vdXRIZWlnaHQsIG91dFdpZHRoID0gX2Eub3V0V2lkdGg7XG4gICAgdmFyIG91dFNoYXBlID0gW291dEhlaWdodCwgb3V0V2lkdGgsIG91dERlcHRoXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpblNoYXBlOiBpblNoYXBlLFxuICAgICAgICBvdXRTaGFwZTogb3V0U2hhcGUsXG4gICAgICAgIHBhZEluZm86IHBhZEluZm8sXG4gICAgICAgIHN0cmlkZUhlaWdodDogc3RyaWRlSGVpZ2h0LFxuICAgICAgICBzdHJpZGVXaWR0aDogc3RyaWRlV2lkdGgsXG4gICAgICAgIGZpbHRlckhlaWdodDogZmlsdGVySGVpZ2h0LFxuICAgICAgICBmaWx0ZXJXaWR0aDogZmlsdGVyV2lkdGhcbiAgICB9O1xufVxuZXhwb3J0cy5jb21wdXRlQ29udjJESW5mbyA9IGNvbXB1dGVDb252MkRJbmZvO1xuZnVuY3Rpb24gY29tcHV0ZU91dHB1dFNoYXBlM0QoaW5TaGFwZSwgZmllbGRTaXplLCBvdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKSB7XG4gICAgaWYgKHplcm9QYWQgPT0gbnVsbCkge1xuICAgICAgICB6ZXJvUGFkID0gY29tcHV0ZURlZmF1bHRQYWQoaW5TaGFwZSwgZmllbGRTaXplLCBzdHJpZGUpO1xuICAgIH1cbiAgICB2YXIgaW5wdXRSb3dzID0gaW5TaGFwZVswXTtcbiAgICB2YXIgaW5wdXRDb2xzID0gaW5TaGFwZVsxXTtcbiAgICB2YXIgb3V0cHV0Um93cyA9IChpbnB1dFJvd3MgLSBmaWVsZFNpemUgKyAyICogemVyb1BhZCkgLyBzdHJpZGUgKyAxO1xuICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQob3V0cHV0Um93cyksIFwiVGhlIG91dHB1dCAjIG9mIHJvd3MgKFwiICsgb3V0cHV0Um93cyArIFwiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgXCIgK1xuICAgICAgICBcInN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wiKTtcbiAgICB2YXIgb3V0cHV0Q29scyA9IChpbnB1dENvbHMgLSBmaWVsZFNpemUgKyAyICogemVyb1BhZCkgLyBzdHJpZGUgKyAxO1xuICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQob3V0cHV0Q29scyksIFwiVGhlIG91dHB1dCAjIG9mIGNvbHVtbnMgKFwiICsgb3V0cHV0Q29scyArIFwiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSBcIiArXG4gICAgICAgIFwidGhlIHN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wiKTtcbiAgICByZXR1cm4gW291dHB1dFJvd3MsIG91dHB1dENvbHMsIG91dERlcHRoXTtcbn1cbmV4cG9ydHMuY29tcHV0ZU91dHB1dFNoYXBlM0QgPSBjb21wdXRlT3V0cHV0U2hhcGUzRDtcbmZ1bmN0aW9uIGNvbXB1dGVEZWZhdWx0UGFkKGlucHV0U2hhcGUsIGZpZWxkU2l6ZSwgc3RyaWRlKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKGlucHV0U2hhcGVbMF0gKiAoc3RyaWRlIC0gMSkgLSBzdHJpZGUgKyBmaWVsZFNpemUpIC8gMik7XG59XG5leHBvcnRzLmNvbXB1dGVEZWZhdWx0UGFkID0gY29tcHV0ZURlZmF1bHRQYWQ7XG5mdW5jdGlvbiBjb21wdXRlV2VpZ2h0c1NoYXBlNEQoaW5wdXREZXB0aCwgb3V0cHV0RGVwdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgpIHtcbiAgICByZXR1cm4gW2ZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIGlucHV0RGVwdGgsIG91dHB1dERlcHRoXTtcbn1cbmV4cG9ydHMuY29tcHV0ZVdlaWdodHNTaGFwZTREID0gY29tcHV0ZVdlaWdodHNTaGFwZTREO1xuZnVuY3Rpb24gY29tcHV0ZURpbGF0ZWRSQyhyYywgb3JpZ1N0cmlkZSkge1xuICAgIHZhciByb3dzRGlsYXRlZCA9IChyY1swXSAtIDEpICogb3JpZ1N0cmlkZSArIDE7XG4gICAgdmFyIGNvbHNEaWxhdGVkID0gKHJjWzFdIC0gMSkgKiBvcmlnU3RyaWRlICsgMTtcbiAgICByZXR1cm4gW3Jvd3NEaWxhdGVkLCBjb2xzRGlsYXRlZF07XG59XG5leHBvcnRzLmNvbXB1dGVEaWxhdGVkUkMgPSBjb21wdXRlRGlsYXRlZFJDO1xuZnVuY3Rpb24gcGFyc2VUdXBsZVBhcmFtKHBhcmFtKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicgPyBbcGFyYW0sIHBhcmFtXSA6IHBhcmFtO1xufVxuZnVuY3Rpb24gZ2V0UGFkQW5kT3V0SW5mbyhwYWQsIGluSGVpZ2h0LCBpbldpZHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoKSB7XG4gICAgdmFyIHBhZEluZm87XG4gICAgdmFyIG91dEhlaWdodDtcbiAgICB2YXIgb3V0V2lkdGg7XG4gICAgaWYgKHR5cGVvZiBwYWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBhZEluZm8gPSB7IHRvcDogcGFkLCBib3R0b206IHBhZCwgbGVmdDogcGFkLCByaWdodDogcGFkIH07XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGNvbXB1dGVPdXRwdXRTaGFwZTNEKFtpbkhlaWdodCwgaW5XaWR0aCwgMV0sIGZpbHRlckhlaWdodCwgMSwgc3RyaWRlSGVpZ2h0LCBwYWQpO1xuICAgICAgICBvdXRIZWlnaHQgPSBvdXRTaGFwZVswXTtcbiAgICAgICAgb3V0V2lkdGggPSBvdXRTaGFwZVsxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFkID09PSAnc2FtZScpIHtcbiAgICAgICAgb3V0SGVpZ2h0ID0gTWF0aC5jZWlsKGluSGVpZ2h0IC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgb3V0V2lkdGggPSBNYXRoLmNlaWwoaW5XaWR0aCAvIHN0cmlkZVdpZHRoKTtcbiAgICAgICAgdmFyIHBhZEFsb25nSGVpZ2h0ID0gKG91dEhlaWdodCAtIDEpICogc3RyaWRlSGVpZ2h0ICsgZmlsdGVySGVpZ2h0IC0gaW5IZWlnaHQ7XG4gICAgICAgIHZhciBwYWRBbG9uZ1dpZHRoID0gKG91dFdpZHRoIC0gMSkgKiBzdHJpZGVXaWR0aCArIGZpbHRlcldpZHRoIC0gaW5XaWR0aDtcbiAgICAgICAgdmFyIHRvcF8xID0gTWF0aC5mbG9vcihwYWRBbG9uZ0hlaWdodCAvIDIpO1xuICAgICAgICB2YXIgYm90dG9tID0gcGFkQWxvbmdIZWlnaHQgLSB0b3BfMTtcbiAgICAgICAgdmFyIGxlZnQgPSBNYXRoLmZsb29yKHBhZEFsb25nV2lkdGggLyAyKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcGFkQWxvbmdXaWR0aCAtIGxlZnQ7XG4gICAgICAgIHBhZEluZm8gPSB7IHRvcDogdG9wXzEsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0LCByaWdodDogcmlnaHQgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFkID09PSAndmFsaWQnKSB7XG4gICAgICAgIHBhZEluZm8gPSB7IHRvcDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCByaWdodDogMCB9O1xuICAgICAgICBvdXRIZWlnaHQgPSBNYXRoLmNlaWwoKGluSGVpZ2h0IC0gZmlsdGVySGVpZ2h0ICsgMSkgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICBvdXRXaWR0aCA9IE1hdGguY2VpbCgoaW5XaWR0aCAtIGZpbHRlcldpZHRoICsgMSkgLyBzdHJpZGVXaWR0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6IFwiICsgcGFkKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcGFkSW5mbzogcGFkSW5mbywgb3V0SGVpZ2h0OiBvdXRIZWlnaHQsIG91dFdpZHRoOiBvdXRXaWR0aCB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udl91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gdmFsaWRhdGVTaGFwZXMoc291cmNlU2l6ZSwgZGVzdFNpemUpIHtcbiAgICB2YXIgc3JjQXJlYSA9IHNvdXJjZVNpemVbMF0gKiBzb3VyY2VTaXplWzFdO1xuICAgIHZhciBkc3RBcmVhID0gZGVzdFNpemVbMF0gKiBkZXN0U2l6ZVsxXTtcbiAgICBpZiAoc3JjQXJlYSAhPT0gZHN0QXJlYSkge1xuICAgICAgICB2YXIgc3JjU3RyID0gXCJbXCIgKyBzb3VyY2VTaXplWzBdICsgXCIsIFwiICsgc291cmNlU2l6ZVsxXSArIFwiXVwiO1xuICAgICAgICB2YXIgZHN0U3RyID0gXCJbXCIgKyBkZXN0U2l6ZVswXSArIFwiLCBcIiArIGRlc3RTaXplWzFdICsgXCJdXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvcHkyRCBzaGFwZXMgaGF2ZSBkaWZmZXJlbnQgYXJlYXM6XFxuICBzb3VyY2VTaXplIFwiICsgc3JjU3RyICtcbiAgICAgICAgICAgIChcIiwgYXJlYSBcIiArIHNyY0FyZWEgKyBcIlxcbiAgZGVzdFNpemUgXCIgKyBkc3RTdHIgKyBcIiwgYXJlYSBcIiArIGRzdEFyZWEpKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU2hhcGVzID0gdmFsaWRhdGVTaGFwZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3B5MmRfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9uZGFycmF5XCIpO1xudmFyIFNxdWFyZUNvc3RGdW5jID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcXVhcmVDb3N0RnVuYygpIHtcbiAgICAgICAgdGhpcy5oYWxmT25lID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMC41KTtcbiAgICB9XG4gICAgU3F1YXJlQ29zdEZ1bmMucHJvdG90eXBlLmNvc3QgPSBmdW5jdGlvbiAobWF0aCwgeDEsIHgyKSB7XG4gICAgICAgIHZhciBkaWZmID0gbWF0aC5zdWJTdHJpY3QoeDEsIHgyKTtcbiAgICAgICAgdmFyIGRpZmZTcXVhcmVkID0gbWF0aC5lbGVtZW50V2lzZU11bChkaWZmLCBkaWZmKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG1hdGguc2NhbGFyVGltZXNBcnJheSh0aGlzLmhhbGZPbmUsIGRpZmZTcXVhcmVkKTtcbiAgICAgICAgZGlmZi5kaXNwb3NlKCk7XG4gICAgICAgIGRpZmZTcXVhcmVkLmRpc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFNxdWFyZUNvc3RGdW5jLnByb3RvdHlwZS5kZXIgPSBmdW5jdGlvbiAobWF0aCwgeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiBtYXRoLnN1YlN0cmljdCh4MSwgeDIpO1xuICAgIH07XG4gICAgU3F1YXJlQ29zdEZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFsZk9uZS5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3F1YXJlQ29zdEZ1bmM7XG59KCkpO1xuZXhwb3J0cy5TcXVhcmVDb3N0RnVuYyA9IFNxdWFyZUNvc3RGdW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29zdF9mdW5jdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGF4aXNfdXRpbCA9IHJlcXVpcmUoXCIuL2F4aXNfdXRpbFwiKTtcbnZhciBicm9hZGNhc3RfdXRpbCA9IHJlcXVpcmUoXCIuL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4vY29uY2F0X3V0aWxcIik7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4vY29udl91dGlsXCIpO1xudmFyIGNvcHkyZF91dGlsID0gcmVxdWlyZShcIi4vY29weTJkX3V0aWxcIik7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbmRhcnJheVwiKTtcbnZhciBzbGljZV91dGlsID0gcmVxdWlyZShcIi4vc2xpY2VfdXRpbFwiKTtcbnZhciBTdW1UeXBlc01hcDtcbihmdW5jdGlvbiAoU3VtVHlwZXNNYXApIHtcbiAgICBTdW1UeXBlc01hcFtcImZsb2F0MzJcIl0gPSBcImZsb2F0MzJcIjtcbiAgICBTdW1UeXBlc01hcFtcImludDMyXCJdID0gXCJpbnQzMlwiO1xuICAgIFN1bVR5cGVzTWFwW1wiYm9vbFwiXSA9IFwiaW50MzJcIjtcbn0pKFN1bVR5cGVzTWFwID0gZXhwb3J0cy5TdW1UeXBlc01hcCB8fCAoZXhwb3J0cy5TdW1UeXBlc01hcCA9IHt9KSk7XG52YXIgTkRBcnJheU1hdGggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5EQXJyYXlNYXRoKHNhZmVNb2RlKSB7XG4gICAgICAgIHRoaXMuc2FmZU1vZGUgPSBzYWZlTW9kZTtcbiAgICAgICAgdGhpcy5uZGFycmF5U2NvcGVzID0gW107XG4gICAgICAgIHRoaXMubmRhcnJheXNUb0tlZXAgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZU5EQXJyYXlzVG9LZWVwID0gW107XG4gICAgICAgIHRoaXMuZGVidWdNb2RlID0gZmFsc2U7XG4gICAgfVxuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uIChzY29wZUZuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RhcnRTY29wZSgpO1xuICAgICAgICB2YXIga2VlcEZuID0gZnVuY3Rpb24gKG5kYXJyYXkpIHsgcmV0dXJuIF90aGlzLmtlZXAobmRhcnJheSk7IH07XG4gICAgICAgIHZhciB0cmFja0ZuID0gZnVuY3Rpb24gKG5kYXJyYXkpIHsgcmV0dXJuIF90aGlzLnRyYWNrKG5kYXJyYXkpOyB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gc2NvcGVGbihrZWVwRm4sIHRyYWNrRm4pO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHIpIHsgcmV0dXJuIF90aGlzLmVuZFNjb3BlKHIpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVuZFNjb3BlKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZW5hYmxlRGVidWdNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlYnVnTW9kZSA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVidWdnaW5nIG1vZGUgaXMgT04uIFRoZSBvdXRwdXQgb2YgZXZlcnkgbWF0aCBjYWxsIHdpbGwgJyArXG4gICAgICAgICAgICAnYmUgZG93bmxvYWRlZCB0byBDUFUgYW5kIGNoZWNrZWQgZm9yIE5hTnMuICcgK1xuICAgICAgICAgICAgJ1RoaXMgc2lnbmlmaWNhbnRseSBpbXBhY3RzIHBlcmZvcm1hbmNlLicpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnN0YXJ0U2NvcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdTY29wZSA9IFtdO1xuICAgICAgICB0aGlzLm5kYXJyYXlTY29wZXMucHVzaChuZXdTY29wZSk7XG4gICAgICAgIHRoaXMuYWN0aXZlU2NvcGUgPSBuZXdTY29wZTtcbiAgICAgICAgdmFyIG5ld05EQXJyYXlzVG9LZWVwID0gW107XG4gICAgICAgIHRoaXMubmRhcnJheXNUb0tlZXAucHVzaChuZXdOREFycmF5c1RvS2VlcCk7XG4gICAgICAgIHRoaXMuYWN0aXZlU2NvcGVOREFycmF5c1RvS2VlcCA9IG5ld05EQXJyYXlzVG9LZWVwO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmV4dHJhY3ROREFycmF5c0Zyb21TY29wZVJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgdmFyIHJlc3VsdE9iaiA9IHJlc3VsdDtcbiAgICAgICAgZm9yICh2YXIgayBpbiByZXN1bHRPYmopIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSByZXN1bHRPYmpba107XG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5lbmRTY29wZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFycmF5c1RvS2VlcCA9IHRoaXMuYWN0aXZlU2NvcGVOREFycmF5c1RvS2VlcDtcbiAgICAgICAgdmFyIHJlc3VsdEFycmF5cyA9IHRoaXMuZXh0cmFjdE5EQXJyYXlzRnJvbVNjb3BlUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgIGFycmF5c1RvS2VlcCA9IGFycmF5c1RvS2VlcC5jb25jYXQocmVzdWx0QXJyYXlzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZVNjb3BlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmRhcnJheSA9IHRoaXMuYWN0aXZlU2NvcGVbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5pc05EQXJyYXlEYXRhSW5MaXN0KG5kYXJyYXksIGFycmF5c1RvS2VlcCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5kYXJyYXkuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmRhcnJheVNjb3Blcy5wb3AoKTtcbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZSA9IHRoaXMubmRhcnJheVNjb3Blcy5sZW5ndGggPT09IDAgP1xuICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICB0aGlzLm5kYXJyYXlTY29wZXNbdGhpcy5uZGFycmF5U2NvcGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXN1bHRBcnJheXMuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzTkRBcnJheURhdGFJbkxpc3QodmFsLCBfdGhpcy5hY3RpdmVTY29wZU5EQXJyYXlzVG9LZWVwKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnRyYWNrKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5kYXJyYXlzVG9LZWVwLnBvcCgpO1xuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlTkRBcnJheXNUb0tlZXAgPSB0aGlzLm5kYXJyYXlzVG9LZWVwLmxlbmd0aCA9PT0gMCA/XG4gICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgIHRoaXMubmRhcnJheXNUb0tlZXBbdGhpcy5uZGFycmF5c1RvS2VlcC5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5pc05EQXJyYXlEYXRhSW5MaXN0ID0gZnVuY3Rpb24gKG5kYXJyYXksIG5kYXJyYXlMaXN0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmRhcnJheUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZGFycmF5TGlzdFtpXS5nZXREYXRhKCkgPT09IG5kYXJyYXkuZ2V0RGF0YSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmtlZXAgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVNjb3BlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNhZmVNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHVzaW5nIG1hdGggaW4gc2FmZSBtb2RlLiBFbmNsb3NlIGFsbCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ21hdGgubWV0aG9kKCkgY2FsbHMgaW5zaWRlIGEgc2NvcGU6ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbWF0aC5zY29wZSgoKSA9PiB7bWF0aC5tZXRob2QoKTsuLi59KSB0byBhdm9pZCBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZU5EQXJyYXlzVG9LZWVwLnB1c2gocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jaGVja0Zvck5hTiA9IGZ1bmN0aW9uICh2YWxzLCBkdHlwZSwgbmFtZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVmFsTmFOKHZhbHNbaV0sIGR0eXBlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBtYXRoLlwiICsgbmFtZSArIFwiIGhhcyBOYU5zLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnRyYWNrID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVTY29wZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zYWZlTW9kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFyZSB1c2luZyBtYXRoIGluIHNhZmUgbW9kZS4gRW5jbG9zZSBhbGwgJyArXG4gICAgICAgICAgICAgICAgICAgICdtYXRoLm1ldGhvZCgpIGNhbGxzIGluc2lkZSBhIHNjb3BlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ21hdGguc2NvcGUoKCkgPT4ge21hdGgubWV0aG9kKCk7Li4ufSkgdG8gYXZvaWQgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVha3MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlU2NvcGUucHVzaChyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm1hdE11bCA9IGZ1bmN0aW9uIChhLCBiLCBhT3JpZW50YXRpb24sIGJPcmllbnRhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYU9yaWVudGF0aW9uID09PSB2b2lkIDApIHsgYU9yaWVudGF0aW9uID0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUjsgfVxuICAgICAgICBpZiAoYk9yaWVudGF0aW9uID09PSB2b2lkIDApIHsgYk9yaWVudGF0aW9uID0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUjsgfVxuICAgICAgICB2YXIgaW5uZXJTaGFwZUEgPSAoYU9yaWVudGF0aW9uID09PSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGEuc2hhcGVbMV0gOiBhLnNoYXBlWzBdO1xuICAgICAgICB2YXIgaW5uZXJTaGFwZUIgPSAoYk9yaWVudGF0aW9uID09PSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGIuc2hhcGVbMF0gOiBiLnNoYXBlWzFdO1xuICAgICAgICB1dGlsLmFzc2VydChhLnJhbmsgPT09IDIgJiYgYi5yYW5rID09PSAyLCBcIkVycm9yIGluIG1hdE11bDogaW5wdXRzIG11c3QgYmUgcmFuayAyLCBnb3QgcmFua3MgXCIgKyBhLnJhbmsgK1xuICAgICAgICAgICAgKFwiIGFuZCBcIiArIGIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGlubmVyU2hhcGVBID09PSBpbm5lclNoYXBlQiwgXCJFcnJvciBpbiBtYXRNdWw6IGlubmVyIHNoYXBlcyAoXCIgKyBpbm5lclNoYXBlQSArIFwiKSBhbmQgKFwiICtcbiAgICAgICAgICAgIChpbm5lclNoYXBlQiArIFwiKSBvZiBOREFycmF5cyB3aXRoIHNoYXBlcyBcIiArIGEuc2hhcGUgKyBcIiBhbmQgXCIpICtcbiAgICAgICAgICAgIChiLnNoYXBlICsgXCIgYW5kIG9yaWVudGF0aW9ucyBcIiArIE1hdHJpeE9yaWVudGF0aW9uW2FPcmllbnRhdGlvbl0pICtcbiAgICAgICAgICAgIChcIiBhbmQgXCIgKyBNYXRyaXhPcmllbnRhdGlvbltiT3JpZW50YXRpb25dICsgXCIgbXVzdCBtYXRjaC5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ21hdE11bCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm1hdE11bEludGVybmFsKGEsIGIsIGFPcmllbnRhdGlvbiwgYk9yaWVudGF0aW9uKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZXhlY3V0ZU9wID0gZnVuY3Rpb24gKG5hbWUsIGYpIHtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGYoKTtcbiAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhciB0aW1lID0gdXRpbC5yaWdodFBhZChwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0ICsgXCJtc1wiLCA5KTtcbiAgICAgICAgICAgIHZhciBwYWRkZWROYW1lID0gdXRpbC5yaWdodFBhZChuYW1lLCAyNSk7XG4gICAgICAgICAgICB2YXIgcmFuayA9IHJlc3VsdC5yYW5rO1xuICAgICAgICAgICAgdmFyIHNpemUgPSByZXN1bHQuc2l6ZTtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHV0aWwucmlnaHRQYWQocmVzdWx0LnNoYXBlLnRvU3RyaW5nKCksIDE0KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJWNcIiArIHBhZGRlZE5hbWUgKyBcIlxcdCVjXCIgKyB0aW1lICsgXCJcXHQlY1wiICsgcmFuayArIFwiRCBcIiArIHNoYXBlICsgXCJcXHQlY1wiICsgc2l6ZSwgJ2ZvbnQtd2VpZ2h0OmJvbGQnLCAnY29sb3I6cmVkJywgJ2NvbG9yOmJsdWUnLCAnY29sb3I6IG9yYW5nZScpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0Zvck5hTih2YWxzLCByZXN1bHQuZHR5cGUsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrKHJlc3VsdCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUudmVjdG9yVGltZXNNYXRyaXggPSBmdW5jdGlvbiAodiwgbWF0cml4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYucmFuayA9PT0gMSwgXCJFcnJvciBpbiB2ZWN0b3JUaW1lc01hdHJpeDogZmlyc3QgaW5wdXQgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIHYucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG1hdHJpeC5yYW5rID09PSAyLCBcIkVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBzZWNvbmQgaW5wdXQgbXVzdCBiZSByYW5rIDIsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIG1hdHJpeC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodi5zaXplID09PSBtYXRyaXguc2hhcGVbMF0sIFwiRXJyb3IgaW4gdmVjdG9yVGltZXNNYXRyaXg6IHNpemUgb2YgdmVjdG9yIChcIiArIHYuc2l6ZSArIFwiKSBcIiArXG4gICAgICAgICAgICAoXCJtdXN0IG1hdGNoIGZpcnN0IGRpbWVuc2lvbiBvZiBtYXRyaXggKFwiICsgbWF0cml4LnNoYXBlWzBdICsgXCIpXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0TXVsKHYuYXMyRCgxLCAtMSksIG1hdHJpeCkuYXMxRCgpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm1hdHJpeFRpbWVzVmVjdG9yID0gZnVuY3Rpb24gKG1hdHJpeCwgdikge1xuICAgICAgICB1dGlsLmFzc2VydCh2LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gbWF0cml4VGltZXNWZWN0b3I6IHNlY29uZCBpbnB1dCBtdXN0IHJhbmsgMSwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgdi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQobWF0cml4LnJhbmsgPT09IDIsIFwiRXJyb3IgaW4gbWF0cml4VGltZXNWZWN0b3I6IGZpcnN0IGlucHV0IG11c3QgYmUgYSByYW5rIDIsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIG1hdHJpeC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodi5zaXplID09PSBtYXRyaXguc2hhcGVbMV0sIFwiRXJyb3IgaW4gbWF0cml4VGltZXNWZWN0b3I6IHNpemUgb2YgZmlyc3QgcmFuayAxIGlucHV0IFwiICsgdi5zaXplICsgXCIgXCIgK1xuICAgICAgICAgICAgXCJtdXN0IG1hdGNoIGlubmVyIGRpbWVuc2lvbiBvZiBzZWNvbmQgcmFuayAyIGlucHV0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInNoYXBlIFwiICsgbWF0cml4LnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0TXVsKG1hdHJpeCwgdi5hczJEKC0xLCAxKSkuYXMxRCgpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmRvdFByb2R1Y3QgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYxLnJhbmsgPT09IDEgJiYgdjIucmFuayA9PT0gMSwgXCJFcnJvciBpbiBkb3RQcm9kdWN0OiBpbnB1dHMgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgcmFua3MgXCIgK1xuICAgICAgICAgICAgKHYxLnJhbmsgKyBcIiBhbmQgXCIgKyB2Mi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodjEuc2l6ZSA9PT0gdjIuc2l6ZSwgXCJFcnJvciBpbiBkb3RQcm9kdWN0OiBzaXplIG9mIGlucHV0cyAoXCIgKyB2MS5zaXplICsgXCIpIGFuZCAoXCIgK1xuICAgICAgICAgICAgKHYyLnNpemUgKyBcIikgbXVzdCBtYXRjaC5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRNdWwodjEuYXMyRCgxLCAtMSksIHYyLmFzMkQoLTEsIDEpKS5hc1NjYWxhcigpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm91dGVyUHJvZHVjdCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodjEucmFuayA9PT0gMSAmJiB2Mi5yYW5rID09PSAxLCBcIkVycm9yIGluIG91dGVyUHJvZHVjdDogaW5wdXRzIG11c3QgYmUgcmFuayAxLCBidXQgZ290IHJhbmtzIFwiICtcbiAgICAgICAgICAgICh2MS5yYW5rICsgXCIgYW5kIFwiICsgdjIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdE11bCh2MS5hczJEKC0xLCAxKSwgdjIuYXMyRCgxLCAtMSkpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdjbG9uZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNsb25lSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnJlc2hhcGUgPSBmdW5jdGlvbiAobmRhcnJheSwgbmV3U2hhcGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdtYXRoLnJlc2hhcGUoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgY2FsbCByZXNoYXBlKCkgJyArXG4gICAgICAgICAgICAnZGlyZWN0bHkgb24gdGhlIG5kYXJyYXkgb2JqZWN0Jyk7XG4gICAgICAgIHJldHVybiBuZGFycmF5LnJlc2hhcGUobmV3U2hhcGUpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNsaWNlMUQgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHNsaWNlX3V0aWwuYXNzZXJ0UGFyYW1zVmFsaWQoaW5wdXQsIFtiZWdpbl0sIFtzaXplXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc2xpY2UxRCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNsaWNlMURJbnRlcm5hbChpbnB1dCwgYmVnaW4sIHNpemUpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zbGljZTJEID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzbGljZV91dGlsLmFzc2VydFBhcmFtc1ZhbGlkKGlucHV0LCBiZWdpbiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc2xpY2UyRCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNsaWNlMkRJbnRlcm5hbChpbnB1dCwgYmVnaW4sIHNpemUpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zbGljZTNEID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzbGljZV91dGlsLmFzc2VydFBhcmFtc1ZhbGlkKGlucHV0LCBiZWdpbiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc2xpY2UzRCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNsaWNlM0RJbnRlcm5hbChpbnB1dCwgYmVnaW4sIHNpemUpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zbGljZTREID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzbGljZV91dGlsLmFzc2VydFBhcmFtc1ZhbGlkKGlucHV0LCBiZWdpbiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc2xpY2U0RCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNsaWNlNERJbnRlcm5hbChpbnB1dCwgYmVnaW4sIHNpemUpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb3B5MkQgPSBmdW5jdGlvbiAoc291cmNlLCBzb3VyY2VCZWdpbiwgc291cmNlU2l6ZSwgZGVzdCwgZGVzdEJlZ2luLCBkZXN0U2l6ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydChzb3VyY2VCZWdpblswXSArIHNvdXJjZVNpemVbMF0gPD0gc291cmNlLnNoYXBlWzBdICYmXG4gICAgICAgICAgICBzb3VyY2VCZWdpblsxXSArIHNvdXJjZVNpemVbMV0gPD0gc291cmNlLnNoYXBlWzFdLCBcIkVycm9yIGluIGNvcHkyRDogcmVxdWVzdGVkIHNvdXJjZSBzdGFydCBwb3NpdGlvbiBcIiArIHNvdXJjZUJlZ2luICsgXCIgXCIgK1xuICAgICAgICAgICAgKFwiYW5kIHNvdXJjZSBzaXplIFwiICsgc291cmNlU2l6ZSArIFwiIHdvdWxkIG92ZXJmbG93IHNvdXJjZSBOREFycmF5XCIpICtcbiAgICAgICAgICAgIChcIm9mIHNoYXBlIFwiICsgc291cmNlLnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZGVzdEJlZ2luWzBdICsgZGVzdFNpemVbMF0gPD0gZGVzdC5zaGFwZVswXSAmJlxuICAgICAgICAgICAgZGVzdEJlZ2luWzFdICsgZGVzdFNpemVbMV0gPD0gZGVzdC5zaGFwZVsxXSwgXCJFcnJvciBpbiBjb3B5MkQ6IHJlcXVlc3RlZCBkZXN0IHN0YXJ0IHBvc2l0aW9uIFwiICsgZGVzdEJlZ2luICsgXCIgXCIgK1xuICAgICAgICAgICAgKFwiYW5kIHNvdXJjZSBzaXplIFwiICsgZGVzdFNpemUgKyBcIiB3b3VsZCBvdmVyZmxvdyBkZXN0IE5EQXJyYXkgb2ZcIikgK1xuICAgICAgICAgICAgKFwic2hhcGUgXCIgKyBkZXN0LnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgY29weTJkX3V0aWwudmFsaWRhdGVTaGFwZXMoc291cmNlU2l6ZSwgZGVzdFNpemUpO1xuICAgICAgICB0aGlzLmV4ZWN1dGVPcCgnY29weTJEJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY29weTJESW50ZXJuYWwoc291cmNlLCBzb3VyY2VCZWdpbiwgc291cmNlU2l6ZSwgZGVzdCwgZGVzdEJlZ2luLCBkZXN0U2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29uY2F0MUQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb25jYXRfdXRpbC5hc3NlcnRQYXJhbXMoYS5zaGFwZSwgYi5zaGFwZSwgMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnY29uY2F0MUQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb25jYXQxREludGVybmFsKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb25jYXQyRCA9IGZ1bmN0aW9uIChhLCBiLCBheGlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbmNhdF91dGlsLmFzc2VydFBhcmFtcyhhLnNoYXBlLCBiLnNoYXBlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdjb25jYXQyRCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbmNhdDJESW50ZXJuYWwoYSwgYiwgYXhpcyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbmNhdDNEID0gZnVuY3Rpb24gKG5kYXJyYXkxLCBuZGFycmF5MiwgYXhpcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb25jYXRfdXRpbC5hc3NlcnRQYXJhbXMobmRhcnJheTEuc2hhcGUsIG5kYXJyYXkyLnNoYXBlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdjb25jYXQzRCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbmNhdDNESW50ZXJuYWwobmRhcnJheTEsIG5kYXJyYXkyLCBheGlzKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29uY2F0NEQgPSBmdW5jdGlvbiAobmRhcnJheTEsIG5kYXJyYXkyLCBheGlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbmNhdF91dGlsLmFzc2VydFBhcmFtcyhuZGFycmF5MS5zaGFwZSwgbmRhcnJheTIuc2hhcGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2NvbmNhdDREJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29uY2F0NERJbnRlcm5hbChuZGFycmF5MSwgbmRhcnJheTIsIGF4aXMpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5sb2dTdW1FeHAgPSBmdW5jdGlvbiAoaW5wdXQsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCBpbnB1dC5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbG9nU3VtRXhwJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHhNYXggPSBfdGhpcy5tYXgoaW5wdXQsIGF4ZXMsIHRydWUpO1xuICAgICAgICAgICAgdmFyIGEgPSBfdGhpcy5zdWJ0cmFjdChpbnB1dCwgeE1heCk7XG4gICAgICAgICAgICB2YXIgYiA9IF90aGlzLmV4cChhKTtcbiAgICAgICAgICAgIHZhciBjID0gX3RoaXMuc3VtKGIsIGF4ZXMpO1xuICAgICAgICAgICAgdmFyIGQgPSBfdGhpcy5sb2coYyk7XG4gICAgICAgICAgICB2YXIgcmVzID0gX3RoaXMuYWRkKHhNYXgucmVzaGFwZShkLnNoYXBlKSwgZCk7XG4gICAgICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0ocmVzLnNoYXBlLCBheGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUobmV3U2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24gKGlucHV0LCBheGlzLCBrZWVwRGltcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG9yaWdBeGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIGlucHV0LnNoYXBlKTtcbiAgICAgICAgdmFyIGF4ZXMgPSBvcmlnQXhlcztcbiAgICAgICAgdmFyIHBlcm11dGVkQXhlcyA9IGF4aXNfdXRpbC5nZXRQZXJtdXRlZEF4ZXMoYXhlcywgaW5wdXQucmFuayk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc3VtJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBfdGhpcy50cmFuc3Bvc2UoaW5wdXQsIHBlcm11dGVkQXhlcyk7XG4gICAgICAgICAgICAgICAgYXhlcyA9IGF4aXNfdXRpbC5nZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXMgPSBfdGhpcy5zdW1JbnRlcm5hbChpbnB1dCwgYXhlcyk7XG4gICAgICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0ocmVzLnNoYXBlLCBvcmlnQXhlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXNoYXBlKG5ld1NoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm1lYW4gPSBmdW5jdGlvbiAoeCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICB2YXIgc2hhcGVzID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyk7XG4gICAgICAgIHZhciByZWR1Y2VTaGFwZSA9IHNoYXBlc1sxXTtcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ21lYW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2NvcGUoZnVuY3Rpb24gKGtlZXAsIHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IF90aGlzLmRpdmlkZSh4LCB0cmFjayhuZGFycmF5XzEuU2NhbGFyLm5ldyhyZWR1Y2VTaXplKSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdW0ocmVzLCBheGlzLCBrZWVwRGltcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYXJnTWluID0gZnVuY3Rpb24gKGlucHV0LCBheGlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIGF4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgaW5wdXQuc2hhcGUpO1xuICAgICAgICB2YXIgcGVybXV0ZWRBeGVzID0gYXhpc191dGlsLmdldFBlcm11dGVkQXhlcyhheGVzLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhcmdNaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IF90aGlzLnRyYW5zcG9zZShpbnB1dCwgcGVybXV0ZWRBeGVzKTtcbiAgICAgICAgICAgICAgICBheGVzID0gYXhpc191dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIGlucHV0LnJhbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFyZ01pbkludGVybmFsKGlucHV0LCBheGVzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYXJnTWF4ID0gZnVuY3Rpb24gKGlucHV0LCBheGlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIGF4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgaW5wdXQuc2hhcGUpO1xuICAgICAgICB2YXIgcGVybXV0ZWRBeGVzID0gYXhpc191dGlsLmdldFBlcm11dGVkQXhlcyhheGVzLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhcmdNYXgnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IF90aGlzLnRyYW5zcG9zZShpbnB1dCwgcGVybXV0ZWRBeGVzKTtcbiAgICAgICAgICAgICAgICBheGVzID0gYXhpc191dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIGlucHV0LnJhbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFyZ01heEludGVybmFsKGlucHV0LCBheGVzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYXJnTWF4RXF1YWxzID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHgxLnNoYXBlLCB4Mi5zaGFwZSwgJ0Vycm9yIGluIGFyZ01heEVxdWFsczogJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnYXJnTWF4RXF1YWxzJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVxdWFsKF90aGlzLmFyZ01heCh4MSksIF90aGlzLmFyZ01heCh4MikpO1xuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZXF1YWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2VxdWFsJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZXF1YWxJbnRlcm5hbCh4LCB5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHguc2hhcGUsIHkuc2hhcGUsICdFcnJvciBpbiBlcXVhbFN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmVxdWFsKHgsIHkpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnRvcEsgPSBmdW5jdGlvbiAobmRhcnJheSwgaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydChrIDw9IG5kYXJyYXkuc2l6ZSwgXCJFcnJvciBpbiB0b3BLOiBrIHZhbHVlIChcIiArIGsgKyBcIikgbXVzdCBiZSBsZXNzIHRoYW4gc2l6ZSBvZiBpbnB1dCBcIiArXG4gICAgICAgICAgICAoXCJuZGFycmF5LCBnb3Qgc2hhcGUgXCIgKyBuZGFycmF5LnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdGhpcy5leGVjdXRlT3AoJ3RvcEsnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBfdGhpcy50b3BLSW50ZXJuYWwobmRhcnJheSwgayk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhY2socmVzdWx0LmluZGljZXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uIChpbnB1dCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBvcmlnQXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCBpbnB1dC5zaGFwZSk7XG4gICAgICAgIHZhciBheGVzID0gb3JpZ0F4ZXM7XG4gICAgICAgIHZhciBwZXJtdXRlZEF4ZXMgPSBheGlzX3V0aWwuZ2V0UGVybXV0ZWRBeGVzKGF4ZXMsIGlucHV0LnJhbmspO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ21pbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChwZXJtdXRlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gX3RoaXMudHJhbnNwb3NlKGlucHV0LCBwZXJtdXRlZEF4ZXMpO1xuICAgICAgICAgICAgICAgIGF4ZXMgPSBheGlzX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgaW5wdXQucmFuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzID0gX3RoaXMubWluSW50ZXJuYWwoaW5wdXQsIGF4ZXMpO1xuICAgICAgICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0gYXhpc191dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKHJlcy5zaGFwZSwgb3JpZ0F4ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShuZXdTaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoaW5wdXQsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgb3JpZ0F4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgaW5wdXQuc2hhcGUpO1xuICAgICAgICB2YXIgYXhlcyA9IG9yaWdBeGVzO1xuICAgICAgICB2YXIgcGVybXV0ZWRBeGVzID0gYXhpc191dGlsLmdldFBlcm11dGVkQXhlcyhheGVzLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdtYXgnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IF90aGlzLnRyYW5zcG9zZShpbnB1dCwgcGVybXV0ZWRBeGVzKTtcbiAgICAgICAgICAgICAgICBheGVzID0gYXhpc191dGlsLmdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIGlucHV0LnJhbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlcyA9IF90aGlzLm1heEludGVybmFsKGlucHV0LCBheGVzKTtcbiAgICAgICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShyZXMuc2hhcGUsIG9yaWdBeGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUobmV3U2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc29mdG1heCA9IGZ1bmN0aW9uIChsb2dpdHMsIGRpbSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGltID09PSB2b2lkIDApIHsgZGltID0gLTE7IH1cbiAgICAgICAgaWYgKGRpbSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGRpbSA9IGxvZ2l0cy5yYW5rIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGltICE9PSBsb2dpdHMucmFuayAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdTb2Z0bWF4IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiAnICtcbiAgICAgICAgICAgICAgICAoXCJMb2dpdHMgd2FzIHJhbmsgXCIgKyBsb2dpdHMucmFuayArIFwiIGFuZCBkaW0gd2FzIFwiICsgZGltKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzb2Z0bWF4JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbHNlID0gX3RoaXMubG9nU3VtRXhwKGxvZ2l0cywgW2RpbV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBsb2dSZXN1bHQgPSBfdGhpcy5zdWJ0cmFjdChsb2dpdHMsIGxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4cChsb2dSZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnN3aXRjaERpbSA9IGZ1bmN0aW9uIChhLCBuZXdEaW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3NlKGEsIG5ld0RpbSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUudGlsZSA9IGZ1bmN0aW9uIChhLCByZXBzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGEucmFuayA9PT0gcmVwcy5sZW5ndGgsIFwiRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0IFwiICsgYS5yYW5rICsgXCIgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCBsZW5ndGggb2YgcmVwcyBcIiArIHJlcHMgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3RpbGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50aWxlSW50ZXJuYWwoYSwgcmVwcyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnRyYW5zcG9zZSA9IGZ1bmN0aW9uIChhLCBwZXJtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChwZXJtID09IG51bGwpIHtcbiAgICAgICAgICAgIHBlcm0gPSBhLnNoYXBlLm1hcChmdW5jdGlvbiAocywgaSkgeyByZXR1cm4gaTsgfSkucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KGEucmFuayA9PT0gcGVybS5sZW5ndGgsIFwiRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0IFwiICsgYS5yYW5rICsgXCIgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCBsZW5ndGggb2YgcGVybSBcIiArIHBlcm0gKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3RyYW5zcG9zZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRyYW5zcG9zZUludGVybmFsKGEsIHBlcm0pOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zY2FsYXJQbHVzQXJyYXkgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB1dGlsLmFzc2VydChjLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gc2NhbGFyUGx1c0FycmF5OiBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgYy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGMsIGEpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNjYWxhck1pbnVzQXJyYXkgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB1dGlsLmFzc2VydChjLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gc2NhbGFyTWludXNBcnJheTogZmlyc3QgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KGMsIGEpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmFycmF5TWludXNTY2FsYXIgPSBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICB1dGlsLmFzc2VydChjLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gYXJyYXlNaW51c1NjYWxhcjogc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgXCIgK1xuICAgICAgICAgICAgKFwiZ290IHJhbmsgXCIgKyBjLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdChhLCBjKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ25lZycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm5lZ0ludGVybmFsKGEpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhZGQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hZGRJbnRlcm5hbChhLCBiKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYWRkU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gYWRkU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGEsIGIpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc3VidHJhY3QnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdWJ0cmFjdEludGVybmFsKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdChhLCBiKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zdWJTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBzdWJTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdChhLCBiKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ211bHRpcGx5JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubXVsdGlwbHlJbnRlcm5hbChhLCBiKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZWxlbWVudFdpc2VNdWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVN0cmljdChhLCBiKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tdWx0aXBseVN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIG11bHRpcGx5U3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoYSwgYik7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnZGl2aWRlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZGl2aWRlSW50ZXJuYWwoYSwgYik7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmRpdmlkZVN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIGRpdmlkZVN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZShhLCBiKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zY2FsYXJEaXZpZGVkQnlBcnJheSA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBzY2FsYXJEaXZpZGVkQnlBcnJheTogZmlyc3QgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgTkRBcnJheSBvZiByYW5rIFwiICsgYy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlKGMsIGEpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmFycmF5RGl2aWRlZEJ5U2NhbGFyID0gZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYy5zaXplID09PSAxLCBcIkVycm9yIGluIGFycmF5RGl2aWRlZEJ5U2NhbGFyOiBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIFwiICtcbiAgICAgICAgICAgIChcImJ1dCBnb3QgTkRBcnJheSBvZiByYW5rIFwiICsgYy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlKGEsIGMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNlaWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2NlaWwnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jZWlsSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmZsb29yID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdmbG9vcicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZsb29ySW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnZXhwJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZXhwSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbG9nJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubG9nSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NxcnQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zcXJ0SW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc3F1YXJlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3F1YXJlSW50ZXJuYWwoeCk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnYWJzJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYWJzSW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbiAobmRhcnJheSwgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoKG1pbiA8PSBtYXgpLCBcIkVycm9yIGluIGNsaXA6IG1pbiAoXCIgKyBtaW4gKyBcIikgbXVzdCBiZVwiICtcbiAgICAgICAgICAgIChcImxlc3MgdGhhbiBvciBlcXVhbCB0byBtYXggKFwiICsgbWF4ICsgXCIpLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnY2xpcCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNsaXBJbnRlcm5hbChuZGFycmF5LCBtaW4sIG1heCk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnJlbHUgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3JlbHUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZWx1SW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmVsdSA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnZWx1JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZWx1SW50ZXJuYWwobmRhcnJheSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmxlYWt5UmVsdSA9IGZ1bmN0aW9uIChuZGFycmF5LCBhbHBoYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDAuMjsgfVxuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2xlYWt5UmVsdScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmxlYWt5UmVsdUludGVybmFsKG5kYXJyYXksIGFscGhhKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2lnbW9pZCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc2lnbW9pZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNpZ21vaWRJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2luID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzaW4nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zaW5JbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29zID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdjb3MnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb3NJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUudGFuID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCd0YW4nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50YW5JbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYXNpbiA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnYXNpbicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmFzaW5JbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYWNvcyA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnYWNvcycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmFjb3NJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYXRhbiA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnYXRhbicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmF0YW5JbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2luaCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc2luaCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNpbmhJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29zaCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnY29zaCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvc2hJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUudGFuaCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgndGFuaCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRhbmhJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uIChuZGFycmF5LCBhbHBoYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDAuMDsgfVxuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3N0ZXAnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdGVwSW50ZXJuYWwobmRhcnJheSwgYWxwaGEpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zY2FsZWRBcnJheUFkZCA9IGZ1bmN0aW9uIChjMSwgYSwgYzIsIGIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoYzEuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBzY2FsZWRBcnJheUFkZDogZmlyc3QgYXJndW1lbnQgbXVzdCByYW5rIDAsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwiIHJhbmsgXCIgKyBjMS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoYzIuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBzY2FsZWRBcnJheUFkZDogdGhpcmQgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwiTkRBcnJheSBvZiByYW5rIFwiICsgYzIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIHNjYWxlZEFycmF5QWRkOiAnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzY2FsZWRBcnJheUFkZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNjYWxlZEFycmF5QWRkSW50ZXJuYWwoYzEsIGEsIGMyLCBiKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2NhbGFyVGltZXNBcnJheSA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBhcnJheURpdmlkZWRCeVNjYWxhcjogZmlyc3QgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgcmFuayBcIiArIGMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KGMsIGEpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmVsZW1lbnRXaXNlTXVsQnJvYWRjYXN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYS5yYW5rID09PSAyLCBcIkVycm9yIGluIGVsZW1lbnRXaXNlTXVsQnJvYWRjYXN0OiBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIFwiICtcbiAgICAgICAgICAgIChcInJhbmsgMiwgYnV0IGdvdCByYW5rIFwiICsgYS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoYi5yYW5rID09PSAyLCBcIkVycm9yIGluIGVsZW1lbnRXaXNlTXVsQnJvYWRjYXN0OiBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIDIsIGJ1dCBnb3QgcmFuayBcIiArIGIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KGEsIGIpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbnYyZCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIGJpYXMsIHN0cmlkZXMsIHBhZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gY29udjJkOiB4IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgXCIgKyB4LnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlci5yYW5rID09PSA0LCBcIkVycm9yIGluIGNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGZpbHRlci5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKGJpYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoYmlhcy5yYW5rID09PSAxLCBcIkVycm9yIGluIGNvbnYyZDogYmlhcyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgICAgICAoYmlhcy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh4LnNoYXBlWzJdID09PSBmaWx0ZXIuc2hhcGVbMl0sIFwiRXJyb3IgaW4gY29udjJkOiBkZXB0aCBvZiBpbnB1dCAoXCIgKyB4LnNoYXBlWzJdICsgXCIpIG11c3QgbWF0Y2ggIFwiICtcbiAgICAgICAgICAgIChcImlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIgKyBmaWx0ZXIuc2hhcGVbMl0gKyBcIi5cIikpO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gZmlsdGVyLnNoYXBlWzBdO1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBmaWx0ZXIuc2hhcGVbMV07XG4gICAgICAgIHZhciBvdXREZXB0aCA9IGZpbHRlci5zaGFwZVszXTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKHN0cmlkZXMpLCBzdHJpZGVIZWlnaHQgPSBfYVswXSwgc3RyaWRlV2lkdGggPSBfYVsxXTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252MkRJbmZvKHguc2hhcGUsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIG91dERlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBwYWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2NvbnYyZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbnYyZEludGVybmFsKHgsIGZpbHRlciwgYmlhcywgY29udkluZm8pOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb252MmRCYWNrUHJvcCA9IGZ1bmN0aW9uICh4LCBkeSwgZmlsdGVyLCBzdHJpZGVzLCBwYWQpIHtcbiAgICAgICAgdmFyIGR3ID0gdGhpcy5jb252MmREZXJGaWx0ZXIoeCwgZHksIGZpbHRlci5zaGFwZSwgc3RyaWRlcywgcGFkKTtcbiAgICAgICAgdmFyIGRiID0gdGhpcy5jb252MmREZXJCaWFzKGR5KTtcbiAgICAgICAgdmFyIGR4ID0gdGhpcy5jb252MmREZXJJbnB1dCh4LnNoYXBlLCBkeSwgZmlsdGVyLCBzdHJpZGVzLCBwYWQpO1xuICAgICAgICByZXR1cm4geyBkYjogZGIsIGR3OiBkdywgZHg6IGR4IH07XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29udjJkRGVySW5wdXQgPSBmdW5jdGlvbiAoaW5TaGFwZSwgZHksIGZpbHRlciwgc3RyaWRlcywgcGFkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpbkRlcHRoID0gaW5TaGFwZVsyXTtcbiAgICAgICAgdmFyIG91dERlcHRoID0gZHkuc2hhcGVbMl07XG4gICAgICAgIHV0aWwuYXNzZXJ0KGluU2hhcGUubGVuZ3RoID09PSAzLCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiB4IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGluU2hhcGUubGVuZ3RoICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZHkucmFuayA9PT0gMywgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZHkgbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGR5LnJhbmspKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZmlsdGVyLnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgZmlsdGVyLnJhbmspKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5EZXB0aCA9PT0gZmlsdGVyLnNoYXBlWzJdLCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBpbnB1dCAoXCIgKyBpbkRlcHRoICsgXCIpIG11c3QgXCIgK1xuICAgICAgICAgICAgKFwibWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIiArIGZpbHRlci5zaGFwZVsyXSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG91dERlcHRoID09PSBmaWx0ZXIuc2hhcGVbM10sIFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGRlcHRoIG9mIG91dHB1dCAoXCIgKyBvdXREZXB0aCArIFwiKSBtdXN0XCIgK1xuICAgICAgICAgICAgKFwibWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIgKyBmaWx0ZXIuc2hhcGVbM10gKyBcIi5cIikpO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gZmlsdGVyLnNoYXBlWzBdO1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBmaWx0ZXIuc2hhcGVbMV07XG4gICAgICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShzdHJpZGVzKSwgc3RyaWRlSGVpZ2h0ID0gX2FbMF0sIHN0cmlkZVdpZHRoID0gX2FbMV07XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlQ29udjJESW5mbyhpblNoYXBlLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBvdXREZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgcGFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdjb252MmREZXJJbnB1dCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbnYyZERlcklucHV0SW50ZXJuYWwoZHksIGZpbHRlciwgY29udkluZm8pOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb252MmREZXJCaWFzID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuY29udjJkRGVyQmlhc0ludGVybmFsKGR5KSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVyID0gZnVuY3Rpb24gKHgsIGR5LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAzLCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogeCBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCBzaGFwZSBcIiArXG4gICAgICAgICAgICAoeC5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGR5LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkeSBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCBzaGFwZSBcIiArXG4gICAgICAgICAgICAoZHkuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChmaWx0ZXJTaXplLmxlbmd0aCA9PT0gNCwgXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGZpbHRlclNpemUgbXVzdCBiZSBsZW5ndGggNCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoZmlsdGVyU2l6ZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHguc2hhcGVbMl0gPT09IGZpbHRlclNpemVbMl0sIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkZXB0aCBvZiB4IFwiICsgeC5zaGFwZVsyXSArIFwiKSBtdXN0IFwiICtcbiAgICAgICAgICAgIChcIm1hdGNoIGlucHV0IGRlcHRoIGluIGZpbHRlciAoXCIgKyBmaWx0ZXJTaXplWzJdICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZHkuc2hhcGVbMl0gPT09IGZpbHRlclNpemVbM10sIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkZXB0aCBvZiBkeSAoXCIgKyBkeS5zaGFwZVsyXSArIFwiKSBtdXN0IFwiICtcbiAgICAgICAgICAgIChcIm1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIChcIiArIGZpbHRlclNpemVbM10gKyBcIikuXCIpKTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGZpbHRlclNpemVbMF07XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGZpbHRlclNpemVbMV07XG4gICAgICAgIHZhciBvdXREZXB0aCA9IGZpbHRlclNpemVbM107XG4gICAgICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShzdHJpZGVzKSwgc3RyaWRlSGVpZ2h0ID0gX2FbMF0sIHN0cmlkZVdpZHRoID0gX2FbMV07XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlQ29udjJESW5mbyh4LnNoYXBlLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBvdXREZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgcGFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5jb252MmREZXJGaWx0ZXJJbnRlcm5hbCh4LCBkeSwgY29udkluZm8pKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb252MmRUcmFuc3Bvc2UgPSBmdW5jdGlvbiAoeCwgZmlsdGVyLCBvdXRwdXRTaGFwZSwgc3RyaWRlcywgcGFkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnYyZERlcklucHV0KG91dHB1dFNoYXBlLCB4LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJEID0gZnVuY3Rpb24gKGlucHV0LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCwgcmF0ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHJhdGVzID09PSB2b2lkIDApIHsgcmF0ZXMgPSBbMSwgMV07IH1cbiAgICAgICAgdmFyIGlucHV0NEQgPSBpbnB1dDtcbiAgICAgICAgdmFyIHJlc2hhcGVkVG80RCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5wdXQucmFuayA9PT0gMykge1xuICAgICAgICAgICAgcmVzaGFwZWRUbzREID0gdHJ1ZTtcbiAgICAgICAgICAgIGlucHV0NEQgPSBpbnB1dC5hczREKDEsIGlucHV0LnNoYXBlWzBdLCBpbnB1dC5zaGFwZVsxXSwgaW5wdXQuc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KGlucHV0NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MkQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBpbnB1dDRELnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChmaWx0ZXIucmFuayA9PT0gNCwgXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MkQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgIChmaWx0ZXIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGlucHV0NEQuc2hhcGVbM10gPT09IGZpbHRlci5zaGFwZVsyXSwgXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MkQ6IG51bWJlciBvZiBpbnB1dCBjaGFubmVscyBcIiArXG4gICAgICAgICAgICAoXCIoXCIgKyBpbnB1dDRELnNoYXBlWzNdICsgXCIpIG11c3QgbWF0Y2ggdGhlIGluQ2hhbm5lbHMgZGltZW5zaW9uIGluIFwiKSArXG4gICAgICAgICAgICAoXCJmaWx0ZXIgXCIgKyBmaWx0ZXIuc2hhcGVbMl0gKyBcIi5cIikpO1xuICAgICAgICByYXRlcyA9IHJhdGVzIHx8IFsxLCAxXTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKHJhdGVzKSwgcmF0ZUhlaWdodCA9IF9hWzBdLCByYXRlV2lkdGggPSBfYVsxXTtcbiAgICAgICAgdXRpbC5hc3NlcnQocmF0ZUhlaWdodCA9PT0gMSAmJiByYXRlV2lkdGggPT09IDEsICdFcnJvciBpbiBkZXB0aHdpc2VDb252MkQ6IHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0ICcgK1xuICAgICAgICAgICAgKFwic3VwcG9ydGVkLiBHb3QgcmF0ZXMgJ1wiICsgcmF0ZXMgKyBcIidcIikpO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZURlcHRod2lzZUNvbnYyREluZm8oaW5wdXQ0RC5zaGFwZSwgZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCBwYWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2RlcHRod2lzZUNvbnYyRCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBfdGhpcy5kZXB0aHdpc2VDb252MkRJbnRlcm5hbChpbnB1dDRELCBmaWx0ZXIsIGNvbnZJbmZvKTtcbiAgICAgICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tYXhQb29sID0gZnVuY3Rpb24gKHgsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gbWF4UG9vbDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgKyB4LnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShmaWx0ZXJTaXplKSwgZmlsdGVySGVpZ2h0ID0gX2FbMF0sIGZpbHRlcldpZHRoID0gX2FbMV07XG4gICAgICAgIHZhciBvdXREZXB0aCA9IHguc2hhcGVbMl07XG4gICAgICAgIHZhciBfYiA9IHBhcnNlVHVwbGVQYXJhbShzdHJpZGVzKSwgc3RyaWRlSGVpZ2h0ID0gX2JbMF0sIHN0cmlkZVdpZHRoID0gX2JbMV07XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlQ29udjJESW5mbyh4LnNoYXBlLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBvdXREZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgcGFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdtYXhQb29sJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubWF4UG9vbEludGVybmFsKHgsIGNvbnZJbmZvKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wID0gZnVuY3Rpb24gKGR5LCB4LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoZHkucmFuayA9PT0gMywgXCJFcnJvciBpbiBtYXhQb29sQmFja3Byb3A6IGR5IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoZHkucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJFcnJvciBpbiBtYXhQb29sQmFja3Byb3A6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgICh4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB2YXIgX2EgPSBwYXJzZVR1cGxlUGFyYW0oZmlsdGVyU2l6ZSksIGZpbHRlckhlaWdodCA9IF9hWzBdLCBmaWx0ZXJXaWR0aCA9IF9hWzFdO1xuICAgICAgICB2YXIgb3V0RGVwdGggPSB4LnNoYXBlWzJdO1xuICAgICAgICB2YXIgX2IgPSBwYXJzZVR1cGxlUGFyYW0oc3RyaWRlcyksIHN0cmlkZUhlaWdodCA9IF9iWzBdLCBzdHJpZGVXaWR0aCA9IF9iWzFdO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeC5zaGFwZSwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgb3V0RGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIHBhZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbWF4UG9vbEJhY2twcm9wJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubWF4UG9vbEJhY2twcm9wSW50ZXJuYWwoZHksIHgsIGNvbnZJbmZvKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubWluUG9vbCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAzLCBcIkVycm9yIGluIG1pblBvb2w6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiICsgeC5yYW5rICsgXCIuXCIpO1xuICAgICAgICB2YXIgX2EgPSBwYXJzZVR1cGxlUGFyYW0oZmlsdGVyU2l6ZSksIGZpbHRlckhlaWdodCA9IF9hWzBdLCBmaWx0ZXJXaWR0aCA9IF9hWzFdO1xuICAgICAgICB2YXIgb3V0RGVwdGggPSB4LnNoYXBlWzJdO1xuICAgICAgICB2YXIgX2IgPSBwYXJzZVR1cGxlUGFyYW0oc3RyaWRlcyksIHN0cmlkZUhlaWdodCA9IF9iWzBdLCBzdHJpZGVXaWR0aCA9IF9iWzFdO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeC5zaGFwZSwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgb3V0RGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIHBhZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbWluUG9vbCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm1pblBvb2xJbnRlcm5hbCh4LCBjb252SW5mbyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmF2Z1Bvb2wgPSBmdW5jdGlvbiAoeCwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJFcnJvciBpbiBhdmdQb29sOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKGZpbHRlclNpemUpLCBmaWx0ZXJIZWlnaHQgPSBfYVswXSwgZmlsdGVyV2lkdGggPSBfYVsxXTtcbiAgICAgICAgdmFyIG91dERlcHRoID0geC5zaGFwZVsyXTtcbiAgICAgICAgdmFyIF9iID0gcGFyc2VUdXBsZVBhcmFtKHN0cmlkZXMpLCBzdHJpZGVIZWlnaHQgPSBfYlswXSwgc3RyaWRlV2lkdGggPSBfYlsxXTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252MkRJbmZvKHguc2hhcGUsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIG91dERlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBwYWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2F2Z1Bvb2wnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hdmdQb29sSW50ZXJuYWwoeCwgY29udkluZm8pOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcjNEID0gZnVuY3Rpb24gKHgsIG5ld1NoYXBlMkQsIGFsaWduQ29ybmVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYWxpZ25Db3JuZXJzID09PSB2b2lkIDApIHsgYWxpZ25Db3JuZXJzID0gZmFsc2U7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAzLCBcIkVycm9yIGluIHJlc2l6ZUJpbGluZWFyM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiICsgeC5yYW5rICsgXCIuXCIpO1xuICAgICAgICB1dGlsLmFzc2VydChuZXdTaGFwZTJELmxlbmd0aCA9PT0gMiwgXCJFcnJvciBpbiByZXNpemVCaWxpbmVhcjNEOiBuZXcgc2hhcGUgbXVzdCAyRCwgYnV0IGdvdCBzaGFwZSBcIiArXG4gICAgICAgICAgICAobmV3U2hhcGUyRCArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgncmVzaXplQmlsaW5lYXIzRCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlc2l6ZUJpbGluZWFyM0RJbnRlcm5hbCh4LCBuZXdTaGFwZTJELCBhbGlnbkNvcm5lcnMpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb24yRCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh2YXJpYW5jZUVwc2lsb24gPT09IHZvaWQgMCkgeyB2YXJpYW5jZUVwc2lsb24gPSAuMDAxOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMiwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKHgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG1lYW4ucmFuayA9PT0gMiB8fCBtZWFuLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uMkQ6IG1lYW4gbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgcmFuayBcIiArIG1lYW4ucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHZhcmlhbmNlLnJhbmsgPT09IDIgfHwgdmFyaWFuY2UucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24yRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHZhcmlhbmNlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoc2NhbGUucmFuayA9PT0gMiB8fCBzY2FsZS5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjJEOiBzY2FsZSBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHNjYWxlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQob2Zmc2V0LnJhbmsgPT09IDIgfHwgb2Zmc2V0LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uMkQ6IG9mZnNldCBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIG9mZnNldC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2JhdGNoTm9ybTJEJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYmF0Y2hOb3JtYWxpemF0aW9uMkRJbnRlcm5hbCh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uM0QgPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodmFyaWFuY2VFcHNpbG9uID09PSB2b2lkIDApIHsgdmFyaWFuY2VFcHNpbG9uID0gLjAwMTsgfVxuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgICh4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChtZWFuLnJhbmsgPT09IDMgfHwgbWVhbi5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiBtZWFuIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgXCIgK1xuICAgICAgICAgICAgKFwiZ290IHJhbmsgXCIgKyBtZWFuLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2YXJpYW5jZS5yYW5rID09PSAzIHx8IHZhcmlhbmNlLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IHZhcmlhbmNlIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBcIiArXG4gICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyB2YXJpYW5jZS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKHNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHNjYWxlLnJhbmsgPT09IDMgfHwgc2NhbGUucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogc2NhbGUgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyBzY2FsZS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KG9mZnNldC5yYW5rID09PSAzIHx8IG9mZnNldC5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyBvZmZzZXQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdiYXRjaE5vcm0zRCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmJhdGNoTm9ybWFsaXphdGlvbjNESW50ZXJuYWwoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm11bHRpUk5OQ2VsbCA9IGZ1bmN0aW9uIChsc3RtQ2VsbHMsIGRhdGEsIGMsIGgpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZGF0YTtcbiAgICAgICAgICAgIHZhciBuZXdTdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbHN0bUNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IGxzdG1DZWxsc1tpXShpbnB1dCwgY1tpXSwgaFtpXSk7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVzLnB1c2gob3V0cHV0WzBdKTtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZXMucHVzaChvdXRwdXRbMV0pO1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb3V0cHV0WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld1N0YXRlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuZXdDID0gW107XG4gICAgICAgIHZhciBuZXdIID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBuZXdDLnB1c2gocmVzW2ldKTtcbiAgICAgICAgICAgIG5ld0gucHVzaChyZXNbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25ld0MsIG5ld0hdO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmJhc2ljTFNUTUNlbGwgPSBmdW5jdGlvbiAoZm9yZ2V0QmlhcywgbHN0bUtlcm5lbCwgbHN0bUJpYXMsIGRhdGEsIGMsIGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbWJpbmVkID0gX3RoaXMuY29uY2F0MkQoZGF0YSwgaCwgMSk7XG4gICAgICAgICAgICB2YXIgd2VpZ2h0ZWQgPSBfdGhpcy5tYXRNdWwoY29tYmluZWQsIGxzdG1LZXJuZWwpO1xuICAgICAgICAgICAgdmFyIHJlcyA9IF90aGlzLmFkZCh3ZWlnaHRlZCwgbHN0bUJpYXMpO1xuICAgICAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHJlcy5zaGFwZVswXTtcbiAgICAgICAgICAgIHZhciBzbGljZUNvbHMgPSByZXMuc2hhcGVbMV0gLyA0O1xuICAgICAgICAgICAgdmFyIHNsaWNlU2l6ZSA9IFtiYXRjaFNpemUsIHNsaWNlQ29sc107XG4gICAgICAgICAgICB2YXIgaSA9IF90aGlzLnNsaWNlMkQocmVzLCBbMCwgMF0sIHNsaWNlU2l6ZSk7XG4gICAgICAgICAgICB2YXIgaiA9IF90aGlzLnNsaWNlMkQocmVzLCBbMCwgc2xpY2VDb2xzXSwgc2xpY2VTaXplKTtcbiAgICAgICAgICAgIHZhciBmID0gX3RoaXMuc2xpY2UyRChyZXMsIFswLCBzbGljZUNvbHMgKiAyXSwgc2xpY2VTaXplKTtcbiAgICAgICAgICAgIHZhciBvID0gX3RoaXMuc2xpY2UyRChyZXMsIFswLCBzbGljZUNvbHMgKiAzXSwgc2xpY2VTaXplKTtcbiAgICAgICAgICAgIHZhciBuZXdDID0gX3RoaXMuYWRkU3RyaWN0KF90aGlzLm11bHRpcGx5U3RyaWN0KGMsIF90aGlzLnNpZ21vaWQoX3RoaXMuc2NhbGFyUGx1c0FycmF5KGZvcmdldEJpYXMsIGYpKSksIF90aGlzLm11bHRpcGx5U3RyaWN0KF90aGlzLnNpZ21vaWQoaSksIF90aGlzLnRhbmgoaikpKTtcbiAgICAgICAgICAgIHZhciBuZXdIID0gX3RoaXMubXVsdGlwbHlTdHJpY3QoX3RoaXMudGFuaChuZXdDKSwgX3RoaXMuc2lnbW9pZChvKSk7XG4gICAgICAgICAgICByZXR1cm4gW25ld0MsIG5ld0hdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtyZXNbMF0sIHJlc1sxXV07XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubXVsdGlub21pYWwgPSBmdW5jdGlvbiAocHJvYmFiaWxpdGllcywgbnVtU2FtcGxlcywgc2VlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbnVtT3V0Y29tZXMgPSBwcm9iYWJpbGl0aWVzLnNpemU7XG4gICAgICAgIGlmIChudW1PdXRjb21lcyA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG11bHRpbm9taWFsOiB5b3UgbmVlZCBhdCBsZWFzdCAyIG91dGNvbWVzLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgICAgICAobnVtT3V0Y29tZXMgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9iYWJpbGl0aWVzLnJhbmsgPiAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5rIG9mIHByb2JhYmlsaXRpZXMgbXVzdCBiZSAxIG9yIDIsIGJ1dCBpcyBcIiArIHByb2JhYmlsaXRpZXMucmFuayk7XG4gICAgICAgIH1cbiAgICAgICAgc2VlZCA9IHNlZWQgfHwgTWF0aC5yYW5kb20oKTtcbiAgICAgICAgdmFyIG9yaWdSYW5rID0gcHJvYmFiaWxpdGllcy5yYW5rO1xuICAgICAgICBpZiAocHJvYmFiaWxpdGllcy5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICBwcm9iYWJpbGl0aWVzID0gcHJvYmFiaWxpdGllcy5hczJEKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ211bHRpbm9taWFsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IF90aGlzLm11bHRpbm9taWFsSW50ZXJuYWwocHJvYmFiaWxpdGllcywgbnVtU2FtcGxlcywgc2VlZCk7XG4gICAgICAgICAgICBpZiAob3JpZ1JhbmsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmFzMUQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm9uZUhvdCA9IGZ1bmN0aW9uIChpbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9uVmFsdWUgPT09IHZvaWQgMCkgeyBvblZhbHVlID0gMTsgfVxuICAgICAgICBpZiAob2ZmVmFsdWUgPT09IHZvaWQgMCkgeyBvZmZWYWx1ZSA9IDA7IH1cbiAgICAgICAgaWYgKGRlcHRoIDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gb25lSG90OiBkZXB0aCBtdXN0IGJlID49MiwgYnV0IGl0IGlzIFwiICsgZGVwdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnb25lSG90JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25lSG90SW50ZXJuYWwoaW5kaWNlcywgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubW9tZW50cyA9IGZ1bmN0aW9uICh4LCBheGlzLCBrZWVwRGltcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGF4ZXMgPSBheGlzX3V0aWwucGFyc2VBeGlzUGFyYW0oYXhpcywgeC5zaGFwZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZWFuID0gX3RoaXMubWVhbih4LCBheGVzLCBrZWVwRGltcyk7XG4gICAgICAgICAgICB2YXIga2VlcERpbXNTaGFwZSA9IG1lYW4uc2hhcGU7XG4gICAgICAgICAgICBpZiAoIWtlZXBEaW1zKSB7XG4gICAgICAgICAgICAgICAga2VlcERpbXNTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShtZWFuLnNoYXBlLCBheGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkZXZTcXVhcmVkID0gX3RoaXMuc3F1YXJlKF90aGlzLnN1YnRyYWN0KHgsIG1lYW4ucmVzaGFwZShrZWVwRGltc1NoYXBlKSkpO1xuICAgICAgICAgICAgdmFyIHZhcmlhbmNlID0gX3RoaXMubWVhbihkZXZTcXVhcmVkLCBheGVzLCBrZWVwRGltcyk7XG4gICAgICAgICAgICByZXR1cm4geyBtZWFuOiBtZWFuLCB2YXJpYW5jZTogdmFyaWFuY2UgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gTkRBcnJheU1hdGg7XG59KCkpO1xuZXhwb3J0cy5OREFycmF5TWF0aCA9IE5EQXJyYXlNYXRoO1xudmFyIE1hdHJpeE9yaWVudGF0aW9uO1xuKGZ1bmN0aW9uIChNYXRyaXhPcmllbnRhdGlvbikge1xuICAgIE1hdHJpeE9yaWVudGF0aW9uW01hdHJpeE9yaWVudGF0aW9uW1wiUkVHVUxBUlwiXSA9IDBdID0gXCJSRUdVTEFSXCI7XG4gICAgTWF0cml4T3JpZW50YXRpb25bTWF0cml4T3JpZW50YXRpb25bXCJUUkFOU1BPU0VEXCJdID0gMV0gPSBcIlRSQU5TUE9TRURcIjtcbn0pKE1hdHJpeE9yaWVudGF0aW9uID0gZXhwb3J0cy5NYXRyaXhPcmllbnRhdGlvbiB8fCAoZXhwb3J0cy5NYXRyaXhPcmllbnRhdGlvbiA9IHt9KSk7XG5mdW5jdGlvbiBwYXJzZVR1cGxlUGFyYW0ocGFyYW0pIHtcbiAgICByZXR1cm4gdHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyA/IFtwYXJhbSwgcGFyYW1dIDogcGFyYW07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2VlZHJhbmRvbSA9IHJlcXVpcmUoXCJzZWVkcmFuZG9tXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBheGlzX3V0aWwgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciBjb25jYXRfdXRpbCA9IHJlcXVpcmUoXCIuL2NvbmNhdF91dGlsXCIpO1xudmFyIGNvbnZfdXRpbCA9IHJlcXVpcmUoXCIuL2NvbnZfdXRpbFwiKTtcbnZhciBjb3B5MkRfdXRpbCA9IHJlcXVpcmUoXCIuL2NvcHkyZF91dGlsXCIpO1xudmFyIG1hdGhfMSA9IHJlcXVpcmUoXCIuL21hdGhcIik7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbmRhcnJheVwiKTtcbnZhciBOREFycmF5TWF0aENQVSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5EQXJyYXlNYXRoQ1BVLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5EQXJyYXlNYXRoQ1BVKHNhZmVNb2RlKSB7XG4gICAgICAgIGlmIChzYWZlTW9kZSA9PT0gdm9pZCAwKSB7IHNhZmVNb2RlID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNhZmVNb2RlKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY2xvbmVJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuZ2V0VmFsdWVzKCkpIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnNsaWNlMURJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHMgPSBpbnB1dC5nZXRWYWx1ZXMoKS5zbGljZShiZWdpbiwgYmVnaW4gKyBzaXplKTtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5BcnJheTFELm5ldyhuZXdWYWxzKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zbGljZTJESW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuQXJyYXkyRC56ZXJvcyhzaXplKTtcbiAgICAgICAgdmFyIHN0YXJ0SSA9IGJlZ2luWzBdLCBzdGFydEogPSBiZWdpblsxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplWzBdOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2l6ZVsxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGlucHV0LmdldChpICsgc3RhcnRJLCBqICsgc3RhcnRKKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHZhbCwgaSwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zbGljZTNESW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuQXJyYXkzRC56ZXJvcyhzaXplKTtcbiAgICAgICAgdmFyIHN0YXJ0SSA9IGJlZ2luWzBdLCBzdGFydEogPSBiZWdpblsxXSwgc3RhcnRLID0gYmVnaW5bMl07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVswXTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNpemVbMV07ICsraikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2l6ZVsyXTsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBpbnB1dC5nZXQoaSArIHN0YXJ0SSwgaiArIHN0YXJ0SiwgayArIHN0YXJ0Syk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQodmFsLCBpLCBqLCBrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zbGljZTRESW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuQXJyYXk0RC56ZXJvcyhzaXplKTtcbiAgICAgICAgdmFyIHN0YXJ0SSA9IGJlZ2luWzBdLCBzdGFydEogPSBiZWdpblsxXSwgc3RhcnRLID0gYmVnaW5bMl0sIHN0YXJ0TCA9IGJlZ2luWzNdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVbMF07ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaXplWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNpemVbMl07ICsraykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHNpemVbM107ICsrbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGlucHV0LmdldChpICsgc3RhcnRJLCBqICsgc3RhcnRKLCBrICsgc3RhcnRLLCBsICsgc3RhcnRMKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQodmFsLCBpLCBqLCBrLCBsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvcHkyREludGVybmFsID0gZnVuY3Rpb24gKHNvdXJjZSwgc291cmNlQmVnaW5Sb3dDb2wsIHNvdXJjZVNpemVSb3dDb2wsIGRlc3QsIGRlc3RCZWdpblJvd0NvbCwgZGVzdFNpemVSb3dDb2wpIHtcbiAgICAgICAgY29weTJEX3V0aWwudmFsaWRhdGVTaGFwZXMoc291cmNlU2l6ZVJvd0NvbCwgZGVzdFNpemVSb3dDb2wpO1xuICAgICAgICB2YXIgc3JjVmFsdWVzID0gc291cmNlLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgZHN0VmFsdWVzID0gZGVzdC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIG4gPSBzb3VyY2VTaXplUm93Q29sWzBdICogc291cmNlU2l6ZVJvd0NvbFsxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzcmNSb3cgPSBzb3VyY2VCZWdpblJvd0NvbFswXSArIE1hdGguZmxvb3IoaSAvIHNvdXJjZVNpemVSb3dDb2xbMV0pO1xuICAgICAgICAgICAgdmFyIHNyY0NvbCA9IHNvdXJjZUJlZ2luUm93Q29sWzFdICsgKGkgJSBzb3VyY2VTaXplUm93Q29sWzFdKTtcbiAgICAgICAgICAgIHZhciBzcmNPZmYgPSBzcmNSb3cgKiBzb3VyY2Uuc2hhcGVbMV0gKyBzcmNDb2w7XG4gICAgICAgICAgICB2YXIgZHN0Um93ID0gZGVzdEJlZ2luUm93Q29sWzBdICsgTWF0aC5mbG9vcihpIC8gZGVzdFNpemVSb3dDb2xbMV0pO1xuICAgICAgICAgICAgdmFyIGRzdENvbCA9IGRlc3RCZWdpblJvd0NvbFsxXSArIChpICUgZGVzdFNpemVSb3dDb2xbMV0pO1xuICAgICAgICAgICAgdmFyIGRzdE9mZiA9IGRzdFJvdyAqIGRlc3Quc2hhcGVbMV0gKyBkc3RDb2w7XG4gICAgICAgICAgICBkc3RWYWx1ZXNbZHN0T2ZmXSA9IHNyY1ZhbHVlc1tzcmNPZmZdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY29uY2F0MURJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGNvbmNhdF91dGlsLmNvbXB1dGVPdXRTaGFwZShhLnNoYXBlLCBiLnNoYXBlLCAwKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5BcnJheTFELnplcm9zKG91dFNoYXBlKTtcbiAgICAgICAgdmFyIGFWYWxzID0gYS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGJWYWxzID0gYi5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhbHMuc2V0KGFWYWxzLCAwKTtcbiAgICAgICAgdmFscy5zZXQoYlZhbHMsIGEuc2l6ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY29uY2F0MkRJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiLCBheGlzKSB7XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGNvbmNhdF91dGlsLmNvbXB1dGVPdXRTaGFwZShhLnNoYXBlLCBiLnNoYXBlLCBheGlzKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5BcnJheTJELnplcm9zKG91dFNoYXBlKTtcbiAgICAgICAgaWYgKGF4aXMgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBhVmFscyA9IGEuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICB2YXIgYlZhbHMgPSBiLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICB2YWxzLnNldChhVmFscywgMCk7XG4gICAgICAgICAgICB2YWxzLnNldChiVmFscywgYS5zaXplKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRTaGFwZVswXTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG91dFNoYXBlWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBbaSwgal07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleFtheGlzXSA8IGEuc2hhcGVbYXhpc10pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhLmdldChpLCBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4W2F4aXNdIC09IGEuc2hhcGVbYXhpc107XG4gICAgICAgICAgICAgICAgICAgIHZhciBpMiA9IGluZGV4WzBdLCBqMiA9IGluZGV4WzFdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGIuZ2V0KGkyLCBqMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQodmFsdWUsIGksIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY29uY2F0M0RJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiLCBheGlzKSB7XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGNvbmNhdF91dGlsLmNvbXB1dGVPdXRTaGFwZShhLnNoYXBlLCBiLnNoYXBlLCBheGlzKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5BcnJheTNELnplcm9zKG91dFNoYXBlKTtcbiAgICAgICAgaWYgKGF4aXMgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBhVmFscyA9IGEuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICB2YXIgYlZhbHMgPSBiLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICB2YWxzLnNldChhVmFscywgMCk7XG4gICAgICAgICAgICB2YWxzLnNldChiVmFscywgYS5zaXplKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRTaGFwZVswXTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG91dFNoYXBlWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dFNoYXBlWzJdOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gW2ksIGosIGtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleFtheGlzXSA8IGEuc2hhcGVbYXhpc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYS5nZXQoaSwgaiwgayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFtheGlzXSAtPSBhLnNoYXBlW2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkyID0gaW5kZXhbMF0sIGoyID0gaW5kZXhbMV0sIGsyID0gaW5kZXhbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGIuZ2V0KGkyLCBqMiwgazIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQodmFsdWUsIGksIGosIGspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvbmNhdDRESW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYiwgYXhpcykge1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuQXJyYXk0RC56ZXJvcyhvdXRTaGFwZSk7XG4gICAgICAgIGlmIChheGlzID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgYVZhbHMgPSBhLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFyIGJWYWxzID0gYi5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFscy5zZXQoYVZhbHMsIDApO1xuICAgICAgICAgICAgdmFscy5zZXQoYlZhbHMsIGEuc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0U2hhcGVbMF07ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdXRTaGFwZVsxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXRTaGFwZVsyXTsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgb3V0U2hhcGVbM107ICsrbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gW2ksIGosIGssIGxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4W2F4aXNdIDwgYS5zaGFwZVtheGlzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYS5nZXQoaSwgaiwgaywgbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFtheGlzXSAtPSBhLnNoYXBlW2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpMiA9IGluZGV4WzBdLCBqMiA9IGluZGV4WzFdLCBrMiA9IGluZGV4WzJdLCBsMiA9IGluZGV4WzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYi5nZXQoaTIsIGoyLCBrMiwgbDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldCh2YWx1ZSwgaSwgaiwgaywgbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zY2FsZWRBcnJheUFkZEludGVybmFsID0gZnVuY3Rpb24gKGMxLCBhLCBjMiwgYikge1xuICAgICAgICB2YXIgYzFWYWwgPSBjMS5nZXQoKTtcbiAgICAgICAgdmFyIGMyVmFsID0gYzIuZ2V0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Zsb2F0MzInLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGMxVmFsICogYVZhbCArIGMyVmFsICogYlZhbDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUubmVnSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsYXJUaW1lc0FycmF5KG5kYXJyYXlfMS5TY2FsYXIuTkVHX09ORSwgYSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuYWRkSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZWRBcnJheUFkZEludGVybmFsKG5kYXJyYXlfMS5TY2FsYXIuT05FLCBhLCBuZGFycmF5XzEuU2NhbGFyLk9ORSwgYik7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc3VidHJhY3RJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlZEFycmF5QWRkSW50ZXJuYWwobmRhcnJheV8xLlNjYWxhci5PTkUsIGEsIG5kYXJyYXlfMS5TY2FsYXIuTkVHX09ORSwgYik7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUubWF0TXVsSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYiwgYU9yaWVudGF0aW9uLCBiT3JpZW50YXRpb24pIHtcbiAgICAgICAgaWYgKGFPcmllbnRhdGlvbiA9PT0gdm9pZCAwKSB7IGFPcmllbnRhdGlvbiA9IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSOyB9XG4gICAgICAgIGlmIChiT3JpZW50YXRpb24gPT09IHZvaWQgMCkgeyBiT3JpZW50YXRpb24gPSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUjsgfVxuICAgICAgICB2YXIgc2hhcmVkRGltID0gKGFPcmllbnRhdGlvbiA9PT0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID8gYS5zaGFwZVsxXSA6IGEuc2hhcGVbMF07XG4gICAgICAgIHZhciBsZWZ0RGltID0gKGFPcmllbnRhdGlvbiA9PT0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID8gYS5zaGFwZVswXSA6IGEuc2hhcGVbMV07XG4gICAgICAgIHZhciByaWdodERpbSA9IChiT3JpZW50YXRpb24gPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGIuc2hhcGVbMV0gOiBiLnNoYXBlWzBdO1xuICAgICAgICB2YXIgbm9ybWFsR2V0dGVyID0gZnVuY3Rpb24gKG1hdHJpeCwgaSwgaikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeC5nZXQoaSwgaik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0cmFuc3Bvc2VkR2V0dGVyID0gZnVuY3Rpb24gKG1hdHJpeCwgaSwgaikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeC5nZXQoaiwgaSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhR2V0dGVyID0gKGFPcmllbnRhdGlvbiA9PT0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID9cbiAgICAgICAgICAgIG5vcm1hbEdldHRlciA6XG4gICAgICAgICAgICB0cmFuc3Bvc2VkR2V0dGVyO1xuICAgICAgICB2YXIgYkdldHRlciA9IChiT3JpZW50YXRpb24gPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/XG4gICAgICAgICAgICBub3JtYWxHZXR0ZXIgOlxuICAgICAgICAgICAgdHJhbnNwb3NlZEdldHRlcjtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobGVmdERpbSAqIHJpZ2h0RGltKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0RGltOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmlnaHREaW07ICsraikge1xuICAgICAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2hhcmVkRGltOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGFHZXR0ZXIoYSwgaSwgaykgKiBiR2V0dGVyKGIsIGssIGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZXNbaW5kZXgrK10gPSBzdW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5BcnJheTJELm5ldyhbbGVmdERpbSwgcmlnaHREaW1dLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLm11bHRpcGx5SW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodXRpbC5zaXplRnJvbVNoYXBlKG5ld1NoYXBlKSk7XG4gICAgICAgIHZhciBhVmFsdWVzID0gYS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGJWYWx1ZXMgPSBiLmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1ZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gYVZhbHVlc1tpICUgYS5zaXplXSAqIGJWYWx1ZXNbaSAlIGIuc2l6ZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmV3U2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuZGl2aWRlSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodXRpbC5zaXplRnJvbVNoYXBlKG5ld1NoYXBlKSk7XG4gICAgICAgIHZhciBhVmFsdWVzID0gYS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGJWYWx1ZXMgPSBiLmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1ZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gYVZhbHVlc1tpICUgYS5zaXplXSAvIGJWYWx1ZXNbaSAlIGIuc2l6ZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmV3U2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSwgJ2Zsb2F0MzInKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zdW1JbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ3N1bScsIGF4ZXMsIGlucHV0LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhpbnB1dC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciByZXN1bHREdHlwZSA9IG1hdGhfMS5TdW1UeXBlc01hcFtpbnB1dC5kdHlwZV07XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhvdXRTaGFwZSwgcmVzdWx0RHR5cGUpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgYVZhbHMgPSBpbnB1dC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVkdWNlU2l6ZTsgKytqKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsc1tpXSA9IHN1bTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmFyZ01pbkludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYXJnTWluJywgYXhlcywgaW5wdXQucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGlucHV0LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG91dFNoYXBlLCAnaW50MzInKTtcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGFWYWxzID0gaW5wdXQuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkgKiByZWR1Y2VTaXplO1xuICAgICAgICAgICAgdmFyIG1pbiA9IGFWYWxzW29mZnNldF07XG4gICAgICAgICAgICB2YXIgbWluSW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWR1Y2VTaXplOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhVmFsc1tvZmZzZXQgKyBqXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gdXRpbC5OQU5fSU5UMzI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxzW2ldID0gbWluSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5hcmdNYXhJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ2FyZ01heCcsIGF4ZXMsIGlucHV0LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhpbnB1dC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhvdXRTaGFwZSwgJ2ludDMyJyk7XG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIHZhbHMgPSByZXN1bHQuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBhVmFscyA9IGlucHV0LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpICogcmVkdWNlU2l6ZTtcbiAgICAgICAgICAgIHZhciBtYXggPSBhVmFsc1tvZmZzZXRdO1xuICAgICAgICAgICAgdmFyIG1heEluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVkdWNlU2l6ZTsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYVZhbHNbb2Zmc2V0ICsgal07XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXhJbmRleCA9IHV0aWwuTkFOX0lOVDMyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsc1tpXSA9IG1heEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuZXF1YWxJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Jvb2wnLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNWYWxOYU4oYVZhbCwgYS5kdHlwZSkgfHwgdXRpbC5pc1ZhbE5hTihiVmFsLCBiLmR0eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLmdldE5hTignYm9vbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhVmFsID09PSBiVmFsKSA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS50b3BLSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSwgaykge1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIHZhbHVlc0FuZEluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc0FuZEluZGljZXMucHVzaCh7IHZhbHVlOiB2YWx1ZXNbaV0sIGluZGV4OiBpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc0FuZEluZGljZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHRvcGtWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGspO1xuICAgICAgICB2YXIgdG9wa0luZGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KGspO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgICAgICAgdG9wa1ZhbHVlc1tpXSA9IHZhbHVlc0FuZEluZGljZXNbaV0udmFsdWU7XG4gICAgICAgICAgICB0b3BrSW5kaWNlc1tpXSA9IHZhbHVlc0FuZEluZGljZXNbaV0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsdWVzOiBuZGFycmF5XzEuQXJyYXkxRC5uZXcodG9wa1ZhbHVlcyksIGluZGljZXM6IG5kYXJyYXlfMS5BcnJheTFELm5ldyh0b3BrSW5kaWNlcykgfTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5taW5JbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ21pbicsIGF4ZXMsIGlucHV0LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhpbnB1dC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhvdXRTaGFwZSwgaW5wdXQuZHR5cGUpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgYVZhbHMgPSBpbnB1dC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgbWluID0gYVZhbHNbMF07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxzW2ldID0gbWluO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUubWF4SW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdtYXgnLCBheGVzLCBpbnB1dC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoaW5wdXQuc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mob3V0U2hhcGUsIGlucHV0LmR0eXBlKTtcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGFWYWxzID0gaW5wdXQuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkgKiByZWR1Y2VTaXplO1xuICAgICAgICAgICAgdmFyIG1heCA9IGFWYWxzW29mZnNldF07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxzW2ldID0gbWF4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY2VpbEludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5jZWlsKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5mbG9vckludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5mbG9vcih2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuZXhwSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLmV4cCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUubG9nSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLmxvZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zcXJ0SW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLnNxcnQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc3F1YXJlSW50ZXJuYWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSB2YWx1ZSAqIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiBuZXdWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUucmVsdUludGVybmFsID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHZhciByZXMgPSBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhpbnB1dC5zaGFwZSwgaW5wdXQuZHR5cGUpO1xuICAgICAgICB2YXIgcmVzVmFscyA9IHJlcy5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGluVmFscyA9IGlucHV0LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluVmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGluVmFsc1tpXTtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVmFsTmFOKHZhbCwgaW5wdXQuZHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzVmFsc1tpXSA9IHV0aWwuZ2V0TmFOKHJlcy5kdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNWYWxzW2ldID0gTWF0aC5tYXgoMCwgaW5WYWxzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmVsdUludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKHYgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSAoTWF0aC5leHAodikgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmxlYWt5UmVsdUludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXksIGFscGhhKSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmICh2ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gYWxwaGEgKiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY2xpcEludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXksIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZhbHVlc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuYWJzSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguYWJzKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zaWdtb2lkSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IDEgLyAoMSArIE1hdGguZXhwKC12YWx1ZXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnNpbkludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLnNpbih2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY29zSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguY29zKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS50YW5JbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC50YW4odmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmFzaW5JbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hc2luKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5hY29zSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguYWNvcyh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuYXRhbkludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmF0YW4odmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnNpbmhJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5zaW5oKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb3NoSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguY29zaCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUudGFuaEludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB1dGlsLnRhbmgodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnN0ZXBJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5LCBhbHBoYSkge1xuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDA7IH1cbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB2YWx1ZSA+IDAgPyAxIDogKHZhbHVlIDwgMCA/IGFscGhhIDogdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY29udjJkSW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgZmlsdGVyLCBiaWFzLCBjb252SW5mbykge1xuICAgICAgICB2YXIgX2EgPSB4LnNoYXBlLCB4Um93cyA9IF9hWzBdLCB4Q29scyA9IF9hWzFdLCBpbnB1dERlcHRoID0gX2FbMl07XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBmaWx0ZXIuc2hhcGVbMF07XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGZpbHRlci5zaGFwZVsxXTtcbiAgICAgICAgdmFyIG91dERlcHRoID0gZmlsdGVyLnNoYXBlWzNdO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgeSA9IG5kYXJyYXlfMS5BcnJheTNELnplcm9zKGNvbnZJbmZvLm91dFNoYXBlKTtcbiAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IG91dERlcHRoOyArK2QyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB5UiA9IDA7IHlSIDwgeS5zaGFwZVswXTsgKyt5Uikge1xuICAgICAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHlSICogY29udkluZm8uc3RyaWRlSGVpZ2h0IC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgeFJNaW4gPSBNYXRoLm1heCgwLCB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgdmFyIHhSTWF4ID0gTWF0aC5taW4oeFJvd3MsIGZpbHRlckhlaWdodCArIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IDA7IHlDIDwgeS5zaGFwZVsxXTsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB5QyAqIGNvbnZJbmZvLnN0cmlkZVdpZHRoIC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENNaW4gPSBNYXRoLm1heCgwLCB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q01heCA9IE1hdGgubWluKHhDb2xzLCBmaWx0ZXJXaWR0aCArIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4UiA9IHhSTWluOyB4UiA8IHhSTWF4OyArK3hSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd1IgPSB4UiAtIHhSQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeEMgPSB4Q01pbjsgeEMgPCB4Q01heDsgKyt4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3QyA9IHhDIC0geENDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGlucHV0RGVwdGg7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0geC5nZXQoeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBmaWx0ZXIuZ2V0KHdSLCB3QywgZDEsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIHdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpYXNWYWwgPSAoYmlhcyAhPSBudWxsKSA/IGJpYXMuZ2V0KGQyKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHkuc2V0KGRvdFByb2QgKyBiaWFzVmFsLCB5UiwgeUMsIGQyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY29udjJkRGVySW5wdXRJbnRlcm5hbCA9IGZ1bmN0aW9uIChkeSwgZmlsdGVyLCBjb252SW5mbykge1xuICAgICAgICB2YXIgaW5EZXB0aCA9IGZpbHRlci5zaGFwZVsyXTtcbiAgICAgICAgdmFyIG91dERlcHRoID0gZmlsdGVyLnNoYXBlWzNdO1xuICAgICAgICB2YXIgeVJvd3MgPSBkeS5zaGFwZVswXTtcbiAgICAgICAgdmFyIHlDb2xzID0gZHkuc2hhcGVbMV07XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBmaWx0ZXIuc2hhcGVbMF07XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGZpbHRlci5zaGFwZVsxXTtcbiAgICAgICAgdmFyIHRvcFBhZCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIGxlZnRQYWQgPSBmaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZHggPSBuZGFycmF5XzEuQXJyYXkzRC56ZXJvcyhjb252SW5mby5pblNoYXBlKTtcbiAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGluRGVwdGg7ICsrZDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHhSID0gMDsgeFIgPCBkeC5zaGFwZVswXTsgKyt4Uikge1xuICAgICAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHhSIC0gbGVmdFBhZDtcbiAgICAgICAgICAgICAgICB2YXIgeFJNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoeFJDb3JuZXIgLyBzdHJpZGVIZWlnaHQpKTtcbiAgICAgICAgICAgICAgICB2YXIgeVJNYXggPSBNYXRoLm1pbih5Um93cywgKGZpbHRlckhlaWdodCArIHhSQ29ybmVyKSAvIHN0cmlkZUhlaWdodCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeEMgPSAwOyB4QyA8IGR4LnNoYXBlWzFdOyArK3hDKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHhDIC0gdG9wUGFkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeENNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoeENDb3JuZXIgLyBzdHJpZGVXaWR0aCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeUNNYXggPSBNYXRoLm1pbih5Q29scywgKGZpbHRlcldpZHRoICsgeENDb3JuZXIpIC8gc3RyaWRlV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlSID0geFJNaW47IHlSIDwgeVJNYXg7ICsreVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3UiA9IHlSICogc3RyaWRlSGVpZ2h0IC0geFJDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IHhDTWluOyB5QyA8IHlDTWF4OyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdDID0geUMgKiBzdHJpZGVXaWR0aCAtIHhDQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQyID0gMDsgZDIgPCBvdXREZXB0aDsgKytkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBkeS5nZXQoeVIsIHlDLCBkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBmaWx0ZXIuZ2V0KGZpbHRlckhlaWdodCAtIDEgLSB3UiwgZmlsdGVyV2lkdGggLSAxIC0gd0MsIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGR4LnNldChkb3RQcm9kLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR4O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvbnYyZERlckZpbHRlckludGVybmFsID0gZnVuY3Rpb24gKHgsIGRZLCBjb252SW5mbykge1xuICAgICAgICB2YXIgaW5wdXREZXB0aCA9IHguc2hhcGVbMl07XG4gICAgICAgIHZhciBvdXRwdXREZXB0aCA9IGRZLnNoYXBlWzJdO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciB3ZWlnaHRzU2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVdlaWdodHNTaGFwZTREKGlucHV0RGVwdGgsIG91dHB1dERlcHRoLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoKTtcbiAgICAgICAgdmFyIGRXID0gbmRhcnJheV8xLkFycmF5NEQuemVyb3Mod2VpZ2h0c1NoYXBlKTtcbiAgICAgICAgdmFyIHlOdW1Sb3dzID0gZFkuc2hhcGVbMF07XG4gICAgICAgIHZhciB5TnVtQ29scyA9IGRZLnNoYXBlWzFdO1xuICAgICAgICB2YXIgeE51bVJvd3MgPSB4LnNoYXBlWzBdO1xuICAgICAgICB2YXIgeE51bUNvbHMgPSB4LnNoYXBlWzFdO1xuICAgICAgICB2YXIgbGVmdFBhZCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHRvcFBhZCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICBmb3IgKHZhciB3UiA9IDA7IHdSIDwgZmlsdGVySGVpZ2h0OyArK3dSKSB7XG4gICAgICAgICAgICB2YXIgeVJNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHRvcFBhZCAtIHdSKSAvIHN0cmlkZUhlaWdodCkpO1xuICAgICAgICAgICAgdmFyIHlSTWF4ID0gTWF0aC5taW4oeU51bVJvd3MsICh4TnVtUm93cyArIHRvcFBhZCAtIHdSKSAvIHN0cmlkZUhlaWdodCk7XG4gICAgICAgICAgICBmb3IgKHZhciB3QyA9IDA7IHdDIDwgZmlsdGVyV2lkdGg7ICsrd0MpIHtcbiAgICAgICAgICAgICAgICB2YXIgeUNNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGxlZnRQYWQgLSB3QykgLyBzdHJpZGVXaWR0aCkpO1xuICAgICAgICAgICAgICAgIHZhciB5Q01heCA9IE1hdGgubWluKHlOdW1Db2xzLCAoeE51bUNvbHMgKyBsZWZ0UGFkIC0gd0MpIC8gc3RyaWRlV2lkdGgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGQxID0gMDsgZDEgPCBpbnB1dERlcHRoOyArK2QxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQyID0gMDsgZDIgPCBvdXRwdXREZXB0aDsgKytkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeVIgPSB5Uk1pbjsgeVIgPCB5Uk1heDsgKyt5Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4UiA9IHdSICsgeVIgKiBzdHJpZGVIZWlnaHQgLSB0b3BQYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSB5Q01pbjsgeUMgPCB5Q01heDsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeEMgPSB3QyArIHlDICogc3RyaWRlV2lkdGggLSBsZWZ0UGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHguZ2V0KHhSLCB4QywgZDEpICogZFkuZ2V0KHlSLCB5QywgZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRXLnNldChkb3RQcm9kLCB3Uiwgd0MsIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRXO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvbnYyZERlckJpYXNJbnRlcm5hbCA9IGZ1bmN0aW9uIChkWSkge1xuICAgICAgICB2YXIgb3V0cHV0RGVwdGggPSBkWS5zaGFwZVsyXTtcbiAgICAgICAgdmFyIG51bVJvd3MgPSBkWS5zaGFwZVswXTtcbiAgICAgICAgdmFyIG51bUNvbHMgPSBkWS5zaGFwZVsxXTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkob3V0cHV0RGVwdGgpO1xuICAgICAgICBmb3IgKHZhciBkMiA9IDA7IGQyIDwgb3V0cHV0RGVwdGg7ICsrZDIpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBudW1Sb3dzOyArK3IpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG51bUNvbHM7ICsrYykge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gZFkuZ2V0KHIsIGMsIGQyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXNbZDJdID0gc3VtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuQXJyYXkxRC5uZXcodmFsdWVzKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkRJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgZmlsdGVyLCBjb252SW5mbykge1xuICAgICAgICB2YXIgX2EgPSBjb252SW5mby5pblNoYXBlLCBudW1CYXRjaGVzID0gX2FbMF0sIHhSb3dzID0gX2FbMV0sIHhDb2xzID0gX2FbMl0sIGluQ2hhbm5lbHMgPSBfYVszXTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciB5Um93cyA9IGNvbnZJbmZvLm91dFNoYXBlWzFdO1xuICAgICAgICB2YXIgeUNvbHMgPSBjb252SW5mby5vdXRTaGFwZVsyXTtcbiAgICAgICAgdmFyIGNoTXVsID0gY29udkluZm8uY2hhbm5lbE11bDtcbiAgICAgICAgdmFyIHkgPSBuZGFycmF5XzEuQXJyYXk0RC56ZXJvcyhjb252SW5mby5vdXRTaGFwZSk7XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgbnVtQmF0Y2hlczsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkMSA9IDA7IGQxIDwgaW5DaGFubmVsczsgKytkMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHlSID0gMDsgeVIgPCB5Um93czsgKyt5Uikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJDb3JuZXIgPSB5UiAqIGNvbnZJbmZvLnN0cmlkZUhlaWdodCAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSTWF4ID0gTWF0aC5taW4oeFJvd3MsIGZpbHRlckhlaWdodCArIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSAwOyB5QyA8IHlDb2xzOyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB5QyAqIGNvbnZJbmZvLnN0cmlkZVdpZHRoIC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWluID0gTWF0aC5tYXgoMCwgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWF4ID0gTWF0aC5taW4oeENvbHMsIGZpbHRlcldpZHRoICsgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcSA9IDA7IHEgPCBjaE11bDsgKytxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhSID0geFJNaW47IHhSIDwgeFJNYXg7ICsreFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdSID0geFIgLSB4UkNvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeEMgPSB4Q01pbjsgeEMgPCB4Q01heDsgKyt4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdDID0geEMgLSB4Q0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGlucHV0LmdldChiLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBmaWx0ZXIuZ2V0KHdSLCB3QywgZDEsIHEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIHdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5LnNldChkb3RQcm9kLCBiLCB5UiwgeUMsIGQxICogY2hNdWwgKyBxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS50aWxlSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgcmVwcykge1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSBuZXcgQXJyYXkoYS5yYW5rKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3U2hhcGVbaV0gPSBhLnNoYXBlW2ldICogcmVwc1tpXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHR5cGU7XG4gICAgICAgIGlmIChhLmR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgIGR0eXBlID0gRmxvYXQzMkFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgICAgIGR0eXBlID0gSW50MzJBcnJheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgIGR0eXBlID0gVWludDhBcnJheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR0eXBlIFwiICsgYS5kdHlwZSArIFwiIG5vdCBzdXBwb3J0ZWQgZm9yIHRpbGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBkdHlwZSh1dGlsLnNpemVGcm9tU2hhcGUobmV3U2hhcGUpKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmV3U2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSwgYS5kdHlwZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBhLmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5zaXplOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuZXdMb2MgPSByZXN1bHQuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbExvYyA9IG5ldyBBcnJheShhLnJhbmspO1xuICAgICAgICAgICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgb3JpZ2luYWxMb2MubGVuZ3RoOyBpXzErKykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsTG9jW2lfMV0gPSBuZXdMb2NbaV8xXSAlIGEuc2hhcGVbaV8xXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEluZGV4ID0gYS5sb2NUb0luZGV4KG9yaWdpbmFsTG9jKTtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHZhbHVlc1tvcmlnaW5hbEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnRyYW5zcG9zZUludGVybmFsID0gZnVuY3Rpb24gKGEsIHBlcm0pIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gbmV3IEFycmF5KGEucmFuayk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld1NoYXBlW2ldID0gYS5zaGFwZVtwZXJtW2ldXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShhLnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gYS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmV3U2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5zaXplOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSBhLmluZGV4VG9Mb2MoaSk7XG4gICAgICAgICAgICB2YXIgbmV3TG9jID0gbmV3IEFycmF5KGxvYy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaV8yID0gMDsgaV8yIDwgbmV3TG9jLmxlbmd0aDsgaV8yKyspIHtcbiAgICAgICAgICAgICAgICBuZXdMb2NbaV8yXSA9IGxvY1twZXJtW2lfMl1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld0luZGV4ID0gcmVzdWx0LmxvY1RvSW5kZXgobmV3TG9jKTtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tuZXdJbmRleF0gPSB2YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5wb29sID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvLCBwb29sVHlwZSkge1xuICAgICAgICB2YXIgX2EgPSB4LnNoYXBlLCB4Um93cyA9IF9hWzBdLCB4Q29scyA9IF9hWzFdLCBkZXB0aCA9IF9hWzJdO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciB5ID0gbmRhcnJheV8xLkFycmF5M0QuemVyb3MoY29udkluZm8ub3V0U2hhcGUpO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRlcHRoOyArK2QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHlSID0gMDsgeVIgPCB5LnNoYXBlWzBdOyArK3lSKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geVIgKiBzdHJpZGVIZWlnaHQgLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgdmFyIHhSTWluID0gTWF0aC5tYXgoMCwgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgIHZhciB4Uk1heCA9IE1hdGgubWluKHhSb3dzLCBmaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSAwOyB5QyA8IHkuc2hhcGVbMV07ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geUMgKiBzdHJpZGVXaWR0aCAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWF4ID0gTWF0aC5taW4oeENvbHMsIGZpbHRlcldpZHRoICsgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWluTWF4VmFsdWUgPSAocG9vbFR5cGUgPT09ICdtYXgnID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdmdWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhSID0geFJNaW47IHhSIDwgeFJNYXg7ICsreFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhDID0geENNaW47IHhDIDwgeENNYXg7ICsreEMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB4LmdldCh4UiwgeEMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihwaXhlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSBOYU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2Z1ZhbHVlID0gTmFOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwb29sVHlwZSA9PT0gJ21heCcgJiYgcGl4ZWwgPiBtaW5NYXhWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBvb2xUeXBlID09PSAnbWluJyAmJiBwaXhlbCA8IG1pbk1heFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwb29sVHlwZSA9PT0gJ2F2ZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZnVmFsdWUgKz0gcGl4ZWwgLyAoZmlsdGVySGVpZ2h0ICogZmlsdGVyV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihtaW5NYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5LnNldChwb29sVHlwZSA9PT0gJ2F2ZycgPyBhdmdWYWx1ZSA6IG1pbk1heFZhbHVlLCB5UiwgeUMsIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5tYXhQb29sSW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9vbCh4LCBjb252SW5mbywgJ21heCcpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLm1heFBvb2xQb3NpdGlvbnMgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIF9hID0geC5zaGFwZSwgeFJvd3MgPSBfYVswXSwgeENvbHMgPSBfYVsxXSwgZGVwdGggPSBfYVsyXTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG4gICAgICAgIHZhciBtYXhQb3NpdGlvbnMgPSBuZGFycmF5XzEuQXJyYXkzRC56ZXJvcyhvdXRwdXRTaGFwZSk7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkZXB0aDsgKytkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB5UiA9IDA7IHlSIDwgb3V0cHV0U2hhcGVbMF07ICsreVIpIHtcbiAgICAgICAgICAgICAgICB2YXIgeFJDb3JuZXIgPSB5UiAqIHN0cmlkZUhlaWdodCAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICB2YXIgeFJNaW4gPSBNYXRoLm1heCgwLCB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgdmFyIHhSTWF4ID0gTWF0aC5taW4oeFJvd3MsIGZpbHRlckhlaWdodCArIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IDA7IHlDIDwgb3V0cHV0U2hhcGVbMV07ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geUMgKiBzdHJpZGVXaWR0aCAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWF4ID0gTWF0aC5taW4oeENvbHMsIGZpbHRlcldpZHRoICsgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4VmFsdWUgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhQb3NpdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4UiA9IHhSTWluOyB4UiA8IHhSTWF4OyArK3hSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd1IgPSB4UiAtIHhSQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeEMgPSB4Q01pbjsgeEMgPCB4Q01heDsgKyt4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3QyA9IHhDIC0geENDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0geC5nZXQoeFIsIHhDLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGl4ZWwgPiBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhQb3NpdGlvbiA9IHdSICogZmlsdGVyV2lkdGggKyB3QztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF4UG9zaXRpb25zLnNldChtYXhQb3NpdGlvbiwgeVIsIHlDLCBkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heFBvc2l0aW9ucztcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3BJbnRlcm5hbCA9IGZ1bmN0aW9uIChkeSwgeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIG1heFBvc2l0aW9ucyA9IHRoaXMubWF4UG9vbFBvc2l0aW9ucyh4LCBjb252SW5mbyk7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBmaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBfYSA9IGR5LnNoYXBlLCBkeVJvd3MgPSBfYVswXSwgZHlDb2xzID0gX2FbMV0sIGRlcHRoID0gX2FbMl07XG4gICAgICAgIHZhciBkeCA9IG5kYXJyYXlfMS5BcnJheTNELnplcm9zKHguc2hhcGUpO1xuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRlcHRoOyArK2QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGR4UiA9IDA7IGR4UiA8IGR4LnNoYXBlWzBdOyArK2R4Uikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGR4QyA9IDA7IGR4QyA8IGR4LnNoYXBlWzFdOyArK2R4Qykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHlSQ29ybmVyID0gZHhSIC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHlDQ29ybmVyID0gZHhDIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDA7IHdSIDwgZmlsdGVySGVpZ2h0OyArK3dSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlSID0gKGR5UkNvcm5lciArIHdSKSAvIHN0cmlkZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBkeVJvd3MgfHwgTWF0aC5mbG9vcihkeVIpICE9PSBkeVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeUMgPSAoZHlDQ29ybmVyICsgd0MpIC8gc3RyaWRlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49IGR5Q29scyB8fCBNYXRoLmZsb29yKGR5QykgIT09IGR5Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heFBvcyA9IGZpbHRlckhlaWdodCAqIGZpbHRlcldpZHRoIC0gMSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFBvc2l0aW9ucy5nZXQoZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJQb3MgPSB3UiAqIGZpbHRlcldpZHRoICsgd0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hc2sgPSBtYXhQb3MgPT09IGN1clBvcyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBkeS5nZXQoZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiBtYXNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGR4LnNldChkb3RQcm9kLCBkeFIsIGR4QywgZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkeDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5taW5Qb29sSW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9vbCh4LCBjb252SW5mbywgJ21pbicpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmF2Z1Bvb2xJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb29sKHgsIGNvbnZJbmZvLCAnYXZnJyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUucmVzaXplQmlsaW5lYXIzREludGVybmFsID0gZnVuY3Rpb24gKHgsIG5ld1NoYXBlMkQsIGFsaWduQ29ybmVycykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gbmRhcnJheV8xLkFycmF5M0QuemVyb3MoW25ld1NoYXBlMkRbMF0sIG5ld1NoYXBlMkRbMV0sIHguc2hhcGVbMl1dKTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUlucHV0U2l6ZSA9IGFsaWduQ29ybmVycyA/IFt4LnNoYXBlWzBdIC0gMSwgeC5zaGFwZVsxXSAtIDEsIHguc2hhcGVbMl1dIDogeC5zaGFwZTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZU91dHB1dFNpemUgPSBhbGlnbkNvcm5lcnMgP1xuICAgICAgICAgICAgW291dHB1dC5zaGFwZVswXSAtIDEsIG91dHB1dC5zaGFwZVsxXSAtIDEsIG91dHB1dC5zaGFwZVsyXV0gOlxuICAgICAgICAgICAgb3V0cHV0LnNoYXBlO1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IG91dHB1dC5zaGFwZVswXTsgcisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG91dHB1dC5zaGFwZVsxXTsgYysrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBvdXRwdXQuc2hhcGVbMl07IGQrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlRnJhY1JvdyA9IChlZmZlY3RpdmVJbnB1dFNpemVbMF0pICogciAvIChlZmZlY3RpdmVPdXRwdXRTaXplWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUZyYWNDb2wgPSAoZWZmZWN0aXZlSW5wdXRTaXplWzFdKSAqIGMgLyAoZWZmZWN0aXZlT3V0cHV0U2l6ZVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VSb3dGbG9vciA9IE1hdGguZmxvb3Ioc291cmNlRnJhY1Jvdyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VSb3dDZWlsID0gTWF0aC5taW4oeC5zaGFwZVswXSAtIDEsIE1hdGguY2VpbChzb3VyY2VGcmFjUm93KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VDb2xGbG9vciA9IE1hdGguZmxvb3Ioc291cmNlRnJhY0NvbCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VDb2xDZWlsID0gTWF0aC5taW4oeC5zaGFwZVsxXSAtIDEsIE1hdGguY2VpbChzb3VyY2VGcmFjQ29sKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3BMZWZ0ID0geC5nZXQoc291cmNlUm93Rmxvb3IsIHNvdXJjZUNvbEZsb29yLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbUxlZnQgPSB4LmdldChzb3VyY2VSb3dDZWlsLCBzb3VyY2VDb2xGbG9vciwgZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3BSaWdodCA9IHguZ2V0KHNvdXJjZVJvd0Zsb29yLCBzb3VyY2VDb2xDZWlsLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0geC5nZXQoc291cmNlUm93Q2VpbCwgc291cmNlQ29sQ2VpbCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dGcmFjID0gc291cmNlRnJhY1JvdyAtIHNvdXJjZVJvd0Zsb29yO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sRnJhYyA9IHNvdXJjZUZyYWNDb2wgLSBzb3VyY2VDb2xGbG9vcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcF8xID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogY29sRnJhYztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbSA9IGJvdHRvbUxlZnQgKyAoYm90dG9tUmlnaHQgLSBib3R0b21MZWZ0KSAqIGNvbEZyYWM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRvcF8xICsgKGJvdHRvbSAtIHRvcF8xKSAqIHJvd0ZyYWM7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXQobmV3VmFsdWUsIHIsIGMsIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbjJESW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICB2YXIgeFZhbHVlcyA9IHguZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBtZWFuVmFsdWVzID0gbWVhbi5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIHZhcmlhbmNlVmFsdWVzID0gdmFyaWFuY2UuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBzY2FsZVZhbHVlcyA9IHNjYWxlID8gc2NhbGUuZ2V0VmFsdWVzKCkgOiBuZXcgRmxvYXQzMkFycmF5KFsxXSk7XG4gICAgICAgIHZhciBvZmZzZXRWYWx1ZXMgPSBvZmZzZXQgPyBvZmZzZXQuZ2V0VmFsdWVzKCkgOiBuZXcgRmxvYXQzMkFycmF5KFswXSk7XG4gICAgICAgIHZhciBvdXRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHhWYWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRWYWx1ZXNbaV0gPSBvZmZzZXRWYWx1ZXNbaSAlIG9mZnNldFZhbHVlcy5sZW5ndGhdICtcbiAgICAgICAgICAgICAgICAoeFZhbHVlc1tpXSAtIG1lYW5WYWx1ZXNbaSAlIG1lYW5WYWx1ZXMubGVuZ3RoXSkgKlxuICAgICAgICAgICAgICAgICAgICBzY2FsZVZhbHVlc1tpICUgc2NhbGVWYWx1ZXMubGVuZ3RoXSAvXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc3FydCh2YXJpYW5jZVZhbHVlc1tpICUgdmFyaWFuY2VWYWx1ZXMubGVuZ3RoXSArIHZhcmlhbmNlRXBzaWxvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5BcnJheTJELm5ldyh4LnNoYXBlLCBvdXRWYWx1ZXMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbjNESW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICB2YXIgeFZhbHVlcyA9IHguZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBtZWFuVmFsdWVzID0gbWVhbi5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIHZhcmlhbmNlVmFsdWVzID0gdmFyaWFuY2UuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBzY2FsZVZhbHVlcyA9IHNjYWxlID8gc2NhbGUuZ2V0VmFsdWVzKCkgOiBuZXcgRmxvYXQzMkFycmF5KFsxXSk7XG4gICAgICAgIHZhciBvZmZzZXRWYWx1ZXMgPSBvZmZzZXQgPyBvZmZzZXQuZ2V0VmFsdWVzKCkgOiBuZXcgRmxvYXQzMkFycmF5KFswXSk7XG4gICAgICAgIHZhciBvdXRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHhWYWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRWYWx1ZXNbaV0gPSBvZmZzZXRWYWx1ZXNbaSAlIG9mZnNldFZhbHVlcy5sZW5ndGhdICtcbiAgICAgICAgICAgICAgICAoeFZhbHVlc1tpXSAtIG1lYW5WYWx1ZXNbaSAlIG1lYW5WYWx1ZXMubGVuZ3RoXSkgKlxuICAgICAgICAgICAgICAgICAgICBzY2FsZVZhbHVlc1tpICUgc2NhbGVWYWx1ZXMubGVuZ3RoXSAvXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc3FydCh2YXJpYW5jZVZhbHVlc1tpICUgdmFyaWFuY2VWYWx1ZXMubGVuZ3RoXSArIHZhcmlhbmNlRXBzaWxvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5BcnJheTNELm5ldyh4LnNoYXBlLCBvdXRWYWx1ZXMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLm11bHRpbm9taWFsSW50ZXJuYWwgPSBmdW5jdGlvbiAocHJvYmFiaWxpdGllcywgbnVtU2FtcGxlcywgc2VlZCkge1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gcHJvYmFiaWxpdGllcy5zaGFwZVswXTtcbiAgICAgICAgdmFyIG51bUV2ZW50cyA9IHByb2JhYmlsaXRpZXMuc2hhcGVbMV07XG4gICAgICAgIHZhciByZXMgPSBuZGFycmF5XzEuQXJyYXkyRC56ZXJvcyhbYmF0Y2hTaXplLCBudW1TYW1wbGVzXSwgJ2ludDMyJyk7XG4gICAgICAgIHZhciByZXNWYWxzID0gcmVzLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgcHJvYlZhbHMgPSBwcm9iYWJpbGl0aWVzLmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gYiAqIG51bUV2ZW50cztcbiAgICAgICAgICAgIHZhciBjZGYgPSBuZXcgRmxvYXQzMkFycmF5KG51bUV2ZW50cyAtIDEpO1xuICAgICAgICAgICAgY2RmWzBdID0gcHJvYlZhbHNbb2Zmc2V0XTtcbiAgICAgICAgICAgIGZvciAodmFyIGV2ZW50XzEgPSAxOyBldmVudF8xIDwgY2RmLmxlbmd0aDsgKytldmVudF8xKSB7XG4gICAgICAgICAgICAgICAgY2RmW2V2ZW50XzFdID0gY2RmW2V2ZW50XzEgLSAxXSArIHByb2JWYWxzW29mZnNldCArIGV2ZW50XzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJhbmRvbSA9IHNlZWRyYW5kb20uYWxlYShzZWVkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdmFyIG91dE9mZnNldCA9IGIgKiBudW1TYW1wbGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgc2FtcGxlSWQgPSAwOyBzYW1wbGVJZCA8IG51bVNhbXBsZXM7ICsrc2FtcGxlSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHJhbmRvbSgpO1xuICAgICAgICAgICAgICAgIHJlc1ZhbHNbb3V0T2Zmc2V0ICsgc2FtcGxlSWRdID0gY2RmLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBldmVudF8yID0gMDsgZXZlbnRfMiA8IGNkZi5sZW5ndGg7IGV2ZW50XzIrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAociA8IGNkZltldmVudF8yXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzVmFsc1tvdXRPZmZzZXQgKyBzYW1wbGVJZF0gPSBldmVudF8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5vbmVIb3RJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBGbG9hdDMyQXJyYXkoaW5kaWNlcy5zaXplICogZGVwdGgpO1xuICAgICAgICByZXMuZmlsbChvZmZWYWx1ZSk7XG4gICAgICAgIGZvciAodmFyIGV2ZW50XzMgPSAwOyBldmVudF8zIDwgaW5kaWNlcy5zaXplOyArK2V2ZW50XzMpIHtcbiAgICAgICAgICAgIHJlc1tldmVudF8zICogZGVwdGggKyBpbmRpY2VzLmdldChldmVudF8zKV0gPSBvblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuQXJyYXkyRC5uZXcoW2luZGljZXMuc2l6ZSwgZGVwdGhdLCByZXMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmJyb2FkY2FzdGVkQmluYXJ5T3AgPSBmdW5jdGlvbiAoYSwgYiwgZHR5cGUsIG9wKSB7XG4gICAgICAgIHZhciBuZXdTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLk5EQXJyYXkuemVyb3MobmV3U2hhcGUsIGR0eXBlKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IHJlc3VsdC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGFWYWx1ZXMgPSBhLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgYlZhbHVlcyA9IGIuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBhQnJvYWRjYXN0RGltcyA9IGJyb2FkY2FzdF91dGlsLmdldEJyb2FkY2FzdERpbXMoYS5zaGFwZSwgbmV3U2hhcGUpO1xuICAgICAgICB2YXIgYkJyb2FkY2FzdERpbXMgPSBicm9hZGNhc3RfdXRpbC5nZXRCcm9hZGNhc3REaW1zKGIuc2hhcGUsIG5ld1NoYXBlKTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIGxvYyA9IHJlc3VsdC5pbmRleFRvTG9jKGkpO1xuICAgICAgICAgICAgdmFyIGFMb2MgPSBsb2Muc2xpY2UoLWEucmFuayk7XG4gICAgICAgICAgICBhQnJvYWRjYXN0RGltcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiBhTG9jW2RdID0gMDsgfSk7XG4gICAgICAgICAgICB2YXIgYUluZGV4ID0gYS5sb2NUb0luZGV4KGFMb2MpO1xuICAgICAgICAgICAgdmFyIGJMb2MgPSBsb2Muc2xpY2UoLWIucmFuayk7XG4gICAgICAgICAgICBiQnJvYWRjYXN0RGltcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiBiTG9jW2RdID0gMDsgfSk7XG4gICAgICAgICAgICB2YXIgYkluZGV4ID0gYi5sb2NUb0luZGV4KGJMb2MpO1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gb3AoYVZhbHVlc1thSW5kZXhdLCBiVmFsdWVzW2JJbmRleF0pO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1ZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIE5EQXJyYXlNYXRoQ1BVO1xufShtYXRoXzEuTkRBcnJheU1hdGgpKTtcbmV4cG9ydHMuTkRBcnJheU1hdGhDUFUgPSBOREFycmF5TWF0aENQVTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhfY3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGF4aXNfdXRpbCA9IHJlcXVpcmUoXCIuL2F4aXNfdXRpbFwiKTtcbnZhciBtYXRoXzEgPSByZXF1aXJlKFwiLi9tYXRoXCIpO1xudmFyIG5kYXJyYXkgPSByZXF1aXJlKFwiLi9uZGFycmF5XCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuL25kYXJyYXlcIik7XG52YXIgcmVkdWNlX3V0aWwgPSByZXF1aXJlKFwiLi9yZWR1Y2VfdXRpbFwiKTtcbnZhciBhZGRzY2FsZWRtYXRfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9hZGRzY2FsZWRtYXRfZ3B1XCIpO1xudmFyIGFyZ21pbm1heF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2FyZ21pbm1heF9ncHVcIik7XG52YXIgYmF0Y2hub3JtX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvYmF0Y2hub3JtX2dwdVwiKTtcbnZhciBiaW5hcnlvcF9ncHUgPSByZXF1aXJlKFwiLi93ZWJnbC9iaW5hcnlvcF9ncHVcIik7XG52YXIgYmluYXJ5b3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9iaW5hcnlvcF9ncHVcIik7XG52YXIgY2xpcF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NsaXBfZ3B1XCIpO1xudmFyIGNvbmNhdF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NvbmNhdF9ncHVcIik7XG52YXIgY29udl9iYWNrcHJvcF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NvbnZfYmFja3Byb3BfZ3B1XCIpO1xudmFyIGNvbnZfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb252X2dwdVwiKTtcbnZhciBjb252X2dwdV9kZXB0aHdpc2VfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NvbnZfZ3B1X2RlcHRod2lzZVwiKTtcbnZhciBjb3B5X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvY29weV9ncHVcIik7XG52YXIgZ3BncHVfY29udGV4dF8xID0gcmVxdWlyZShcIi4vd2ViZ2wvZ3BncHVfY29udGV4dFwiKTtcbnZhciBncGdwdV9tYXRoID0gcmVxdWlyZShcIi4vd2ViZ2wvZ3BncHVfbWF0aFwiKTtcbnZhciBncGdwdV91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2wvZ3BncHVfdXRpbFwiKTtcbnZhciBtYXhfcG9vbF9iYWNrcHJvcF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL21heF9wb29sX2JhY2twcm9wX2dwdVwiKTtcbnZhciBtdWxtYXRfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9tdWxtYXRfZ3B1XCIpO1xudmFyIG11bHRpbm9taWFsX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvbXVsdGlub21pYWxfZ3B1XCIpO1xudmFyIG9uZWhvdF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL29uZWhvdF9ncHVcIik7XG52YXIgcG9vbF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3Bvb2xfZ3B1XCIpO1xudmFyIHJlZHVjZV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3JlZHVjZV9ncHVcIik7XG52YXIgcmVzaXplX2JpbGluZWFyX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvcmVzaXplX2JpbGluZWFyX2dwdVwiKTtcbnZhciBzbGljZV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3NsaWNlX2dwdVwiKTtcbnZhciB0ZXh0dXJlX21hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3RleHR1cmVfbWFuYWdlclwiKTtcbnZhciB0aWxlX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvdGlsZV9ncHVcIik7XG52YXIgdHJhbnNwb3NlX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvdHJhbnNwb3NlX2dwdVwiKTtcbnZhciB1bmFyeV9vcCA9IHJlcXVpcmUoXCIuL3dlYmdsL3VuYXJ5b3BfZ3B1XCIpO1xudmFyIHVuYXJ5b3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC91bmFyeW9wX2dwdVwiKTtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2wvd2ViZ2xfdXRpbFwiKTtcbnZhciBOREFycmF5TWF0aEdQVSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5EQXJyYXlNYXRoR1BVLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5EQXJyYXlNYXRoR1BVKGdwZ3B1LCBzYWZlTW9kZSkge1xuICAgICAgICBpZiAoc2FmZU1vZGUgPT09IHZvaWQgMCkgeyBzYWZlTW9kZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNhZmVNb2RlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5iaW5hcnlDYWNoZSA9IHt9O1xuICAgICAgICBpZiAoZ3BncHUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGdsID0gZ3BncHVfdXRpbC5jcmVhdGVXZWJHTENvbnRleHQoKTtcbiAgICAgICAgICAgIF90aGlzLmdwZ3B1ID0gbmV3IGdwZ3B1X2NvbnRleHRfMS5HUEdQVUNvbnRleHQoZ2wpO1xuICAgICAgICAgICAgX3RoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5ncGdwdSA9IGdwZ3B1O1xuICAgICAgICAgICAgX3RoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnRleHR1cmVNYW5hZ2VyID0gbmV3IHRleHR1cmVfbWFuYWdlcl8xLlRleHR1cmVNYW5hZ2VyKF90aGlzLmdwZ3B1KTtcbiAgICAgICAgbmRhcnJheS5pbml0aWFsaXplR1BVKF90aGlzLmdwZ3B1LCBfdGhpcy50ZXh0dXJlTWFuYWdlcik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmdldEdQR1BVQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3BncHU7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY2xvbmVJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciB0ZXhTaGFwZSA9IGEuZ2V0VGV4dHVyZVNoYXBlUkMoKTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGEuYXMyRCh0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV0pO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkodGV4U2hhcGUsIGEuZHR5cGUpO1xuICAgICAgICB0aGlzLmNvcHkyRChzb3VyY2UsIFswLCAwXSwgdGV4U2hhcGUsIG91dHB1dCwgWzAsIDBdLCB0ZXhTaGFwZSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQucmVzaGFwZShhLnNoYXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zbGljZTFESW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHNsaWNlX2dwdV8xLlNsaWNlUHJvZ3JhbShbc2l6ZV0pO1xuICAgICAgICB2YXIgY3VzdG9tU2V0dXAgPSBwcm9ncmFtLmdldEN1c3RvbVNldHVwRnVuYyhbYmVnaW5dKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbaW5wdXRdLCBudWxsLCBjdXN0b21TZXR1cCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc2xpY2UyREludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBzbGljZV9ncHVfMS5TbGljZVByb2dyYW0oc2l6ZSk7XG4gICAgICAgIHZhciBjdXN0b21TZXR1cCA9IHByb2dyYW0uZ2V0Q3VzdG9tU2V0dXBGdW5jKGJlZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbaW5wdXRdLCBudWxsLCBjdXN0b21TZXR1cCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc2xpY2UzREludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBzbGljZV9ncHVfMS5TbGljZVByb2dyYW0oc2l6ZSk7XG4gICAgICAgIHZhciBjdXN0b21TZXR1cCA9IHByb2dyYW0uZ2V0Q3VzdG9tU2V0dXBGdW5jKGJlZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbaW5wdXRdLCBudWxsLCBjdXN0b21TZXR1cCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc2xpY2U0REludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBzbGljZV9ncHVfMS5TbGljZVByb2dyYW0oc2l6ZSk7XG4gICAgICAgIHZhciBjdXN0b21TZXR1cCA9IHByb2dyYW0uZ2V0Q3VzdG9tU2V0dXBGdW5jKGJlZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbaW5wdXRdLCBudWxsLCBjdXN0b21TZXR1cCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29weTJESW50ZXJuYWwgPSBmdW5jdGlvbiAoc291cmNlLCBzb3VyY2VCZWdpblJvd0NvbCwgc291cmNlU2l6ZVJvd0NvbCwgZGVzdCwgZGVzdEJlZ2luUm93Q29sLCBkZXN0U2l6ZVJvd0NvbCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb3B5X2dwdV8xLkNvcHkyRFByb2dyYW0oc291cmNlU2l6ZVJvd0NvbFsxXSwgZGVzdFNpemVSb3dDb2xbMV0pO1xuICAgICAgICB2YXIgY3VzdG9tU2V0dXAgPSBwcm9ncmFtLmdldEN1c3RvbVNldHVwRnVuYyhzb3VyY2VCZWdpblJvd0NvbCwgZGVzdEJlZ2luUm93Q29sLCBkZXN0U2l6ZVJvd0NvbCk7XG4gICAgICAgIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbc291cmNlXSwgZGVzdCwgY3VzdG9tU2V0dXApO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvbmNhdDFESW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb25jYXRfZ3B1XzEuQ29uY2F0UHJvZ3JhbShhLnNoYXBlLCBiLnNoYXBlLCAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvbmNhdDJESW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYiwgYXhpcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb25jYXRfZ3B1XzEuQ29uY2F0UHJvZ3JhbShhLnNoYXBlLCBiLnNoYXBlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvbmNhdDNESW50ZXJuYWwgPSBmdW5jdGlvbiAoeDEsIHgyLCBheGlzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbmNhdF9ncHVfMS5Db25jYXRQcm9ncmFtKHgxLnNoYXBlLCB4Mi5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3gxLCB4Ml0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvbmNhdDRESW50ZXJuYWwgPSBmdW5jdGlvbiAoeDEsIHgyLCBheGlzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbmNhdF9ncHVfMS5Db25jYXRQcm9ncmFtKHgxLnNoYXBlLCB4Mi5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3gxLCB4Ml0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnNjYWxlZEFycmF5QWRkSW50ZXJuYWwgPSBmdW5jdGlvbiAoYzEsIGEsIGMyLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGFkZHNjYWxlZG1hdF9ncHVfMS5BZGRTY2FsZWRNYXRQcm9ncmFtKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiLCBjMSwgYzJdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5uZWdJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuTkVHKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLm1ha2VPdXRwdXRBcnJheSA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIHRleHR1cmVTaGFwZVJDID0gd2ViZ2xfdXRpbC5nZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlKHRoaXMuZ3BncHUuZ2wsIHNoYXBlKTtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKHRleHR1cmVTaGFwZVJDKTtcbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2Uoc2hhcGUsIHsgdGV4dHVyZTogdGV4dHVyZSwgdGV4dHVyZVNoYXBlUkM6IHRleHR1cmVTaGFwZVJDIH0sIGR0eXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb21waWxlQW5kUnVuID0gZnVuY3Rpb24gKHByb2dyYW0sIGlucHV0cywgb3V0cHV0LCBjdXN0b21TZXR1cCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3V0cHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsIGlucHV0c1swXS5kdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IGdwZ3B1X21hdGgubWFrZVNoYWRlcktleShwcm9ncmFtLCBpbnB1dHMsIG91dHB1dCk7XG4gICAgICAgIHZhciBiaW5hcnkgPSB0aGlzLmdldEFuZFNhdmVCaW5hcnkoa2V5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3BncHVfbWF0aC5jb21waWxlUHJvZ3JhbShfdGhpcy5ncGdwdSwgcHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZ3BncHVfbWF0aC5ydW5Qcm9ncmFtKGJpbmFyeSwgaW5wdXRzLCBvdXRwdXQsIGN1c3RvbVNldHVwKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5tYXRNdWxJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiLCBhT3JpZW50YXRpb24sIGJPcmllbnRhdGlvbikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBtdWxtYXRfZ3B1XzEuTWF0TXVsUHJvZ3JhbShhLnNoYXBlLCBiLnNoYXBlLCBhT3JpZW50YXRpb24sIGJPcmllbnRhdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5tdWx0aXBseUludGVybmFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5NVUwsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uMkRJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBpbnB1dHMgPSBbeCwgbWVhbiwgdmFyaWFuY2VdO1xuICAgICAgICB2YXIgb2Zmc2V0U2hhcGUgPSBudWxsO1xuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9mZnNldFNoYXBlID0gb2Zmc2V0LnNoYXBlO1xuICAgICAgICAgICAgaW5wdXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NhbGVTaGFwZSA9IG51bGw7XG4gICAgICAgIGlmIChzY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzY2FsZVNoYXBlID0gc2NhbGUuc2hhcGU7XG4gICAgICAgICAgICBpbnB1dHMucHVzaChzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmF0Y2hub3JtX2dwdV8xLkJhdGNoTm9ybVByb2dyYW0oeC5zaGFwZSwgbWVhbi5zaGFwZSwgdmFyaWFuY2Uuc2hhcGUsIG9mZnNldFNoYXBlLCBzY2FsZVNoYXBlLCB2YXJpYW5jZUVwc2lsb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIGlucHV0cyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uM0RJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBpbnB1dHMgPSBbeCwgbWVhbiwgdmFyaWFuY2VdO1xuICAgICAgICB2YXIgb2Zmc2V0U2hhcGUgPSBudWxsO1xuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9mZnNldFNoYXBlID0gb2Zmc2V0LnNoYXBlO1xuICAgICAgICAgICAgaW5wdXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NhbGVTaGFwZSA9IG51bGw7XG4gICAgICAgIGlmIChzY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzY2FsZVNoYXBlID0gc2NhbGUuc2hhcGU7XG4gICAgICAgICAgICBpbnB1dHMucHVzaChzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmF0Y2hub3JtX2dwdV8xLkJhdGNoTm9ybVByb2dyYW0oeC5zaGFwZSwgbWVhbi5zaGFwZSwgdmFyaWFuY2Uuc2hhcGUsIG9mZnNldFNoYXBlLCBzY2FsZVNoYXBlLCB2YXJpYW5jZUVwc2lsb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIGlucHV0cyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUudGlsZUludGVybmFsID0gZnVuY3Rpb24gKGEsIHJlcHMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdGlsZV9ncHVfMS5UaWxlUHJvZ3JhbShhLnNoYXBlLCByZXBzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnRyYW5zcG9zZUludGVybmFsID0gZnVuY3Rpb24gKGEsIHBlcm0pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdHJhbnNwb3NlX2dwdV8xLlRyYW5zcG9zZVByb2dyYW0oYS5zaGFwZSwgcGVybSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoYSwgcmVkdWNlVHlwZSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IGEuc2hhcGVbMF07XG4gICAgICAgIHZhciBpblNpemUgPSBhLnNoYXBlWzFdO1xuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHJlZHVjZV91dGlsLmNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZShpblNpemUpO1xuICAgICAgICB2YXIgcmVkdWNlSW5mbyA9IHsgd2luZG93U2l6ZTogd2luZG93U2l6ZSwgaW5TaXplOiBpblNpemUsIGJhdGNoU2l6ZTogYmF0Y2hTaXplIH07XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHJlZHVjZV9ncHVfMS5SZWR1Y2VQcm9ncmFtKHJlZHVjZUluZm8sIHJlZHVjZVR5cGUpO1xuICAgICAgICB2YXIgX2EgPSBwcm9ncmFtLm91dHB1dFNoYXBlLCByb3dzID0gX2FbMF0sIGNvbHMgPSBfYVsxXTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsIGR0eXBlKS5hczJEKHJvd3MsIGNvbHMpO1xuICAgICAgICB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdLCBvdXRwdXQpO1xuICAgICAgICBpZiAob3V0cHV0LnNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShvdXRwdXQsIHJlZHVjZVR5cGUsIGR0eXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5hcmdSZWR1Y2UgPSBmdW5jdGlvbiAoYSwgcmVkdWNlVHlwZSwgYmVzdEluZGljZXNBKSB7XG4gICAgICAgIGlmIChiZXN0SW5kaWNlc0EgPT09IHZvaWQgMCkgeyBiZXN0SW5kaWNlc0EgPSBudWxsOyB9XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBhLnNoYXBlWzBdO1xuICAgICAgICB2YXIgaW5TaXplID0gYS5zaGFwZVsxXTtcbiAgICAgICAgaWYgKGJlc3RJbmRpY2VzQSAhPSBudWxsKSB7XG4gICAgICAgICAgICBiYXRjaFNpemUgPSBiZXN0SW5kaWNlc0Euc2hhcGVbMF07XG4gICAgICAgICAgICBpblNpemUgPSBiZXN0SW5kaWNlc0Euc2hhcGVbMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpbmRvd1NpemUgPSByZWR1Y2VfdXRpbC5jb21wdXRlT3B0aW1hbFdpbmRvd1NpemUoaW5TaXplKTtcbiAgICAgICAgdmFyIHJlZHVjZUluZm8gPSB7IHdpbmRvd1NpemU6IHdpbmRvd1NpemUsIGluU2l6ZTogaW5TaXplLCBiYXRjaFNpemU6IGJhdGNoU2l6ZSB9O1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBhcmdtaW5tYXhfZ3B1XzEuQXJnTWluTWF4UHJvZ3JhbShyZWR1Y2VJbmZvLCByZWR1Y2VUeXBlLCBiZXN0SW5kaWNlc0EgPT0gbnVsbCk7XG4gICAgICAgIHZhciBfYSA9IHByb2dyYW0ub3V0cHV0U2hhcGUsIHJvd3MgPSBfYVswXSwgY29scyA9IF9hWzFdO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2ludDMyJykuYXMyRChyb3dzLCBjb2xzKTtcbiAgICAgICAgdmFyIGlucHV0cyA9IFthXTtcbiAgICAgICAgaWYgKGJlc3RJbmRpY2VzQSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dHMucHVzaChiZXN0SW5kaWNlc0EpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBpbnB1dHMsIG91dHB1dCk7XG4gICAgICAgIGlmIChvdXRwdXQuc2hhcGVbMV0gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXJnUmVkdWNlKGEsIHJlZHVjZVR5cGUsIG91dHB1dCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc3VtSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ3N1bScsIGF4ZXMsIGEucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGEuc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIGEyRCA9IGEuYXMyRCgtMSwgaW5TaXplKTtcbiAgICAgICAgdmFyIG91dHB1dERUeXBlID0gbWF0aF8xLlN1bVR5cGVzTWFwW2EuZHR5cGVdO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UoYTJELCAnc3VtJywgb3V0cHV0RFR5cGUpLnJlc2hhcGUob3V0U2hhcGUpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmFyZ01pbkludGVybmFsID0gZnVuY3Rpb24gKGEsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdhcmdNaW4nLCBheGVzLCBhLnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhhLnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBhMkQgPSBhLmFzMkQoLTEsIGluU2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ1JlZHVjZShhMkQsICdtaW4nKS5yZXNoYXBlKG91dFNoYXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5hcmdNYXhJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYXJnTWF4JywgYXhlcywgYS5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoYS5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgYTJEID0gYS5hczJEKC0xLCBpblNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdSZWR1Y2UoYTJELCAnbWF4JykucmVzaGFwZShvdXRTaGFwZSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuZXF1YWxJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuRVFVQUwsIHguc2hhcGUsIHkuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2Jvb2wnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeCwgeV0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUudG9wS0ludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXksIGspIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b3BLIEdQVSBub3QgeWV0IGltcGxlbWVudGVkIScpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLm1pbkludGVybmFsID0gZnVuY3Rpb24gKGEsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdtaW4nLCBheGVzLCBhLnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhhLnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBhMkQgPSBhLmFzMkQoLTEsIGluU2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShhMkQsICdtaW4nLCBhMkQuZHR5cGUpLnJlc2hhcGUob3V0U2hhcGUpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLm1heEludGVybmFsID0gZnVuY3Rpb24gKGEsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdtYXgnLCBheGVzLCBhLnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhhLnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIGluU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciBhMkQgPSBhLmFzMkQoLTEsIGluU2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShhMkQsICdtYXgnLCBhMkQuZHR5cGUpLnJlc2hhcGUob3V0U2hhcGUpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmRpdmlkZUludGVybmFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5ESVYsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2Zsb2F0MzInKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuYWRkSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkFERCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zdWJ0cmFjdEludGVybmFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5TVUIsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY2VpbEludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5DRUlMKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmZsb29ySW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkZMT09SKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmV4cEludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5FWFApO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubG9nSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkxPRyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zcXJ0SW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLlNRUlQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc3F1YXJlSW50ZXJuYWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlNRVUFSRSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5yZWx1SW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLlJFTFUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuZWx1SW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkVMVSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5sZWFreVJlbHVJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBhbHBoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkxFQUtZX1JFTFUoYWxwaGEpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNsaXBJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBtaW4sIG1heCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjbGlwX2dwdV8xLkNsaXBQcm9ncmFtKGEuc2hhcGUsIG1pbiwgbWF4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmFic0ludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5BQlMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc2lnbW9pZEludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5TSUdNT0lEKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnNpbkludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5TSU4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29zSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkNPUyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS50YW5JbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuVEFOKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmFzaW5JbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuQVNJTik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5hY29zSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkFDT1MpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuYXRhbkludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5BVEFOKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnNpbmhJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuU0lOSCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb3NoSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkNPU0gpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUudGFuaEludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5UQU5IKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnN0ZXBJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBhbHBoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLlNURVAoYWxwaGEpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvbnYyZEludGVybmFsID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgYmlhcywgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29udl9ncHVfMS5Db252MkRQcm9ncmFtKGNvbnZJbmZvLCBiaWFzICE9IG51bGwpO1xuICAgICAgICB2YXIgaW5wdXRzID0gYmlhcyAhPSBudWxsID8gW3gsIGZpbHRlciwgYmlhc10gOiBbeCwgZmlsdGVyXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBpbnB1dHMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvbnYyZERlcklucHV0SW50ZXJuYWwgPSBmdW5jdGlvbiAoZHksIGZpbHRlciwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29udl9iYWNrcHJvcF9ncHVfMS5Db252MkREZXJJbnB1dFByb2dyYW0oY29udkluZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtkeSwgZmlsdGVyXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVySW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgZFksIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbnZfYmFja3Byb3BfZ3B1XzEuQ29udjJERGVyV2VpZ2h0c1Byb2dyYW0oY29udkluZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4LCBkWV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvbnYyZERlckJpYXNJbnRlcm5hbCA9IGZ1bmN0aW9uIChkWSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb252X2JhY2twcm9wX2dwdV8xLkNvbnYyRERlckJpYXNQcm9ncmFtKGRZLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbZFldKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkRJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgZmlsdGVyLCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb252X2dwdV9kZXB0aHdpc2VfMS5EZXB0aHdpc2VDb252MkRQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbaW5wdXQsIGZpbHRlcl0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLm1heFBvb2xJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBwb29sX2dwdV8xLlBvb2wyRFByb2dyYW0oY29udkluZm8sICdtYXgnLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5taW5Qb29sSW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgcG9vbF9ncHVfMS5Qb29sMkRQcm9ncmFtKGNvbnZJbmZvLCAnbWluJywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuYXZnUG9vbEludGVybmFsID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHBvb2xfZ3B1XzEuUG9vbDJEUHJvZ3JhbShjb252SW5mbywgJ2F2ZycsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLm1heFBvb2xCYWNrcHJvcEludGVybmFsID0gZnVuY3Rpb24gKGR5LCB4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgZ2V0UG9zaXRpb25zID0gdHJ1ZTtcbiAgICAgICAgdmFyIG1heFBvb2xQb3NpdGlvbnNQcm9ncmFtID0gbmV3IHBvb2xfZ3B1XzEuUG9vbDJEUHJvZ3JhbShjb252SW5mbywgJ21heCcsIGdldFBvc2l0aW9ucyk7XG4gICAgICAgIHZhciBtYXhQb29sUG9zaXRpb25zID0gdGhpcy5jb21waWxlQW5kUnVuKG1heFBvb2xQb3NpdGlvbnNQcm9ncmFtLCBbeF0pO1xuICAgICAgICB2YXIgbWF4UG9vbEJhY2tQcm9wUHJvZ3JhbSA9IG5ldyBtYXhfcG9vbF9iYWNrcHJvcF9ncHVfMS5NYXhQb29sMkRCYWNrcHJvcFByb2dyYW0oY29udkluZm8pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jb21waWxlQW5kUnVuKG1heFBvb2xCYWNrUHJvcFByb2dyYW0sIFtkeSwgbWF4UG9vbFBvc2l0aW9uc10pO1xuICAgICAgICBtYXhQb29sUG9zaXRpb25zLmRpc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcjNESW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgbmV3U2hhcGUyRCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHJlc2l6ZV9iaWxpbmVhcl9ncHVfMS5SZXNpemVCaWxpbmVhcjNEUHJvZ3JhbSh4LnNoYXBlLCBuZXdTaGFwZTJELCBhbGlnbkNvcm5lcnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubXVsdGlub21pYWxJbnRlcm5hbCA9IGZ1bmN0aW9uIChwcm9icywgbnVtU2FtcGxlcywgc2VlZCkge1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gcHJvYnMuc2hhcGVbMF07XG4gICAgICAgIHZhciBudW1PdXRjb21lcyA9IHByb2JzLnNoYXBlWzFdO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBtdWx0aW5vbWlhbF9ncHVfMS5NdWx0aW5vbWlhbFByb2dyYW0oYmF0Y2hTaXplLCBudW1PdXRjb21lcywgbnVtU2FtcGxlcyk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnaW50MzInKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoc2VlZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3Byb2JzXSwgb3V0cHV0LCBjdXN0b21TZXR1cCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUub25lSG90SW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5kaWNlcywgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IG9uZWhvdF9ncHVfMS5PbmVIb3RQcm9ncmFtKGluZGljZXMuc2l6ZSwgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbaW5kaWNlc10pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmdldEFuZFNhdmVCaW5hcnkgPSBmdW5jdGlvbiAoa2V5LCBnZXRCaW5hcnkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuYmluYXJ5Q2FjaGUpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeUNhY2hlW2tleV0gPSBnZXRCaW5hcnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlDYWNoZVtrZXldO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmdldFRleHR1cmVNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlTWFuYWdlcjtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5iaW5hcnlDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5ncGdwdS5kZWxldGVQcm9ncmFtKHRoaXMuYmluYXJ5Q2FjaGVba2V5XS53ZWJHTFByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5KSB7XG4gICAgICAgICAgICB0aGlzLmdwZ3B1LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5EQXJyYXlNYXRoR1BVO1xufShtYXRoXzEuTkRBcnJheU1hdGgpKTtcbmV4cG9ydHMuTkRBcnJheU1hdGhHUFUgPSBOREFycmF5TWF0aEdQVTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciB0ZXhfdXRpbF8xID0gcmVxdWlyZShcIi4vd2ViZ2wvdGV4X3V0aWxcIik7XG52YXIgd2ViZ2xfdXRpbCA9IHJlcXVpcmUoXCIuL3dlYmdsL3dlYmdsX3V0aWxcIik7XG5leHBvcnRzLkdQR1BVID0gbnVsbDtcbmV4cG9ydHMuVEVYVFVSRV9NQU5BR0VSID0gbnVsbDtcbnZhciBEVHlwZTtcbihmdW5jdGlvbiAoRFR5cGUpIHtcbiAgICBEVHlwZVtcImZsb2F0MzJcIl0gPSBcImZsb2F0MzJcIjtcbiAgICBEVHlwZVtcImludDMyXCJdID0gXCJpbnQzMlwiO1xuICAgIERUeXBlW1wiYm9vbFwiXSA9IFwiYm9vbFwiO1xufSkoRFR5cGUgPSBleHBvcnRzLkRUeXBlIHx8IChleHBvcnRzLkRUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGluaXRpYWxpemVHUFUoZ3BncHUsIHRleHR1cmVNYW5hZ2VyKSB7XG4gICAgZXhwb3J0cy5HUEdQVSA9IGdwZ3B1O1xuICAgIGV4cG9ydHMuVEVYVFVSRV9NQU5BR0VSID0gdGV4dHVyZU1hbmFnZXI7XG59XG5leHBvcnRzLmluaXRpYWxpemVHUFUgPSBpbml0aWFsaXplR1BVO1xuZnVuY3Rpb24gdGhyb3dJZkdQVU5vdEluaXRpYWxpemVkKCkge1xuICAgIGlmIChleHBvcnRzLkdQR1BVID09IG51bGwgfHwgZXhwb3J0cy5URVhUVVJFX01BTkFHRVIgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dQVSBub3QgaW50aWFsaXplZC4nKTtcbiAgICB9XG59XG52YXIgTkRBcnJheSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTkRBcnJheShzaGFwZSwgZGF0YSwgZHR5cGUpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoZGF0YS52YWx1ZXMgIT0gbnVsbCB8fCBkYXRhLnRleHR1cmUgIT0gbnVsbCwgJ0VpdGhlciBgdmFsdWVzYCBvciBgdGV4dHVyZWAgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGRhdGEudGV4dHVyZSA9PSBudWxsIHx8IChkYXRhLnRleHR1cmVTaGFwZVJDICE9IG51bGwpLCAnYHRleHR1cmVTaGFwZWAgbXVzdCBiZSBkZWZpbmVkIHdoZW4gYHRleHR1cmVgIGlzIGRlZmluZWQnKTtcbiAgICAgICAgdGhpcy5zaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKTtcbiAgICAgICAgaWYgKGRhdGEudmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMuc2l6ZSA9PT0gZGF0YS52YWx1ZXMubGVuZ3RoLCBcIkNvbnN0cnVjdGluZyBuZGFycmF5IG9mIHNoYXBlIChcIiArIHRoaXMuc2l6ZSArIFwiKSBzaG91bGQgbWF0Y2ggdGhlIFwiICtcbiAgICAgICAgICAgICAgICAoXCJsZW5ndGggb2YgdmFsdWVzIChcIiArIGRhdGEudmFsdWVzLmxlbmd0aCArIFwiKVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlO1xuICAgICAgICBpZiAoZGF0YS50ZXh0dXJlVHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhLnRleHR1cmVUeXBlID0gdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5ERUZBVUxUO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmRhcnJheURhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmR0eXBlID0gZHR5cGUgfHwgJ2Zsb2F0MzInO1xuICAgICAgICB2YXIgZGltID0gdGhpcy5zaGFwZS5sZW5ndGg7XG4gICAgICAgIGlmIChkaW0gPCAyKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmlkZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RyaWRlcyA9IG5ldyBBcnJheShkaW0gLSAxKTtcbiAgICAgICAgICAgIHRoaXMuc3RyaWRlc1tkaW0gLSAyXSA9IHRoaXMuc2hhcGVbZGltIC0gMV07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGltIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmlkZXNbaV0gPSB0aGlzLnN0cmlkZXNbaSArIDFdICogdGhpcy5zaGFwZVtpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgTkRBcnJheS56ZXJvcyA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG1ha2VaZXJvc1R5cGVkQXJyYXkodXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKSwgZHR5cGUpO1xuICAgICAgICByZXR1cm4gTkRBcnJheS5tYWtlKHNoYXBlLCB7IHZhbHVlczogdmFsdWVzIH0sIGR0eXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXkuemVyb3NMaWtlID0gZnVuY3Rpb24gKGFub3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkuemVyb3MoYW5vdGhlci5zaGFwZSwgYW5vdGhlci5kdHlwZSk7XG4gICAgfTtcbiAgICBOREFycmF5Lmxpa2UgPSBmdW5jdGlvbiAoYW5vdGhlcikge1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gY29weVR5cGVkQXJyYXkoYW5vdGhlci5nZXRWYWx1ZXMoKSwgYW5vdGhlci5kdHlwZSk7XG4gICAgICAgIHJldHVybiBOREFycmF5Lm1ha2UoYW5vdGhlci5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9LCBhbm90aGVyLmR0eXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXkubWFrZSA9IGZ1bmN0aW9uIChzaGFwZSwgZGF0YSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKGRhdGEuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1ha2UgbmV3IE5EQXJyYXkgZnJvbSBkaXNwb3NlZCBOREFycmF5RGF0YS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNjYWxhcihkYXRhLCBkdHlwZSk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheTFEKGRhdGEsIGR0eXBlKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5MkQoc2hhcGUsIGRhdGEsIGR0eXBlKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5M0Qoc2hhcGUsIGRhdGEsIGR0eXBlKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5NEQoc2hhcGUsIGRhdGEsIGR0eXBlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOREFycmF5KHNoYXBlLCBkYXRhLCBkdHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5EQXJyYXkuZnJvbVBpeGVscyA9IGZ1bmN0aW9uIChwaXhlbHMsIG51bUNoYW5uZWxzKSB7XG4gICAgICAgIGlmIChudW1DaGFubmVscyA9PT0gdm9pZCAwKSB7IG51bUNoYW5uZWxzID0gMzsgfVxuICAgICAgICBpZiAobnVtQ2hhbm5lbHMgPiA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb25zdHJ1Y3QgTkRBcnJheSB3aXRoIG1vcmUgdGhhbiA0IGNoYW5uZWxzIGZyb20gcGl4ZWxzLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaGFwZSA9IFtwaXhlbHMuaGVpZ2h0LCBwaXhlbHMud2lkdGgsIG51bUNoYW5uZWxzXTtcbiAgICAgICAgdmFyIHRleHR1cmVTaGFwZVJDID0gW3NoYXBlWzBdLCBzaGFwZVsxXV07XG4gICAgICAgIHZhciB0ZXh0dXJlID0gZXhwb3J0cy5URVhUVVJFX01BTkFHRVIuYWNxdWlyZVRleHR1cmUodGV4dHVyZVNoYXBlUkMpO1xuICAgICAgICB2YXIgdGV4dHVyZVR5cGUgPSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLlJHQkFfQ09MT1I7XG4gICAgICAgIGV4cG9ydHMuR1BHUFUudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKHRleHR1cmUsIHBpeGVscyk7XG4gICAgICAgIHJldHVybiBBcnJheTNELm1ha2Uoc2hhcGUsIHsgdGV4dHVyZTogdGV4dHVyZSwgdGV4dHVyZVNoYXBlUkM6IHRleHR1cmVTaGFwZVJDLCB0ZXh0dXJlVHlwZTogdGV4dHVyZVR5cGUgfSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24gKG5ld1NoYXBlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIG5ld1NoYXBlID0gdXRpbC5pbmZlckZyb21JbXBsaWNpdFNoYXBlKG5ld1NoYXBlLCB0aGlzLnNpemUpO1xuICAgICAgICBpZiAodXRpbC5hcnJheXNFcXVhbCh0aGlzLnNoYXBlLCBuZXdTaGFwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMuc2l6ZSA9PT0gdXRpbC5zaXplRnJvbVNoYXBlKG5ld1NoYXBlKSwgJ25ldyBzaGFwZSBhbmQgb2xkIHNoYXBlIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuJyk7XG4gICAgICAgIHJldHVybiBOREFycmF5Lm1ha2UobmV3U2hhcGUsIHRoaXMubmRhcnJheURhdGEsIHRoaXMuZHR5cGUpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBBcnJheTFEKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hczFEKCk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hc1NjYWxhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5zaXplID09PSAxLCAnVGhlIGFycmF5IG11c3QgaGF2ZSBvbmx5IDEgZWxlbWVudC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZShbXSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hczFEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKFt0aGlzLnNpemVdKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmFzMkQgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKFtyb3dzLCBjb2x1bW5zXSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hczNEID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMsIGRlcHRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2hhcGUoW3Jvd3MsIGNvbHVtbnMsIGRlcHRoXSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hczREID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMsIGRlcHRoLCBkZXB0aDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZShbcm93cywgY29sdW1ucywgZGVwdGgsIGRlcHRoMl0pO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuYXNUeXBlID0gZnVuY3Rpb24gKGR0eXBlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHZhciBuZXdEYXRhID0gdGhpcy5nZXREYXRhKCk7XG4gICAgICAgIGlmIChuZXdEYXRhLnZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZXdEYXRhID0geyB2YWx1ZXM6IHRvVHlwZWRBcnJheShuZXdEYXRhLnZhbHVlcywgZHR5cGUpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkubWFrZSh0aGlzLnNoYXBlLCBuZXdEYXRhLCBkdHlwZSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTkRBcnJheS5wcm90b3R5cGUsIFwicmFua1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNoYXBlLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9jcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbG9jc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHZhciBpbmRleCA9IGxvY3NbbG9jcy5sZW5ndGggLSAxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgaW5kZXggKz0gdGhpcy5zdHJpZGVzW2ldICogbG9jc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoKVtpbmRleF07XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGxvY3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGxvY3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdGhpcy5zZXQuYXBwbHkodGhpcywgW3RoaXMuZ2V0LmFwcGx5KHRoaXMsIGxvY3MpICsgdmFsdWVdLmNvbmNhdChsb2NzKSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGxvY3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGxvY3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIGluZGV4ID0gbG9jc1tsb2NzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBpbmRleCArPSB0aGlzLnN0cmlkZXNbaV0gKiBsb2NzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKClbaW5kZXhdID0gdmFsdWU7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS52YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2NzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBsb2NzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5kYXRhKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuZ2V0LmFwcGx5KHRoaXMsIGxvY3MpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5sb2NUb0luZGV4ID0gZnVuY3Rpb24gKGxvY3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbG9jc1tsb2NzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBpbmRleCArPSB0aGlzLnN0cmlkZXNbaV0gKiBsb2NzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmluZGV4VG9Mb2MgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGxvY3MgPSBuZXcgQXJyYXkodGhpcy5zaGFwZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBsb2NzW2ldID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlc1tpXSk7XG4gICAgICAgICAgICBpbmRleCAtPSBsb2NzW2ldICogdGhpcy5zdHJpZGVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGxvY3NbbG9jcy5sZW5ndGggLSAxXSA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbG9jcztcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKS5maWxsKHZhbHVlKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5kYXJyYXlEYXRhO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU3luYygpO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZ2V0VmFsdWVzQXN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgcXVlcnlGbjtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZGFycmF5RGF0YS52YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5uZGFycmF5RGF0YS52YWx1ZXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9HRVRfQlVGRkVSX1NVQl9EQVRBX0FTWU5DX0VYVEVOU0lPTl9FTkFCTEVEJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVUeXBlID09PSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLkRFRkFVTFQpKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLm5kYXJyYXlEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBleHBvcnRzLkdQR1BVLmRvd25sb2FkTWF0cml4RnJvbVRleHR1cmVBc3luYyh0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmUsIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVNoYXBlUkNbMF0sIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVNoYXBlUkNbMV0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudmFsdWVzID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLm5kYXJyYXlEYXRhLnZhbHVlc107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX0VOQUJMRUQnKSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5kYXRhU3luYygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIsIF9iLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Rm4gPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGV4cG9ydHMuR1BHUFUucnVuUXVlcnkocXVlcnlGbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuZGF0YVN5bmMoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZGF0YVN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmICh0aGlzLm5kYXJyYXlEYXRhLnZhbHVlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd0lmR1BVTm90SW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlVHlwZSA9PT0gdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5ERUZBVUxUKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzID0gZXhwb3J0cy5HUEdQVS5kb3dubG9hZE1hdHJpeEZyb21UZXh0dXJlKHRoaXMubmRhcnJheURhdGEudGV4dHVyZSwgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlU2hhcGVSQ1swXSwgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlU2hhcGVSQ1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBleHBvcnRzLkdQR1BVLmRvd25sb2FkTWF0cml4RnJvbVJHQkFDb2xvclRleHR1cmUodGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlLCB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVTaGFwZVJDWzBdLCB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVTaGFwZVJDWzFdLCB0aGlzLnNoYXBlWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmRhcnJheURhdGEudmFsdWVzID0gZmxvYXQzMlRvVHlwZWRBcnJheSh2YWx1ZXMsIHRoaXMuZHR5cGUpO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlVGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5kYXJyYXlEYXRhLnZhbHVlcztcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLnVwbG9hZFRvR1BVID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvd0lmR1BVTm90SW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlU2hhcGVSQyA9XG4gICAgICAgICAgICB3ZWJnbF91dGlsLmdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUoZXhwb3J0cy5HUEdQVS5nbCwgdGhpcy5zaGFwZSk7XG4gICAgICAgIHRoaXMubmRhcnJheURhdGEudGV4dHVyZSA9XG4gICAgICAgICAgICBleHBvcnRzLlRFWFRVUkVfTUFOQUdFUi5hY3F1aXJlVGV4dHVyZSh0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVTaGFwZVJDKTtcbiAgICAgICAgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlVHlwZSA9IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuREVGQVVMVDtcbiAgICAgICAgZXhwb3J0cy5HUEdQVS51cGxvYWRNYXRyaXhUb1RleHR1cmUodGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlLCB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVTaGFwZVJDWzBdLCB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVTaGFwZVJDWzFdLCB0eXBlZEFycmF5VG9GbG9hdDMyKHRoaXMubmRhcnJheURhdGEudmFsdWVzLCB0aGlzLmR0eXBlKSk7XG4gICAgICAgIHRoaXMubmRhcnJheURhdGEudmFsdWVzID0gbnVsbDtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmdldFRleHR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmICh0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51cGxvYWRUb0dQVSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmU7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5nZXRUZXh0dXJlU2hhcGVSQyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHRoaXMubmRhcnJheURhdGEudGV4dHVyZVNoYXBlUkMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51cGxvYWRUb0dQVSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVTaGFwZVJDO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUudGhyb3dJZkRpc3Bvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5uZGFycmF5RGF0YS5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREFycmF5IGlzIGRpc3Bvc2VkLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5uZGFycmF5RGF0YS52YWx1ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnNoYXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZGFycmF5RGF0YS5pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubmRhcnJheURhdGEudGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VUZXh0dXJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmRpc3Bvc2VUZXh0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvd0lmR1BVTm90SW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgZXhwb3J0cy5URVhUVVJFX01BTkFHRVIucmVsZWFzZVRleHR1cmUodGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlLCB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmVTaGFwZVJDKTtcbiAgICAgICAgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZGFycmF5RGF0YS50ZXh0dXJlU2hhcGVSQyA9IG51bGw7XG4gICAgICAgIHRoaXMubmRhcnJheURhdGEudGV4dHVyZVR5cGUgPSBudWxsO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuaW5HUFUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5kYXJyYXlEYXRhLnRleHR1cmUgIT0gbnVsbDtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmR0eXBlID09PSB0LmR0eXBlICYmIHV0aWwuYXJyYXlzRXF1YWwodGhpcy5zaGFwZSwgdC5zaGFwZSkgJiZcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy5nZXRWYWx1ZXMoKSwgdC5nZXRWYWx1ZXMoKSk7XG4gICAgfTtcbiAgICBOREFycmF5LnJhbmQgPSBmdW5jdGlvbiAoc2hhcGUsIHJhbmRGdW5jdGlvbikge1xuICAgICAgICB2YXIgc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gcmFuZEZ1bmN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkubWFrZShzaGFwZSwgeyB2YWx1ZXM6IHZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucmFuZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5LnJhbmRUcnVuY2F0ZWROb3JtYWwgPSBmdW5jdGlvbiAoc2hhcGUsIG1lYW4sIHN0ZERldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZEdhdXNzKG1lYW4sIHN0ZERldiwgdHJ1ZSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheS5yYW5kVW5pZm9ybSA9IGZ1bmN0aW9uIChzaGFwZSwgYSwgYikge1xuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRVbmlmb3JtKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBOREFycmF5O1xufSgpKTtcbmV4cG9ydHMuTkRBcnJheSA9IE5EQXJyYXk7XG52YXIgU2NhbGFyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2NhbGFyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNjYWxhcihkYXRhLCBkdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGF0YS50ZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGEudGV4dHVyZVNoYXBlUkMgPSBbMSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBbXSwgZGF0YSwgZHR5cGUpIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2NhbGFyLm5ldyA9IGZ1bmN0aW9uICh2YWx1ZSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFt2YWx1ZV07XG4gICAgICAgIHJldHVybiBuZXcgU2NhbGFyKHsgdmFsdWVzOiB0b1R5cGVkQXJyYXkodmFsdWVzLCBkdHlwZSkgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgU2NhbGFyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcygpWzBdO1xuICAgIH07XG4gICAgU2NhbGFyLnByb3RvdHlwZS52YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCB0aGlzLmRhdGEoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5nZXQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2NhbGFyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVswXSA9IHZhbHVlO1xuICAgIH07XG4gICAgU2NhbGFyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVswXSArPSB2YWx1ZTtcbiAgICB9O1xuICAgIFNjYWxhci5wcm90b3R5cGUuYXNUeXBlID0gZnVuY3Rpb24gKGR0eXBlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmFzVHlwZS5jYWxsKHRoaXMsIGR0eXBlKTtcbiAgICB9O1xuICAgIFNjYWxhci5wcm90b3R5cGUubG9jVG9JbmRleCA9IGZ1bmN0aW9uIChsb2MpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBTY2FsYXIucHJvdG90eXBlLmluZGV4VG9Mb2MgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgU2NhbGFyLlpFUk8gPSBTY2FsYXIubmV3KDApO1xuICAgIFNjYWxhci5PTkUgPSBTY2FsYXIubmV3KDEpO1xuICAgIFNjYWxhci5UV08gPSBTY2FsYXIubmV3KDIpO1xuICAgIFNjYWxhci5ORUdfT05FID0gU2NhbGFyLm5ldygtMSk7XG4gICAgcmV0dXJuIFNjYWxhcjtcbn0oTkRBcnJheSkpO1xuZXhwb3J0cy5TY2FsYXIgPSBTY2FsYXI7XG52YXIgQXJyYXkxRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5MUQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXkxRChkYXRhLCBkdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2hhcGUgPSAoZGF0YS52YWx1ZXMgIT0gbnVsbCkgP1xuICAgICAgICAgICAgW2RhdGEudmFsdWVzLmxlbmd0aF0gOlxuICAgICAgICAgICAgW3V0aWwuc2l6ZUZyb21TaGFwZShkYXRhLnRleHR1cmVTaGFwZVJDKV07XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2hhcGUsIGRhdGEsIGR0eXBlKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFycmF5MUQubmV3ID0gZnVuY3Rpb24gKHZhbHVlcywgZHR5cGUpIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZW9mVHlwZWRBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICB2YXIgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoaW5mZXJyZWRTaGFwZS5sZW5ndGggPT09IDEsIFwiRXJyb3IgY29uc3RydWN0aW5nIEFycmF5MUQuIFNoYXBlIG9mIHZhbHVlcyBcIiArIGluZmVycmVkU2hhcGUgKyBcIiBpcyBcIiArXG4gICAgICAgICAgICAgICAgXCJub3QgMSBkaW1lbnNpb25hbC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheTFEKHsgdmFsdWVzOiB0b1R5cGVkQXJyYXkodmFsdWVzLCBkdHlwZSkgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXkxRC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKClbaV07XG4gICAgfTtcbiAgICBBcnJheTFELnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVtpXSA9IHZhbHVlO1xuICAgIH07XG4gICAgQXJyYXkxRC5wcm90b3R5cGUudmFsID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIHRoaXMuZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmdldChpKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXJyYXkxRC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKClbaV0gKz0gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheTFELnByb3RvdHlwZS5sb2NUb0luZGV4ID0gZnVuY3Rpb24gKGxvYykge1xuICAgICAgICByZXR1cm4gbG9jWzBdO1xuICAgIH07XG4gICAgQXJyYXkxRC5wcm90b3R5cGUuaW5kZXhUb0xvYyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gW2luZGV4XTtcbiAgICB9O1xuICAgIEFycmF5MUQucHJvdG90eXBlLmFzVHlwZSA9IGZ1bmN0aW9uIChkdHlwZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5hc1R5cGUuY2FsbCh0aGlzLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheTFELnplcm9zID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gTkRBcnJheS56ZXJvcyhzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXkxRC5yYW5kTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYpOyB9KTtcbiAgICB9O1xuICAgIEFycmF5MUQucmFuZFRydW5jYXRlZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2LCB0cnVlKTsgfSk7XG4gICAgfTtcbiAgICBBcnJheTFELnJhbmRVbmlmb3JtID0gZnVuY3Rpb24gKHNoYXBlLCBhLCBiKSB7XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZFVuaWZvcm0oYSwgYik7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5MUQ7XG59KE5EQXJyYXkpKTtcbmV4cG9ydHMuQXJyYXkxRCA9IEFycmF5MUQ7XG52YXIgQXJyYXkyRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5MkQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXkyRChzaGFwZSwgZGF0YSwgZHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoc2hhcGUubGVuZ3RoID09PSAyLCAnU2hhcGUgc2hvdWxkIGJlIG9mIGxlbmd0aCAyJyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2hhcGUsIGRhdGEsIGR0eXBlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdHJpZGUwID0gX3RoaXMuc3RyaWRlc1swXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBcnJheTJELm5ldyA9IGZ1bmN0aW9uIChzaGFwZSwgdmFsdWVzLCBkdHlwZSkge1xuICAgICAgICBpZiAoIWluc3RhbmNlb2ZUeXBlZEFycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIHZhciBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChzaGFwZSwgaW5mZXJyZWRTaGFwZSwgXCJFcnJvciB3aGVuIGNvbnN0cnVjdGluZyBBcnJheTJELiBTaGFwZSBvZiB2YWx1ZXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoaW5mZXJyZWRTaGFwZSArIFwiIGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBzaGFwZSBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoc2hhcGUgKyBcIi4gXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5MkQoc2hhcGUsIHsgdmFsdWVzOiB0b1R5cGVkQXJyYXkodmFsdWVzLCBkdHlwZSkgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXkyRC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGksIGopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIGpdO1xuICAgIH07XG4gICAgQXJyYXkyRC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlLCBpLCBqKSB7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIGpdID0gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheTJELnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUsIGksIGopIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgal0gKz0gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheTJELnByb3RvdHlwZS52YWwgPSBmdW5jdGlvbiAoaSwgaikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgdGhpcy5kYXRhKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuZ2V0KGksIGopXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcnJheTJELnByb3RvdHlwZS5sb2NUb0luZGV4ID0gZnVuY3Rpb24gKGxvY3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaWRlMCAqIGxvY3NbMF0gKyBsb2NzWzFdO1xuICAgIH07XG4gICAgQXJyYXkyRC5wcm90b3R5cGUuaW5kZXhUb0xvYyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gW01hdGguZmxvb3IoaW5kZXggLyB0aGlzLnN0cmlkZTApLCBpbmRleCAlIHRoaXMuc3RyaWRlMF07XG4gICAgfTtcbiAgICBBcnJheTJELnByb3RvdHlwZS5hc1R5cGUgPSBmdW5jdGlvbiAoZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuYXNUeXBlLmNhbGwodGhpcywgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXkyRC56ZXJvcyA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkuemVyb3Moc2hhcGUsIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5MkQucmFuZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2KTsgfSk7XG4gICAgfTtcbiAgICBBcnJheTJELnJhbmRUcnVuY2F0ZWROb3JtYWwgPSBmdW5jdGlvbiAoc2hhcGUsIG1lYW4sIHN0ZERldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZEdhdXNzKG1lYW4sIHN0ZERldiwgdHJ1ZSk7IH0pO1xuICAgIH07XG4gICAgQXJyYXkyRC5yYW5kVW5pZm9ybSA9IGZ1bmN0aW9uIChzaGFwZSwgYSwgYikge1xuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRVbmlmb3JtKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBcnJheTJEO1xufShOREFycmF5KSk7XG5leHBvcnRzLkFycmF5MkQgPSBBcnJheTJEO1xudmFyIEFycmF5M0QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheTNELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5M0Qoc2hhcGUsIGRhdGEsIGR0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHNoYXBlLmxlbmd0aCA9PT0gMywgJ1NoYXBlIHNob3VsZCBiZSBvZiBsZW5ndGggMycpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNoYXBlLCBkYXRhLCBkdHlwZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RyaWRlMCA9IF90aGlzLnN0cmlkZXNbMF07XG4gICAgICAgIF90aGlzLnN0cmlkZTEgPSBfdGhpcy5zdHJpZGVzWzFdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFycmF5M0QubmV3ID0gZnVuY3Rpb24gKHNoYXBlLCB2YWx1ZXMsIGR0eXBlKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2VvZlR5cGVkQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgdmFyIGluZmVycmVkU2hhcGUgPSB1dGlsLmluZmVyU2hhcGUodmFsdWVzKTtcbiAgICAgICAgICAgIGlmIChpbmZlcnJlZFNoYXBlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHNoYXBlLCBpbmZlcnJlZFNoYXBlLCBcIkVycm9yIHdoZW4gY29uc3RydWN0aW5nIEFycmF5M0QuIFNoYXBlIG9mIHZhbHVlcyBcIiArXG4gICAgICAgICAgICAgICAgICAgIChpbmZlcnJlZFNoYXBlICsgXCIgZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHNoYXBlIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIChzaGFwZSArIFwiLiBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkzRChzaGFwZSwgeyB2YWx1ZXM6IHRvVHlwZWRBcnJheSh2YWx1ZXMsIGR0eXBlKSB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheTNELnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaSwgaiwgaykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgdGhpcy5zdHJpZGUxICogaiArIGtdO1xuICAgIH07XG4gICAgQXJyYXkzRC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlLCBpLCBqLCBrKSB7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIHRoaXMuc3RyaWRlMSAqIGogKyBrXSA9IHZhbHVlO1xuICAgIH07XG4gICAgQXJyYXkzRC5wcm90b3R5cGUudmFsID0gZnVuY3Rpb24gKGksIGosIGspIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIHRoaXMuZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmdldChpLCBqLCBrKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXJyYXkzRC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlLCBpLCBqLCBrKSB7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIHRoaXMuc3RyaWRlMSAqIGogKyBrXSArPSB2YWx1ZTtcbiAgICB9O1xuICAgIEFycmF5M0QucHJvdG90eXBlLmxvY1RvSW5kZXggPSBmdW5jdGlvbiAobG9jcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpZGUwICogbG9jc1swXSArIHRoaXMuc3RyaWRlMSAqIGxvY3NbMV0gKyBsb2NzWzJdO1xuICAgIH07XG4gICAgQXJyYXkzRC5wcm90b3R5cGUuaW5kZXhUb0xvYyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLnN0cmlkZTApO1xuICAgICAgICBpbmRleCAtPSBpICogdGhpcy5zdHJpZGUwO1xuICAgICAgICByZXR1cm4gW2ksIE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLnN0cmlkZTEpLCBpbmRleCAlIHRoaXMuc3RyaWRlMV07XG4gICAgfTtcbiAgICBBcnJheTNELnByb3RvdHlwZS5hc1R5cGUgPSBmdW5jdGlvbiAoZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuYXNUeXBlLmNhbGwodGhpcywgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXkzRC56ZXJvcyA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkuemVyb3Moc2hhcGUsIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5M0QucmFuZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2KTsgfSk7XG4gICAgfTtcbiAgICBBcnJheTNELnJhbmRUcnVuY2F0ZWROb3JtYWwgPSBmdW5jdGlvbiAoc2hhcGUsIG1lYW4sIHN0ZERldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZEdhdXNzKG1lYW4sIHN0ZERldiwgdHJ1ZSk7IH0pO1xuICAgIH07XG4gICAgQXJyYXkzRC5yYW5kVW5pZm9ybSA9IGZ1bmN0aW9uIChzaGFwZSwgYSwgYikge1xuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRVbmlmb3JtKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBcnJheTNEO1xufShOREFycmF5KSk7XG5leHBvcnRzLkFycmF5M0QgPSBBcnJheTNEO1xudmFyIEFycmF5NEQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheTRELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5NEQoc2hhcGUsIGRhdGEsIGR0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHNoYXBlLmxlbmd0aCA9PT0gNCwgJ1NoYXBlIHNob3VsZCBiZSBvZiBsZW5ndGggNCcpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNoYXBlLCBkYXRhLCBkdHlwZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RyaWRlMCA9IF90aGlzLnN0cmlkZXNbMF07XG4gICAgICAgIF90aGlzLnN0cmlkZTEgPSBfdGhpcy5zdHJpZGVzWzFdO1xuICAgICAgICBfdGhpcy5zdHJpZGUyID0gX3RoaXMuc3RyaWRlc1syXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBcnJheTRELm5ldyA9IGZ1bmN0aW9uIChzaGFwZSwgdmFsdWVzLCBkdHlwZSkge1xuICAgICAgICBpZiAoIWluc3RhbmNlb2ZUeXBlZEFycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIHZhciBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChzaGFwZSwgaW5mZXJyZWRTaGFwZSwgXCJFcnJvciB3aGVuIGNvbnN0cnVjdGluZyBBcnJheTRELiBTaGFwZSBvZiB2YWx1ZXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoaW5mZXJyZWRTaGFwZSArIFwiIGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBzaGFwZSBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoc2hhcGUgKyBcIi4gXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5NEQoc2hhcGUsIHsgdmFsdWVzOiB0b1R5cGVkQXJyYXkodmFsdWVzLCBkdHlwZSkgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXk0RC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGksIGosIGssIGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIHRoaXMuc3RyaWRlMSAqIGogKyB0aGlzLnN0cmlkZTIgKiBrICsgbF07XG4gICAgfTtcbiAgICBBcnJheTRELnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUsIGksIGosIGssIGwpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgdGhpcy5zdHJpZGUxICogaiArIHRoaXMuc3RyaWRlMiAqIGsgKyBsXSA9IHZhbHVlO1xuICAgIH07XG4gICAgQXJyYXk0RC5wcm90b3R5cGUudmFsID0gZnVuY3Rpb24gKGksIGosIGssIGwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIHRoaXMuZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmdldChpLCBqLCBrLCBsKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXJyYXk0RC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlLCBpLCBqLCBrLCBsKSB7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIHRoaXMuc3RyaWRlMSAqIGogKyB0aGlzLnN0cmlkZTIgKiBrICsgbF0gKz0gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheTRELnByb3RvdHlwZS5sb2NUb0luZGV4ID0gZnVuY3Rpb24gKGxvY3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaWRlMCAqIGxvY3NbMF0gKyB0aGlzLnN0cmlkZTEgKiBsb2NzWzFdICtcbiAgICAgICAgICAgIHRoaXMuc3RyaWRlMiAqIGxvY3NbMl0gKyBsb2NzWzNdO1xuICAgIH07XG4gICAgQXJyYXk0RC5wcm90b3R5cGUuaW5kZXhUb0xvYyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLnN0cmlkZTApO1xuICAgICAgICBpbmRleCAtPSBpICogdGhpcy5zdHJpZGUwO1xuICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLnN0cmlkZTEpO1xuICAgICAgICBpbmRleCAtPSBqICogdGhpcy5zdHJpZGUxO1xuICAgICAgICByZXR1cm4gW2ksIGosIE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLnN0cmlkZTIpLCBpbmRleCAlIHRoaXMuc3RyaWRlMl07XG4gICAgfTtcbiAgICBBcnJheTRELnByb3RvdHlwZS5hc1R5cGUgPSBmdW5jdGlvbiAoZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuYXNUeXBlLmNhbGwodGhpcywgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXk0RC56ZXJvcyA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkuemVyb3Moc2hhcGUsIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5NEQucmFuZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2KTsgfSk7XG4gICAgfTtcbiAgICBBcnJheTRELnJhbmRUcnVuY2F0ZWROb3JtYWwgPSBmdW5jdGlvbiAoc2hhcGUsIG1lYW4sIHN0ZERldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZEdhdXNzKG1lYW4sIHN0ZERldiwgdHJ1ZSk7IH0pO1xuICAgIH07XG4gICAgQXJyYXk0RC5yYW5kVW5pZm9ybSA9IGZ1bmN0aW9uIChzaGFwZSwgYSwgYikge1xuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRVbmlmb3JtKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBcnJheTREO1xufShOREFycmF5KSk7XG5leHBvcnRzLkFycmF5NEQgPSBBcnJheTREO1xuZnVuY3Rpb24gY29weVR5cGVkQXJyYXkoYXJyYXksIGR0eXBlKSB7XG4gICAgaWYgKGR0eXBlID09IG51bGwgfHwgZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShhcnJheSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShhcnJheSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgdmFyIGJvb2wgPSBuZXcgVWludDhBcnJheShhcnJheS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2wubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVmFsTmFOKHZhbCwgJ2Jvb2wnKSkge1xuICAgICAgICAgICAgICAgIGJvb2xbaV0gPSB1dGlsLmdldE5hTignYm9vbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgYm9vbFtpXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIiArIGR0eXBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnN0YW5jZW9mVHlwZWRBcnJheShhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgYSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcbiAgICAgICAgYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG59XG5mdW5jdGlvbiBub0NvbnZlcnNpb25OZWVkZWQoYSwgZHR5cGUpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgJiYgZHR5cGUgPT09ICdmbG9hdDMyJykgfHxcbiAgICAgICAgKGEgaW5zdGFuY2VvZiBJbnQzMkFycmF5ICYmIGR0eXBlID09PSAnaW50MzInKSB8fFxuICAgICAgICAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgZHR5cGUgPT09ICdib29sJyk7XG59XG5mdW5jdGlvbiB0b1R5cGVkQXJyYXkoYSwgZHR5cGUpIHtcbiAgICBpZiAobm9Db252ZXJzaW9uTmVlZGVkKGEsIGR0eXBlKSkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgYSA9IHV0aWwuZmxhdHRlbihhKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHlUeXBlZEFycmF5KGEsIGR0eXBlKTtcbn1cbmZ1bmN0aW9uIG1ha2VaZXJvc1R5cGVkQXJyYXkoc2l6ZSwgZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT0gbnVsbCB8fCBkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoc2l6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIgKyBkdHlwZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHlwZWRBcnJheVRvRmxvYXQzMihhLCBkdHlwZSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBGbG9hdDMyQXJyYXkoYS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGFbaV07XG4gICAgICAgICAgICByZXNbaV0gPSB1dGlsLmlzVmFsTmFOKHZhbCwgZHR5cGUpID8gTmFOIDogdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gZmxvYXQzMlRvVHlwZWRBcnJheShhLCBkdHlwZSkge1xuICAgIGlmIChkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJyB8fCBkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAoZHR5cGUgPT09ICdpbnQzMicpID8gbmV3IEludDMyQXJyYXkoYS5sZW5ndGgpIDpcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBhW2ldO1xuICAgICAgICAgICAgdmFsID0gaXNOYU4odmFsKSA/IHV0aWwuZ2V0TmFOKGR0eXBlKSA6IE1hdGgucm91bmQodmFsKTtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIiArIGR0eXBlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZGFycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QQVJBTExFTElaRV9USFJFU0hPTEQgPSAzMDtcbmZ1bmN0aW9uIGNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZShpblNpemUpIHtcbiAgICBpZiAoaW5TaXplIDw9IGV4cG9ydHMuUEFSQUxMRUxJWkVfVEhSRVNIT0xEKSB7XG4gICAgICAgIHJldHVybiBpblNpemU7XG4gICAgfVxuICAgIHJldHVybiBuZWFyZXN0RGl2aXNvcihpblNpemUsIE1hdGguZmxvb3IoTWF0aC5zcXJ0KGluU2l6ZSkpKTtcbn1cbmV4cG9ydHMuY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplID0gY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplO1xuZnVuY3Rpb24gbmVhcmVzdERpdmlzb3Ioc2l6ZSwgc3RhcnQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgICAgaWYgKHNpemUgJSBpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZV91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGFzc2VydFBhcmFtc1ZhbGlkKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgIHV0aWwuYXNzZXJ0KGlucHV0LnJhbmsgPT09IGJlZ2luLmxlbmd0aCwgXCJFcnJvciBpbiBzbGljZVwiICsgaW5wdXQucmFuayArIFwiRDogTGVuZ3RoIG9mIGJlZ2luIFwiICsgYmVnaW4gKyBcIiBtdXN0IFwiICtcbiAgICAgICAgKFwibWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5IChcIiArIGlucHV0LnJhbmsgKyBcIikuXCIpKTtcbiAgICB1dGlsLmFzc2VydChpbnB1dC5yYW5rID09PSBzaXplLmxlbmd0aCwgXCJFcnJvciBpbiBzbGljZVwiICsgaW5wdXQucmFuayArIFwiRDogTGVuZ3RoIG9mIHNpemUgXCIgKyBzaXplICsgXCIgbXVzdCBcIiArXG4gICAgICAgIChcIm1hdGNoIHRoZSByYW5rIG9mIHRoZSBhcnJheSAoXCIgKyBpbnB1dC5yYW5rICsgXCIpLlwiKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5yYW5rOyArK2kpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYmVnaW5baV0gKyBzaXplW2ldIDw9IGlucHV0LnNoYXBlW2ldLCBcIkVycm9yIGluIHNsaWNlXCIgKyBpbnB1dC5yYW5rICsgXCJEOiBiZWdpbltcIiArIGkgKyBcIl0gKyBzaXplW1wiICsgaSArIFwiXSBcIiArXG4gICAgICAgICAgICAoXCIoXCIgKyAoYmVnaW5baV0gKyBzaXplW2ldKSArIFwiKSB3b3VsZCBvdmVyZmxvdyBpbnB1dC5zaGFwZVtcIiArIGkgKyBcIl0gKFwiICsgaW5wdXQuc2hhcGVbaV0gKyBcIilcIikpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0UGFyYW1zVmFsaWQgPSBhc3NlcnRQYXJhbXNWYWxpZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNsaWNlX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi4vYnJvYWRjYXN0X3V0aWxcIik7XG52YXIgQWRkU2NhbGVkTWF0UHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWRkU2NhbGVkTWF0UHJvZ3JhbShhU2hhcGUsIGJTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnLCAnQicsICdjMScsICdjMiddO1xuICAgICAgICB0aGlzLnN1cHBvcnRzQnJvYWRjYXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9XG4gICAgICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhU2hhcGUsIGJTaGFwZSk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGMxID0gZ2V0QzEoKTtcXG4gICAgICAgIGZsb2F0IGMyID0gZ2V0QzIoKTtcXG4gICAgICAgIHNldE91dHB1dChkb3QodmVjMihjMSwgYzIpLCB2ZWMyKGEsIGIpKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEFkZFNjYWxlZE1hdFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5BZGRTY2FsZWRNYXRQcm9ncmFtID0gQWRkU2NhbGVkTWF0UHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHNjYWxlZG1hdF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQXJnTWluTWF4UHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJnTWluTWF4UHJvZ3JhbShyZWR1Y2VJbmZvLCBvcCwgZmlyc3RQYXNzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHJlZHVjZUluZm8ud2luZG93U2l6ZTtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHJlZHVjZUluZm8uYmF0Y2hTaXplO1xuICAgICAgICB2YXIgaW5TaXplID0gcmVkdWNlSW5mby5pblNpemU7XG4gICAgICAgIHZhciBvdXRTaXplID0gTWF0aC5jZWlsKGluU2l6ZSAvIHdpbmRvd1NpemUpO1xuICAgICAgICBpZiAoIWZpcnN0UGFzcykge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ2Jlc3RJbmRpY2VzQScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBvdXRTaXplXTtcbiAgICAgICAgdmFyIGNvbXBPcCA9IChvcCA9PT0gJ21heCcpID8gJz4nIDogJzwnO1xuICAgICAgICB2YXIgaW5kZXhTbmlwcGV0ID0gZmlyc3RQYXNzID9cbiAgICAgICAgICAgICdpbk9mZnNldCArIGk7JyA6XG4gICAgICAgICAgICAncm91bmQoZ2V0QmVzdEluZGljZXNBKGJhdGNoLCBpbk9mZnNldCArIGkpKTsnO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgaW5PZmZzZXQgPSBvdXRJZHggKiBcIiArIHdpbmRvd1NpemUgKyBcIjtcXG5cXG4gICAgICAgIGludCBiZXN0SW5kZXggPSAwO1xcbiAgICAgICAgZmxvYXQgYmVzdFZhbHVlID0gZ2V0QShiYXRjaCwgaW5PZmZzZXQpO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIHdpbmRvd1NpemUgKyBcIjsgaSsrKSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IFwiICsgaW5kZXhTbmlwcGV0ICsgXCI7XFxuICAgICAgICAgIGZsb2F0IGNhbmRpZGF0ZSA9IGdldEEoYmF0Y2gsIGluSWR4KTtcXG4gICAgICAgICAgaWYgKGlzTmFOKGNhbmRpZGF0ZSkpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoY2FuZGlkYXRlKTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSBcIiArIGNvbXBPcCArIFwiIGJlc3RWYWx1ZSkge1xcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9IGNhbmRpZGF0ZTtcXG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpbklkeDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KGJlc3RJbmRleCkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBBcmdNaW5NYXhQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQXJnTWluTWF4UHJvZ3JhbSA9IEFyZ01pbk1heFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmdtaW5tYXhfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJyb2FkY2FzdF91dGlsID0gcmVxdWlyZShcIi4uL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIEJhdGNoTm9ybVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhdGNoTm9ybVByb2dyYW0oeFNoYXBlLCBtZWFuU2hhcGUsIHZhcmlhbmNlU2hhcGUsIG9mZnNldFNoYXBlLCBzY2FsZVNoYXBlLCB2YXJpYW5jZUVwc2lsb24pIHtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB0aGlzLnN1cHBvcnRzQnJvYWRjYXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ21lYW4nLCAndmFyaWFuY2UnXTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoeFNoYXBlLCBtZWFuU2hhcGUpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh4U2hhcGUsIHZhcmlhbmNlU2hhcGUpO1xuICAgICAgICB2YXIgb2Zmc2V0U25pcHBldCA9ICcwLjAnO1xuICAgICAgICBpZiAob2Zmc2V0U2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoeFNoYXBlLCBvZmZzZXRTaGFwZSk7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnb2Zmc2V0Jyk7XG4gICAgICAgICAgICBvZmZzZXRTbmlwcGV0ID0gJ2dldE9mZnNldEF0T3V0Q29vcmRzKCknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2FsZVNuaXBwZXQgPSAnMS4wJztcbiAgICAgICAgaWYgKHNjYWxlU2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoeFNoYXBlLCBzY2FsZVNoYXBlKTtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdzY2FsZScpO1xuICAgICAgICAgICAgc2NhbGVTbmlwcGV0ID0gJ2dldFNjYWxlQXRPdXRDb29yZHMoKSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IHhTaGFwZTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgeCA9IGdldFhBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgbWVhbiA9IGdldE1lYW5BdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRWYXJpYW5jZUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBvZmZzZXQgPSBcIiArIG9mZnNldFNuaXBwZXQgKyBcIjtcXG4gICAgICAgIGZsb2F0IHNjYWxlID0gXCIgKyBzY2FsZVNuaXBwZXQgKyBcIjtcXG4gICAgICAgIGZsb2F0IGludiA9IHNjYWxlIC8gc3FydCh2YXJpYW5jZSArIGZsb2F0KFwiICsgdmFyaWFuY2VFcHNpbG9uICsgXCIpKTtcXG4gICAgICAgIHNldE91dHB1dCgoeCAtIG1lYW4pICogaW52ICsgb2Zmc2V0KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQmF0Y2hOb3JtUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkJhdGNoTm9ybVByb2dyYW0gPSBCYXRjaE5vcm1Qcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmF0Y2hub3JtX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBicm9hZGNhc3RfdXRpbCA9IHJlcXVpcmUoXCIuLi9icm9hZGNhc3RfdXRpbFwiKTtcbmV4cG9ydHMuQUREID0gJ3JldHVybiBhICsgYjsnO1xuZXhwb3J0cy5TVUIgPSAncmV0dXJuIGEgLSBiOyc7XG5leHBvcnRzLk1VTCA9ICdyZXR1cm4gYSAqIGI7JztcbmV4cG9ydHMuRElWID0gJ3JldHVybiBhIC8gYjsnO1xuZXhwb3J0cy5FUVVBTCA9IFwiXFxuICBpZiAoaXNOYU4oYSkpIHJldHVybiBhO1xcbiAgaWYgKGlzTmFOKGIpKSByZXR1cm4gYjtcXG4gIHJldHVybiBmbG9hdChhID09IGIpO1xcblwiO1xudmFyIEJpbmFyeU9wUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluYXJ5T3BQcm9ncmFtKG9wLCBhU2hhcGUsIGJTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnLCAnQiddO1xuICAgICAgICB0aGlzLnN1cHBvcnRzQnJvYWRjYXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9XG4gICAgICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhU2hhcGUsIGJTaGFwZSk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGZsb2F0IGJpbmFyeU9wZXJhdGlvbihmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgICAgICBcIiArIG9wICsgXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgYSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGJpbmFyeU9wZXJhdGlvbihhLCBiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEJpbmFyeU9wUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkJpbmFyeU9wUHJvZ3JhbSA9IEJpbmFyeU9wUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmFyeW9wX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDbGlwUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xpcFByb2dyYW0oYVNoYXBlLCBtaW4sIG1heCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGFTaGFwZTtcbiAgICAgICAgdmFyIG1pbkZpeGVkID0gbWluLnRvRml4ZWQoMjApO1xuICAgICAgICB2YXIgbWF4Rml4ZWQgPSBtYXgudG9GaXhlZCgyMCk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XFxuICAgICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNldE91dHB1dChjbGFtcCh2YWx1ZSwgXCIgKyBtaW5GaXhlZCArIFwiLCBcIiArIG1heEZpeGVkICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ2xpcFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5DbGlwUHJvZ3JhbSA9IENsaXBQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpcF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29uY2F0X3V0aWwgPSByZXF1aXJlKFwiLi4vY29uY2F0X3V0aWxcIik7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgQ29uY2F0UHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uY2F0UHJvZ3JhbShhU2hhcGUsIGJTaGFwZSwgYXhpcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnLCAnQiddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHZhciB5QXhlcyA9IFsneVInLCAneUMnLCAneUQnLCAneVcnXTtcbiAgICAgICAgdmFyIGNvbmNhdEF4aXMgPSB5QXhlc1theGlzXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbmNhdF91dGlsLmNvbXB1dGVPdXRTaGFwZShhU2hhcGUsIGJTaGFwZSwgYXhpcyk7XG4gICAgICAgIHZhciBkVHlwZSA9IHNoYWRlcl9jb21waWxlcl8xLmdldENvb3Jkc0RhdGFUeXBlKGFTaGFwZS5sZW5ndGgpO1xuICAgICAgICB2YXIgdW5wYWNrU25pcHBldCA9IGdldFVucGFjayhhU2hhcGUubGVuZ3RoKTtcbiAgICAgICAgdmFyIHNhbXBsZUNvb3JkcyA9IGdldFNhbXBsZUNvb3JkcyhhU2hhcGUubGVuZ3RoKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyBkVHlwZSArIFwiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgXCIgKyB1bnBhY2tTbmlwcGV0ICsgXCJcXG5cXG4gICAgICAgIGZsb2F0IHZhbHVlID0gMC4wO1xcbiAgICAgICAgaWYgKFwiICsgY29uY2F0QXhpcyArIFwiIDwgXCIgKyBhU2hhcGVbYXhpc10gKyBcIikge1xcbiAgICAgICAgICB2YWx1ZSA9IGdldEEoXCIgKyBzYW1wbGVDb29yZHMgKyBcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBcIiArIGNvbmNhdEF4aXMgKyBcIiAtPSBcIiArIGFTaGFwZVtheGlzXSArIFwiO1xcbiAgICAgICAgICB2YWx1ZSA9IGdldEIoXCIgKyBzYW1wbGVDb29yZHMgKyBcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDb25jYXRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ29uY2F0UHJvZ3JhbSA9IENvbmNhdFByb2dyYW07XG5mdW5jdGlvbiBnZXRTYW1wbGVDb29yZHMocmFuaykge1xuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgIHJldHVybiAneVInO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAyKSB7XG4gICAgICAgIHJldHVybiAneVIsIHlDJztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMykge1xuICAgICAgICByZXR1cm4gJ3lSLCB5QywgeUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgICAgIHJldHVybiAneVIsIHlDLCB5RCwgeVcnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDb25jYXQgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VW5wYWNrKHJhbmspIHtcbiAgICB2YXIgcmVzID0gcmFuayA9PT0gMSA/ICdpbnQgeVIgPSBjb29yZHM7JyA6ICdpbnQgeVIgPSBjb29yZHMueDsnO1xuICAgIGlmIChyYW5rID4gMSkge1xuICAgICAgICByZXMgKz0gJ1xcbmludCB5QyA9IGNvb3Jkcy55Oyc7XG4gICAgfVxuICAgIGlmIChyYW5rID4gMikge1xuICAgICAgICByZXMgKz0gJ1xcbmludCB5RCA9IGNvb3Jkcy56Oyc7XG4gICAgfVxuICAgIGlmIChyYW5rID4gMykge1xuICAgICAgICByZXMgKz0gJ1xcbmludCB5VyA9IGNvb3Jkcy53Oyc7XG4gICAgfVxuICAgIGlmIChyYW5rID4gNCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkNvbmNhdCBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4uL2NvbnZfdXRpbFwiKTtcbnZhciBDb252MkREZXJXZWlnaHRzUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjJERGVyV2VpZ2h0c1Byb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ2R5J107XG4gICAgICAgIHZhciBfYSA9IGNvbnZJbmZvLm91dFNoYXBlLCB5TnVtUm93cyA9IF9hWzBdLCB5TnVtQ29scyA9IF9hWzFdLCBvdXREZXB0aCA9IF9hWzJdO1xuICAgICAgICB2YXIgX2IgPSBjb252SW5mby5pblNoYXBlLCB4TnVtUm93cyA9IF9iWzBdLCB4TnVtQ29scyA9IF9iWzFdLCBpbkRlcHRoID0gX2JbMl07XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVXZWlnaHRzU2hhcGU0RChpbkRlcHRoLCBvdXREZXB0aCwgY29udkluZm8uZmlsdGVySGVpZ2h0LCBjb252SW5mby5maWx0ZXJXaWR0aCk7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHdSID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgd0MgPSBjb29yZHMueTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIGR5KDosIDosIGQyKSB0byBnZXQgZHcod1IsIHdDLCBkMSwgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8IFwiICsgeU51bVJvd3MgKyBcIjsgeVIrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB3UiArIHlSICogXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiAtIFwiICsgcGFkVG9wICsgXCI7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyB4TnVtUm93cyArIFwiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8IFwiICsgeU51bUNvbHMgKyBcIjsgeUMrKykge1xcbiAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiBcIiArIHN0cmlkZVdpZHRoICsgXCIgLSBcIiArIHBhZExlZnQgKyBcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiICsgeE51bUNvbHMgKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeSh5UiwgeUMsIGQyKTtcXG4gICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbnYyRERlcldlaWdodHNQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ29udjJERGVyV2VpZ2h0c1Byb2dyYW0gPSBDb252MkREZXJXZWlnaHRzUHJvZ3JhbTtcbnZhciBDb252MkREZXJJbnB1dFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnYyRERlcklucHV0UHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5JywgJ1cnXTtcbiAgICAgICAgdmFyIF9hID0gY29udkluZm8ub3V0U2hhcGUsIHlSb3dzID0gX2FbMF0sIHlDb2xzID0gX2FbMV0sIG91dERlcHRoID0gX2FbMl07XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5pblNoYXBlO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XFxuXFxuICAgICAgICBpdmVjMiBkeUNvcm5lciA9IGNvb3Jkcy54eSAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIiArIHN0cmlkZUhlaWdodCArIFwiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiICsgeVJvd3MgKyBcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBpbnQgd1JQZXJtID0gXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIiAtIDEgLSB3UjtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiICsgc3RyaWRlV2lkdGggKyBcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiICsgeUNvbHMgKyBcIi4wIHx8IGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGludCB3Q1Blcm0gPSBcIiArIGZpbHRlcldpZHRoICsgXCIgLSAxIC0gd0M7XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8IFwiICsgb3V0RGVwdGggKyBcIjsgZDIrKykge1xcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoaWR5UiwgaWR5QywgZDIpO1xcbiAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDb252MkREZXJJbnB1dFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Db252MkREZXJJbnB1dFByb2dyYW0gPSBDb252MkREZXJJbnB1dFByb2dyYW07XG52YXIgQ29udjJERGVyQmlhc1Byb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnYyRERlckJpYXNQcm9ncmFtKHlTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5J107XG4gICAgICAgIHZhciB5TnVtUm93cyA9IHlTaGFwZVswXSwgeU51bUNvbHMgPSB5U2hhcGVbMV0sIG91dHB1dERlcHRoID0geVNoYXBlWzJdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW291dHB1dERlcHRoXTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaW50IGQyID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICBmbG9hdCBkZXJCaWFzID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8IFwiICsgeU51bVJvd3MgKyBcIjsgeVIrKykge1xcbiAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIgKyB5TnVtQ29scyArIFwiOyB5QysrKSB7XFxuICAgICAgICAgICAgZGVyQmlhcyArPSBnZXREeSh5UiwgeUMsIGQyKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRlckJpYXMpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDb252MkREZXJCaWFzUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvbnYyRERlckJpYXNQcm9ncmFtID0gQ29udjJERGVyQmlhc1Byb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252X2JhY2twcm9wX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb252MkRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb252MkRQcm9ncmFtKGNvbnZJbmZvLCBoYXNCaWFzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdXJ107XG4gICAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmlhcycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgdmFyIGJpYXNTbmlwcGV0ID0gaGFzQmlhcyA/ICdkb3RQcm9kICs9IGdldEJpYXMoZDIpOycgOiAnJztcbiAgICAgICAgdmFyIF9hID0gY29udkluZm8uaW5TaGFwZSwgeE51bVJvd3MgPSBfYVswXSwgeE51bUNvbHMgPSBfYVsxXSwgaW5wdXREZXB0aCA9IF9hWzJdO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBpbnB1dERlcHRoTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKGlucHV0RGVwdGggLyA0KSAqIDQ7XG4gICAgICAgIHZhciBpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9IGlucHV0RGVwdGggJSA0O1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiwgXCIgKyBzdHJpZGVXaWR0aCArIFwiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLno7XFxuXFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueHkgKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBnZXQgeSh5UiwgeUMsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyB4TnVtUm93cyArIFwiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XFxuXFxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIHhOdW1Db2xzICsgXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIjsgZDEgKz0gNCkge1xcbiAgICAgICAgICAgICAgdmVjNCB4VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0WCh4UiwgeEMsIGQxKSxcXG4gICAgICAgICAgICAgICAgZ2V0WCh4UiwgeEMsIGQxICsgMSksXFxuICAgICAgICAgICAgICAgIGdldFgoeFIsIHhDLCBkMSArIDIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKHhSLCB4QywgZDEgKyAzKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHZlYzQgd1ZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMywgZDIpXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChcIiArIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPVxcbiAgICAgICAgICAgICAgICBnZXRYKHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIikgKlxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiwgZDIpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzIgeFZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgIGdldFgoeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiKSxcXG4gICAgICAgICAgICAgICAgZ2V0WCh4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAxKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHZlYzIgd1ZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSwgZDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIiArIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgZ2V0WCh4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDEpLFxcbiAgICAgICAgICAgICAgICBnZXRYKHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgdmVjMyB3VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMiwgZDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBcIiArIGJpYXNTbmlwcGV0ICsgXCJcXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29udjJEUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvbnYyRFByb2dyYW0gPSBDb252MkRQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udl9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGVwdGh3aXNlQ29udjJEUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVwdGh3aXNlQ29udjJEUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnVyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG4gICAgICAgIHZhciB4TnVtUm93cyA9IGNvbnZJbmZvLmluU2hhcGVbMV07XG4gICAgICAgIHZhciB4TnVtQ29scyA9IGNvbnZJbmZvLmluU2hhcGVbMl07XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIGNoYW5uZWxNdWwgPSBjb252SW5mby5jaGFubmVsTXVsO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiwgXCIgKyBzdHJpZGVXaWR0aCArIFwiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQxID0gZDIgLyBcIiArIGNoYW5uZWxNdWwgKyBcIjtcXG4gICAgICAgIGludCBxID0gZDIgLSBkMSAqIFwiICsgY2hhbm5lbE11bCArIFwiO1xcblxcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgcSkgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICAvLyBUT0RPKGRzbWlsa292KTogRmxhdHRlbiB0aGUgdHdvIGZvciBsb29wcyBhbmQgdmVjNCB0aGUgb3BlcmF0aW9ucy5cXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyB4TnVtUm93cyArIFwiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XFxuXFxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIHhOdW1Db2xzICsgXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcod1IsIHdDLCBkMSwgcSk7XFxuICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsICogd1ZhbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBEZXB0aHdpc2VDb252MkRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuRGVwdGh3aXNlQ29udjJEUHJvZ3JhbSA9IERlcHRod2lzZUNvbnYyRFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb252X2dwdV9kZXB0aHdpc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ29weTJEUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29weTJEUHJvZ3JhbShzcmNOdW1Db2xzLCBkZXN0TnVtQ29scykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3NvdXJjZSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdW5pZm9ybSBpdmVjMiBzb3VyY2VTdGFydDtcXG4gICAgICB1bmlmb3JtIGl2ZWMyIGRlc3RTdGFydDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBkZXN0Q29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCkgLSBkZXN0U3RhcnQ7XFxuICAgICAgICBpbnQgaW5kZXggPSBkZXN0Q29vcmRzLnggKiBcIiArIGRlc3ROdW1Db2xzICsgXCIgKyBkZXN0Q29vcmRzLnk7XFxuICAgICAgICBpbnQgciA9IGluZGV4IC8gXCIgKyBzcmNOdW1Db2xzICsgXCI7XFxuICAgICAgICBpdmVjMiBzb3VyY2VDb29yZHMgPSBzb3VyY2VTdGFydCArIGl2ZWMyKHIsIGluZGV4IC0gciAqIFwiICsgc3JjTnVtQ29scyArIFwiKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRTb3VyY2Uoc291cmNlQ29vcmRzLngsIHNvdXJjZUNvb3Jkcy55KSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgQ29weTJEUHJvZ3JhbS5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jID0gZnVuY3Rpb24gKHNvdXJjZVN0YXJ0LCBkZXN0U3RhcnQsIGRlc3RTaXplKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ3BncHUsIHdlYkdMUHJvZ3JhbSkge1xuICAgICAgICAgICAgZ3BncHUuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb24oZGVzdFN0YXJ0WzBdLCBkZXN0U2l6ZVswXSwgZGVzdFN0YXJ0WzFdLCBkZXN0U2l6ZVsxXSk7XG4gICAgICAgICAgICB2YXIgc291cmNlU3RhcnRDUkxvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sICdzb3VyY2VTdGFydCcpO1xuICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTJpKHNvdXJjZVN0YXJ0Q1JMb2MsIHNvdXJjZVN0YXJ0WzBdLCBzb3VyY2VTdGFydFsxXSk7XG4gICAgICAgICAgICB2YXIgZGVzdFN0YXJ0Q1JMb2MgPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCAnZGVzdFN0YXJ0Jyk7XG4gICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtMmkoZGVzdFN0YXJ0Q1JMb2MsIGRlc3RTdGFydFswXSwgZGVzdFN0YXJ0WzFdKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb3B5MkRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ29weTJEUHJvZ3JhbSA9IENvcHkyRFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3B5X2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdwZ3B1X3V0aWwgPSByZXF1aXJlKFwiLi9ncGdwdV91dGlsXCIpO1xudmFyIHRleF91dGlsID0gcmVxdWlyZShcIi4vdGV4X3V0aWxcIik7XG52YXIgd2ViZ2xfdXRpbCA9IHJlcXVpcmUoXCIuL3dlYmdsX3V0aWxcIik7XG52YXIgR1BHUFVDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHUEdQVUNvbnRleHQoZ2wpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlID0gZmFsc2U7XG4gICAgICAgIGlmIChnbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gZ3BncHVfdXRpbC5jcmVhdGVXZWJHTENvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJykgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uID1cbiAgICAgICAgICAgICAgICB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ09FU190ZXh0dXJlX2Zsb2F0Jyk7XG4gICAgICAgICAgICB0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgIHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbiA9XG4gICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC5nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb3NlQ29udGV4dEV4dGVuc2lvbiA9XG4gICAgICAgICAgICB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ1dFQkdMX2xvc2VfY29udGV4dCcpO1xuICAgICAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9HRVRfQlVGRkVSX1NVQl9EQVRBX0FTWU5DX0VYVEVOU0lPTl9FTkFCTEVEJykpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uID1cbiAgICAgICAgICAgICAgICB0aGlzLmdsLmdldEV4dGVuc2lvbignV0VCR0xfZ2V0X2J1ZmZlcl9zdWJfZGF0YV9hc3luYycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyID0gZ3BncHVfdXRpbC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5nbCk7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBncGdwdV91dGlsLmNyZWF0ZUluZGV4QnVmZmVyKHRoaXMuZ2wpO1xuICAgICAgICB0aGlzLmZyYW1lYnVmZmVyID0gd2ViZ2xfdXRpbC5jcmVhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICB9XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAodGhpcy5wcm9ncmFtICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGlzcG9zaW5nIGEgR1BHUFVDb250ZXh0IHRoYXQgc3RpbGwgaGFzIGEgYm91bmQgV2ViR0xQcm9ncmFtLicgK1xuICAgICAgICAgICAgICAgICcgVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgcHJvZ3JhbSB3aXRoICcgK1xuICAgICAgICAgICAgICAgICdHUEdQVUNvbnRleHQuZGVsZXRlUHJvZ3JhbSBiZWZvcmUgZGlzcG9zaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm91dHB1dFRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBvdXRwdXQgbWF0cml4ICcgK1xuICAgICAgICAgICAgICAgICd0ZXh0dXJlLiAgVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgb3V0cHV0ICcgK1xuICAgICAgICAgICAgICAgICdtYXRyaXggdGV4dHVyZSB3aXRoIEdQR1BVQ29udGV4dC5kZWxldGVNYXRyaXhUZXh0dXJlIGJlZm9yZSAnICtcbiAgICAgICAgICAgICAgICAnZGlzcG9zaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5maW5pc2goKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKF90aGlzLmZyYW1lYnVmZmVyKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGVsZXRlQnVmZmVyKF90aGlzLnZlcnRleEJ1ZmZlcik7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGVsZXRlQnVmZmVyKF90aGlzLmluZGV4QnVmZmVyKTsgfSk7XG4gICAgICAgIHRoaXMubG9zZUNvbnRleHRFeHRlbnNpb24ubG9zZUNvbnRleHQoKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmVuYWJsZUF1dG9tYXRpY0RlYnVnVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUgPSBlbmFibGVkO1xuICAgICAgICB3ZWJnbF91dGlsLmVuYWJsZURlYnVnV2ViR0xFcnJvckNoZWNraW5nKGVuYWJsZWQpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIGdwZ3B1X3V0aWwuY3JlYXRlTWF0cml4VGV4dHVyZSh0aGlzLmdsLCByb3dzLCBjb2x1bW5zKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHBpeGVscykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBncGdwdV91dGlsLnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSh0aGlzLmdsLCB0ZXh0dXJlLCBwaXhlbHMpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIGdwZ3B1X3V0aWwuY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZSh0aGlzLmdsLCByb3dzLCBjb2x1bW5zKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZGVsZXRlTWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dFRleHR1cmUgPT09IHRleHR1cmUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKHRoaXMuZ2wsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudXBsb2FkTWF0cml4VG9UZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB2YXIgbnVtQ2hhbm5lbHMgPSAxO1xuICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC51cGxvYWRNYXRyaXhUb1RleHR1cmUodGhpcy5nbCwgdGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4LCBudW1DaGFubmVscyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIGdwZ3B1X3V0aWwudXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlKHRoaXMuZ2wsIHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcih0ZXh0dXJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC5kb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKF90aGlzLmdsLCByb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVRleHR1cmVBc3luYyA9IGZ1bmN0aW9uICh0ZXh0dXJlLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRvd25sb2FkIG1hdHJpeCBmcm9tIG91dHB1dCB0ZXh0dXJlIGFzeW5jaHJvbm91c2x5LCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIldFQkdMX2dldF9idWZmZXJfc3ViX2RhdGFfYXN5bmMgaXMgbm90IGVuYWJsZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXJBc3luYyh0ZXh0dXJlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBncGdwdV91dGlsLmRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmVBc3luYyhfdGhpcy5nbCwgX3RoaXMuZ2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uLCByb3dzLCBjb2x1bW5zKTsgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeEZyb21SR0JBQ29sb3JUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKHRleHR1cmUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdwZ3B1X3V0aWwuZG93bmxvYWRNYXRyaXhGcm9tUkdCQUNvbG9yVGV4dHVyZShfdGhpcy5nbCwgcm93cywgY29sdW1ucywgY2hhbm5lbHMpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKHRleHR1cmUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdwZ3B1X3V0aWwuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZShfdGhpcy5nbCwgcm93cywgY29sdW1ucyk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVQcm9ncmFtID0gZnVuY3Rpb24gKGZyYWdtZW50U2hhZGVyU291cmNlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHdlYmdsX3V0aWwuY3JlYXRlRnJhZ21lbnRTaGFkZXIoZ2wsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgICAgICAgdmFyIHZlcnRleFNoYWRlciA9IGdwZ3B1X3V0aWwuY3JlYXRlVmVydGV4U2hhZGVyKGdsKTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSB3ZWJnbF91dGlsLmNyZWF0ZVByb2dyYW0oZ2wpO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwubGlua1Byb2dyYW0oZ2wsIHByb2dyYW0pO1xuICAgICAgICBpZiAodGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZVByb2dyYW0oZ2wsIHByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kZWxldGVQcm9ncmFtID0gZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHByb2dyYW0gPT09IHRoaXMucHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3JhbSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRQcm9ncmFtID0gZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgaWYgKCh0aGlzLnByb2dyYW0gIT0gbnVsbCkgJiYgdGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZVByb2dyYW0odGhpcy5nbCwgdGhpcy5wcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC51c2VQcm9ncmFtKHByb2dyYW0pOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZ2V0VW5pZm9ybUxvY2F0aW9uID0gZnVuY3Rpb24gKHByb2dyYW0sIHVuaWZvcm1OYW1lKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB3ZWJnbF91dGlsLmdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93KHRoaXMuZ2wsIHByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTG9jYXRpb24gPSBmdW5jdGlvbiAocHJvZ3JhbSwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJ1dGUpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyA9IGZ1bmN0aW9uIChwcm9ncmFtLCB1bmlmb3JtTmFtZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRJbnB1dE1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAoaW5wdXRNYXRyaXhUZXh0dXJlLCB1bmlmb3JtTG9jYXRpb24sIHRleHR1cmVVbml0KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO1xuICAgICAgICB3ZWJnbF91dGlsLmJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXIodGhpcy5nbCwgdGhpcy5wcm9ncmFtLCBpbnB1dE1hdHJpeFRleHR1cmUsIHVuaWZvcm1Mb2NhdGlvbiwgdGV4dHVyZVVuaXQpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKG91dHB1dE1hdHJpeFRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyKG91dHB1dE1hdHJpeFRleHR1cmUsIGNvbHVtbnMsIHJvd3MpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKG91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgICAgICB0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIob3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uID0gZnVuY3Rpb24gKHN0YXJ0Um93LCBudW1Sb3dzLCBzdGFydENvbHVtbiwgbnVtQ29sdW1ucykge1xuICAgICAgICB0aGlzLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyKHN0YXJ0Q29sdW1uLCBzdGFydFJvdywgbnVtQ29sdW1ucywgbnVtUm93cyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dFBhY2tlZE1hdHJpeFdyaXRlUmVnaW9uID0gZnVuY3Rpb24gKHN0YXJ0Um93LCBudW1Sb3dzLCBzdGFydENvbHVtbiwgbnVtQ29sdW1ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldE91dHB1dFBhY2tlZE1hdHJpeFdyaXRlUmVnaW9uIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZGVidWdWYWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZXhlY3V0ZVByb2dyYW0gPSBmdW5jdGlvbiAoYXR0cmliTG9jYXRpb25zKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBncGdwdV91dGlsLmJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtcyhnbCwgdGhpcy5wcm9ncmFtLCB0aGlzLnZlcnRleEJ1ZmZlciwgYXR0cmliTG9jYXRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWdWYWxpZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5ibG9ja1VudGlsQWxsUHJvZ3JhbXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKHRoaXMuZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdsLmZpbmlzaCgpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUucnVuUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlGbikge1xuICAgICAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJykgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1blF1ZXJ5V2ViR0wyKHF1ZXJ5Rm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJ1blF1ZXJ5V2ViR0wxKHF1ZXJ5Rm4pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5ydW5RdWVyeVdlYkdMMiA9IGZ1bmN0aW9uIChiZW5jaG1hcmspIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV4dCA9IHdlYmdsX3V0aWwuZ2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLCAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMicpO1xuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLmdsLmNyZWF0ZVF1ZXJ5KCk7XG4gICAgICAgIHRoaXMuZ2wuYmVnaW5RdWVyeShleHQuVElNRV9FTEFQU0VEX0VYVCwgcXVlcnkpO1xuICAgICAgICBiZW5jaG1hcmsoKTtcbiAgICAgICAgdGhpcy5nbC5lbmRRdWVyeShleHQuVElNRV9FTEFQU0VEX0VYVCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcXVlcnlHUFUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF2YWlsYWJsZSA9IF90aGlzLmdsXG4gICAgICAgICAgICAgICAgICAgIC5nZXRRdWVyeVBhcmFtZXRlcihxdWVyeSwgX3RoaXMuZ2wuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSk7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2pvaW50ID0gX3RoaXMuZ2wuZ2V0UGFyYW1ldGVyKGV4dC5HUFVfRElTSk9JTlRfRVhUKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlICYmICFkaXNqb2ludDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZ2V0VGltZUVsYXBzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVFbGFwc2VkTmFub3MgPSBfdGhpcy5nbFxuICAgICAgICAgICAgICAgICAgICAuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnksIF90aGlzLmdsLlFVRVJZX1JFU1VMVCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aW1lRWxhcHNlZE5hbm9zIC8gMTAwMDAwMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlc29sdmVXaXRoV2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Rpc2pvaW50IHF1ZXJ5IHRpbWVyIG5ldmVyIGF2YWlsYWJsZS4nKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKC0xKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB1dGlsLnJlcGVhdGVkVHJ5KHF1ZXJ5R1BVKS50aGVuKGdldFRpbWVFbGFwc2VkKS5jYXRjaChyZXNvbHZlV2l0aFdhcm5pbmcpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUucnVuUXVlcnlXZWJHTDEgPSBmdW5jdGlvbiAoYmVuY2htYXJrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBleHQgPSB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeScpO1xuICAgICAgICB2YXIgcXVlcnkgPSBleHQuY3JlYXRlUXVlcnlFWFQoKTtcbiAgICAgICAgZXh0LmJlZ2luUXVlcnlFWFQoZXh0LlRJTUVfRUxBUFNFRF9FWFQsIHF1ZXJ5KTtcbiAgICAgICAgYmVuY2htYXJrKCk7XG4gICAgICAgIGV4dC5lbmRRdWVyeUVYVChleHQuVElNRV9FTEFQU0VEX0VYVCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcXVlcnlHUFUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF2YWlsYWJsZSA9IGV4dC5nZXRRdWVyeU9iamVjdEVYVChxdWVyeSwgZXh0LlFVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzam9pbnQgPSBfdGhpcy5nbC5nZXRQYXJhbWV0ZXIoZXh0LkdQVV9ESVNKT0lOVF9FWFQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGUgJiYgIWRpc2pvaW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBnZXRUaW1lRWxhcHNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZUVsYXBzZWROYW5vcyA9IGV4dC5nZXRRdWVyeU9iamVjdEVYVChxdWVyeSwgZXh0LlFVRVJZX1JFU1VMVF9FWFQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGltZUVsYXBzZWROYW5vcyAvIDEwMDAwMDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXNvbHZlV2l0aFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNqb2ludCBxdWVyeSB0aW1lciBuZXZlciBhdmFpbGFibGUuJyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgtMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdXRpbC5yZXBlYXRlZFRyeShxdWVyeUdQVSkudGhlbihnZXRUaW1lRWxhcHNlZCkuY2F0Y2gocmVzb2x2ZVdpdGhXYXJuaW5nKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RHJpdmVyU2V0dXAgPSBmdW5jdGlvbiAodGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB3ZWJnbF91dGlsLmJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKHRoaXMuZ2wsIHRleHR1cmUsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICBpZiAodGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZUZyYW1lYnVmZmVyKHRoaXMuZ2wpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RHJpdmVyVGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dFRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC5iaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcih0aGlzLmdsLCB0aGlzLm91dHB1dFRleHR1cmUsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlRnJhbWVidWZmZXIodGhpcy5nbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcih0aGlzLmdsLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeERyaXZlciA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBkb3dubG9hZEFuZERlY29kZSkge1xuICAgICAgICB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyU2V0dXAodGV4dHVyZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBkb3dubG9hZEFuZERlY29kZSgpO1xuICAgICAgICB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyVGVhcmRvd24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhEcml2ZXJBc3luYyA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBkb3dubG9hZEFuZERlY29kZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlclNldHVwKHRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBkb3dubG9hZEFuZERlY29kZSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlclRlYXJkb3duKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc3VsdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyID0gZnVuY3Rpb24gKG91dHB1dE1hdHJpeFRleHR1cmVNYXliZVBhY2tlZCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB3ZWJnbF91dGlsLmJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKGdsLCBvdXRwdXRNYXRyaXhUZXh0dXJlTWF5YmVQYWNrZWQsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICBpZiAodGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZUZyYW1lYnVmZmVyKGdsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFRleHR1cmUgPSBvdXRwdXRNYXRyaXhUZXh0dXJlTWF5YmVQYWNrZWQ7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5zY2lzc29yKDAsIDAsIHdpZHRoLCBoZWlnaHQpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXIgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5zY2lzc29yKHgsIHksIHdpZHRoLCBoZWlnaHQpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudGhyb3dJZkRpc3Bvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gdXNlIGRpc3Bvc2VkIEdQR1BVQ29udGV4dC4nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS50aHJvd0lmTm9Qcm9ncmFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9ncmFtID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gR1BVIHByb2dyYW0gaXMgY3VycmVudGx5IHNldC4nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdQR1BVQ29udGV4dDtcbn0oKSk7XG5leHBvcnRzLkdQR1BVQ29udGV4dCA9IEdQR1BVQ29udGV4dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdwZ3B1X2NvbnRleHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgc2hhZGVyX2NvbXBpbGVyID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIEFUVFJJQlVURV9OQU1FUyA9IFsndXYnLCAnY2xpcFNwYWNlUG9zJ107XG52YXIgTkFOX1VOSUZPUk1fTkFNRSA9ICdOYU4nO1xuZnVuY3Rpb24gc2hvdWxkVXBsb2FkTmFOVW5pZm9ybSgpIHtcbiAgICByZXR1cm4gIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJyk7XG59XG5mdW5jdGlvbiBjb21waWxlUHJvZ3JhbShncGdwdSwgcHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQpIHtcbiAgICB2YXIgdXNlckNvZGUgPSBwcm9ncmFtLnVzZXJDb2RlO1xuICAgIHZhciBpbnB1dEluZm9zID0gaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQsIGkpIHtcbiAgICAgICAgdmFyIHNoYXBlSW5mbyA9IHtcbiAgICAgICAgICAgIGxvZ2ljYWxTaGFwZTogaW5wdXQuc2hhcGUsXG4gICAgICAgICAgICB0ZXhTaGFwZTogaW5wdXQuZ2V0VGV4dHVyZVNoYXBlUkMoKSxcbiAgICAgICAgICAgIHRleHR1cmVUeXBlOiBpbnB1dC5nZXREYXRhKCkudGV4dHVyZVR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogcHJvZ3JhbS52YXJpYWJsZU5hbWVzW2ldLCBzaGFwZUluZm86IHNoYXBlSW5mbyB9O1xuICAgIH0pO1xuICAgIHZhciBpblNoYXBlSW5mb3MgPSBpbnB1dEluZm9zLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zaGFwZUluZm87IH0pO1xuICAgIHZhciBvdXRTaGFwZUluZm8gPSB7XG4gICAgICAgIGxvZ2ljYWxTaGFwZTogb3V0cHV0LnNoYXBlLFxuICAgICAgICB0ZXhTaGFwZTogb3V0cHV0LmdldFRleHR1cmVTaGFwZVJDKCksXG4gICAgICAgIHRleHR1cmVUeXBlOiBvdXRwdXQuZ2V0RGF0YSgpLnRleHR1cmVUeXBlXG4gICAgfTtcbiAgICB2YXIgc291cmNlID0gc2hhZGVyX2NvbXBpbGVyLm1ha2VTaGFkZXIoaW5wdXRJbmZvcywgb3V0U2hhcGVJbmZvLCB1c2VyQ29kZSwgcHJvZ3JhbS5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9PT0gdHJ1ZSk7XG4gICAgdmFyIHdlYkdMUHJvZ3JhbSA9IGdwZ3B1LmNyZWF0ZVByb2dyYW0oc291cmNlKTtcbiAgICB2YXIgdW5pZm9ybUxvY2F0aW9ucyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZ3JhbS52YXJpYWJsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB1bmlmb3JtTmFtZSA9IHByb2dyYW0udmFyaWFibGVOYW1lc1tpXTtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uc1t1bmlmb3JtTmFtZV0gPVxuICAgICAgICAgICAgZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICAgIH1cbiAgICB2YXIgYXR0cmlidXRlTG9jYXRpb25zID0ge307XG4gICAgQVRUUklCVVRFX05BTUVTLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBhdHRyaWJ1dGVMb2NhdGlvbnNbYXR0cmlidXRlXSA9XG4gICAgICAgICAgICBncGdwdS5nZXRBdHRyaWJ1dGVMb2NhdGlvbih3ZWJHTFByb2dyYW0sIGF0dHJpYnV0ZSk7XG4gICAgfSk7XG4gICAgaWYgKHNob3VsZFVwbG9hZE5hTlVuaWZvcm0oKSkge1xuICAgICAgICB1bmlmb3JtTG9jYXRpb25zW05BTl9VTklGT1JNX05BTUVdID1cbiAgICAgICAgICAgIGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sIE5BTl9VTklGT1JNX05BTUUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgd2ViR0xQcm9ncmFtOiB3ZWJHTFByb2dyYW0sXG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnM6IHVuaWZvcm1Mb2NhdGlvbnMsXG4gICAgICAgIGF0dHJpYnV0ZUxvY2F0aW9uczogYXR0cmlidXRlTG9jYXRpb25zLFxuICAgICAgICBncGdwdTogZ3BncHUsXG4gICAgICAgIGluU2hhcGVJbmZvczogaW5TaGFwZUluZm9zLFxuICAgICAgICBvdXRTaGFwZUluZm86IG91dFNoYXBlSW5mb1xuICAgIH07XG59XG5leHBvcnRzLmNvbXBpbGVQcm9ncmFtID0gY29tcGlsZVByb2dyYW07XG5mdW5jdGlvbiB2YWxpZGF0ZUJpbmFyeUFuZFByb2dyYW0oc2hhcGVJbmZvcywgaW5wdXRzKSB7XG4gICAgaWYgKHNoYXBlSW5mb3MubGVuZ3RoICE9PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIFwiICsgc2hhcGVJbmZvcy5sZW5ndGggKyBcIiBpbnB1dHMsIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJ3YXMgZXhlY3V0ZWQgd2l0aCBcIiArIGlucHV0cy5sZW5ndGggKyBcIiBpbnB1dHNcIikpO1xuICAgIH1cbiAgICBzaGFwZUluZm9zLmZvckVhY2goZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgdmFyIHNoYXBlQSA9IHMubG9naWNhbFNoYXBlO1xuICAgICAgICB2YXIgdGV4U2hhcGVBID0gcy50ZXhTaGFwZTtcbiAgICAgICAgdmFyIHNoYXBlQiA9IGlucHV0c1tpXS5zaGFwZTtcbiAgICAgICAgdmFyIHRleFNoYXBlQiA9IGlucHV0c1tpXS5nZXRUZXh0dXJlU2hhcGVSQygpO1xuICAgICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoc2hhcGVBLCBzaGFwZUIpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgc2hhcGVzIHRoYW4gXCIgK1xuICAgICAgICAgICAgICAgIChcInRoZSBjdXJyZW50IGFyZ3MuIFNoYXBlcyBcIiArIHNoYXBlQSArIFwiIGFuZCBcIiArIHNoYXBlQiArIFwiIG11c3QgbWF0Y2hcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbCh0ZXhTaGFwZUEsIHRleFNoYXBlQikpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCB0ZXh0dXJlIHNoYXBlcyB0aGFuIHRoZVwiICtcbiAgICAgICAgICAgICAgICAoXCIgY3VycmVudCBhcmdzLiBTaGFwZSBcIiArIHRleFNoYXBlQSArIFwiIGFuZCBcIiArIHRleFNoYXBlQiArIFwiIG11c3QgbWF0Y2hcIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBydW5Qcm9ncmFtKGJpbmFyeSwgaW5wdXRzLCBvdXRwdXQsIGN1c3RvbVNldHVwKSB7XG4gICAgdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKGJpbmFyeS5pblNoYXBlSW5mb3MsIGlucHV0cyk7XG4gICAgdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKFtiaW5hcnkub3V0U2hhcGVJbmZvXSwgW291dHB1dF0pO1xuICAgIHZhciBvdXRUZXggPSBvdXRwdXQuZ2V0VGV4dHVyZSgpO1xuICAgIHZhciBvdXRUZXhTaGFwZSA9IG91dHB1dC5nZXRUZXh0dXJlU2hhcGVSQygpO1xuICAgIHZhciBncGdwdSA9IGJpbmFyeS5ncGdwdTtcbiAgICBncGdwdS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKG91dFRleCwgb3V0VGV4U2hhcGVbMF0sIG91dFRleFNoYXBlWzFdKTtcbiAgICBncGdwdS5zZXRQcm9ncmFtKGJpbmFyeS53ZWJHTFByb2dyYW0pO1xuICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCwgaSkge1xuICAgICAgICB2YXIgdGV4ID0gaW5wdXQuZ2V0VGV4dHVyZSgpO1xuICAgICAgICB2YXIgdmFyaWFibGVOYW1lID0gYmluYXJ5LnByb2dyYW0udmFyaWFibGVOYW1lc1tpXTtcbiAgICAgICAgdmFyIHZhcmlhYmxlVW5pZm9ybUxvY2F0aW9uID0gYmluYXJ5LnVuaWZvcm1Mb2NhdGlvbnNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHRleCwgdmFyaWFibGVVbmlmb3JtTG9jYXRpb24sIGkpO1xuICAgIH0pO1xuICAgIGlmIChzaG91bGRVcGxvYWROYU5Vbmlmb3JtKCkpIHtcbiAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFmKGJpbmFyeS51bmlmb3JtTG9jYXRpb25zW05BTl9VTklGT1JNX05BTUVdLCBOYU4pO1xuICAgIH1cbiAgICBpZiAoY3VzdG9tU2V0dXAgIT0gbnVsbCkge1xuICAgICAgICBjdXN0b21TZXR1cChncGdwdSwgYmluYXJ5LndlYkdMUHJvZ3JhbSk7XG4gICAgfVxuICAgIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKGJpbmFyeS5hdHRyaWJ1dGVMb2NhdGlvbnMpO1xufVxuZXhwb3J0cy5ydW5Qcm9ncmFtID0gcnVuUHJvZ3JhbTtcbmZ1bmN0aW9uIG1ha2VTaGFkZXJLZXkocHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQpIHtcbiAgICB2YXIga2V5SW5wdXRzID0gJyc7XG4gICAgaW5wdXRzLmNvbmNhdChvdXRwdXQpLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAga2V5SW5wdXRzICs9IHguc2hhcGUgKyBcIl9cIiArIHguZ2V0VGV4dHVyZVNoYXBlUkMoKTtcbiAgICB9KTtcbiAgICB2YXIga2V5VXNlckNvZGUgPSBwcm9ncmFtLnVzZXJDb2RlO1xuICAgIHZhciBrZXlCcm9hZGNhc3QgPSAocHJvZ3JhbS5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9PT0gdHJ1ZSkudG9TdHJpbmcoKTtcbiAgICB2YXIga2V5ID0gcHJvZ3JhbS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGtleSArPSAnXycgKyBrZXlCcm9hZGNhc3QgKyAnXycgKyBrZXlJbnB1dHMgKyAnXycgKyBrZXlVc2VyQ29kZTtcbiAgICByZXR1cm4ga2V5O1xufVxuZXhwb3J0cy5tYWtlU2hhZGVyS2V5ID0gbWFrZVNoYWRlcktleTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdwZ3B1X21hdGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xudmFyIHRleF91dGlsID0gcmVxdWlyZShcIi4vdGV4X3V0aWxcIik7XG52YXIgd2ViZ2xfdXRpbCA9IHJlcXVpcmUoXCIuL3dlYmdsX3V0aWxcIik7XG5mdW5jdGlvbiBnZXRXZWJHTENvbnRleHRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgZGVwdGg6IGZhbHNlLFxuICAgICAgICBzdGVuY2lsOiBmYWxzZSxcbiAgICAgICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdHJ1ZVxuICAgIH07XG59XG5leHBvcnRzLmdldFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMgPSBnZXRXZWJHTENvbnRleHRBdHRyaWJ1dGVzO1xuZnVuY3Rpb24gY3JlYXRlV2ViR0xDb250ZXh0KGNhbnZhcykge1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZ2V0V2ViR0xDb250ZXh0QXR0cmlidXRlcygpO1xuICAgIHZhciBnbDtcbiAgICBpZiAoY2FudmFzICE9IG51bGwpIHtcbiAgICAgICAgZ2wgPSB3ZWJnbF91dGlsLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMoY2FudmFzLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdsID0gd2ViZ2xfdXRpbC5jcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHQoYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5CTEVORCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLkRJVEhFUik7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5TQU1QTEVfQ09WRVJBR0UpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmN1bGxGYWNlKGdsLkJBQ0spOyB9KTtcbiAgICByZXR1cm4gZ2w7XG59XG5leHBvcnRzLmNyZWF0ZVdlYkdMQ29udGV4dCA9IGNyZWF0ZVdlYkdMQ29udGV4dDtcbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleFNoYWRlcihnbCkge1xuICAgIHZhciB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBcIlxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIGF0dHJpYnV0ZSB2ZWMzIGNsaXBTcGFjZVBvcztcXG4gICAgYXR0cmlidXRlIHZlYzIgdXY7XFxuICAgIHZhcnlpbmcgdmVjMiByZXN1bHRVVjtcXG5cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2VQb3MsIDEpO1xcbiAgICAgIHJlc3VsdFVWID0gdXY7XFxuICAgIH1cIjtcbiAgICByZXR1cm4gd2ViZ2xfdXRpbC5jcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wsIHZlcnRleFNoYWRlclNvdXJjZSk7XG59XG5leHBvcnRzLmNyZWF0ZVZlcnRleFNoYWRlciA9IGNyZWF0ZVZlcnRleFNoYWRlcjtcbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleEJ1ZmZlcihnbCkge1xuICAgIHZhciB2ZXJ0ZXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAxLCAwLCAwLCAxLCAtMSwgLTEsIDAsIDAsIDAsIDEsIDEsIDAsIDEsIDEsIDEsIC0xLCAwLCAxLCAwXSk7XG4gICAgcmV0dXJuIHdlYmdsX3V0aWwuY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyKGdsLCB2ZXJ0ZXhBcnJheSk7XG59XG5leHBvcnRzLmNyZWF0ZVZlcnRleEJ1ZmZlciA9IGNyZWF0ZVZlcnRleEJ1ZmZlcjtcbmZ1bmN0aW9uIGNyZWF0ZUluZGV4QnVmZmVyKGdsKSB7XG4gICAgdmFyIHRyaWFuZ2xlVmVydGV4SW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShbMCwgMSwgMiwgMiwgMSwgM10pO1xuICAgIHJldHVybiB3ZWJnbF91dGlsLmNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyKGdsLCB0cmlhbmdsZVZlcnRleEluZGljZXMpO1xufVxuZXhwb3J0cy5jcmVhdGVJbmRleEJ1ZmZlciA9IGNyZWF0ZUluZGV4QnVmZmVyO1xuZnVuY3Rpb24gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0KGdsLCBudW1DaGFubmVscykge1xuICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSkge1xuICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICB9XG4gICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgIGlmIChudW1DaGFubmVscyA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsLlJHQkEzMkY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsLlIzMkY7XG4gICAgfVxuICAgIHJldHVybiBnbC5SR0JBO1xufVxuZnVuY3Rpb24gZ2V0VGV4dHVyZUZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgcmV0dXJuIGdsLlJHQkE7XG4gICAgfVxuICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMikge1xuICAgICAgICBpZiAobnVtQ2hhbm5lbHMgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBnbC5SR0JBO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbC5SRUQ7XG4gICAgfVxuICAgIHJldHVybiBnbC5SR0JBO1xufVxuZnVuY3Rpb24gZ2V0VGV4dHVyZVR5cGUoZ2wpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgcmV0dXJuIGdsLlVOU0lHTkVEX0JZVEU7XG4gICAgfVxuICAgIHJldHVybiBnbC5GTE9BVDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIG51bUNoYW5uZWxzKSB7XG4gICAgd2ViZ2xfdXRpbC52YWxpZGF0ZVRleHR1cmVTaXplKGdsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgdGV4dHVyZSA9IHdlYmdsX3V0aWwuY3JlYXRlVGV4dHVyZShnbCk7XG4gICAgdmFyIHRleDJkID0gZ2wuVEVYVFVSRV8yRDtcbiAgICB2YXIgaW50ZXJuYWxGb3JtYXQgPSBnZXRUZXh0dXJlSW50ZXJuYWxGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKTtcbiAgICB2YXIgZm9ybWF0ID0gZ2V0VGV4dHVyZUZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZSh0ZXgyZCwgdGV4dHVyZSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhQYXJhbWV0ZXJpKHRleDJkLCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhQYXJhbWV0ZXJpKHRleDJkLCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhQYXJhbWV0ZXJpKHRleDJkLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleEltYWdlMkQodGV4MmQsIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIGdldFRleHR1cmVUeXBlKGdsKSwgbnVsbCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTsgfSk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG59XG5mdW5jdGlvbiBjcmVhdGVNYXRyaXhUZXh0dXJlKGdsLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgdmFyIG51bUNoYW5uZWxzID0gMTtcbiAgICByZXR1cm4gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgbnVtQ2hhbm5lbHMpO1xufVxuZXhwb3J0cy5jcmVhdGVNYXRyaXhUZXh0dXJlID0gY3JlYXRlTWF0cml4VGV4dHVyZTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbG9yTWF0cml4VGV4dHVyZShnbCwgcm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldENvbG9yTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgIHZhciBudW1DaGFubmVscyA9IDQ7XG4gICAgcmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIG51bUNoYW5uZWxzKTtcbn1cbmV4cG9ydHMuY3JlYXRlQ29sb3JNYXRyaXhUZXh0dXJlID0gY3JlYXRlQ29sb3JNYXRyaXhUZXh0dXJlO1xuZnVuY3Rpb24gY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZShnbCwgcm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgICB2YXIgbnVtQ2hhbm5lbHMgPSA0O1xuICAgIHJldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUgPSBjcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlO1xuZnVuY3Rpb24gYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zKGdsLCBwcm9ncmFtLCB2ZXJ0ZXhCdWZmZXIsIGF0dHJpYkxvY2F0aW9ucykge1xuICAgIHZhciBwb3NPZmZzZXQgPSAwO1xuICAgIHZhciB1dk9mZnNldCA9IDMgKiA0O1xuICAgIHZhciBzdHJpZGUgPSAoMyAqIDQpICsgKDIgKiA0KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlcik7IH0pO1xuICAgIHdlYmdsX3V0aWwuYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgJ2NsaXBTcGFjZVBvcycsIHZlcnRleEJ1ZmZlciwgMywgc3RyaWRlLCBwb3NPZmZzZXQsIGF0dHJpYkxvY2F0aW9ucyk7XG4gICAgd2ViZ2xfdXRpbC5iaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlKGdsLCBwcm9ncmFtLCAndXYnLCB2ZXJ0ZXhCdWZmZXIsIDIsIHN0cmlkZSwgdXZPZmZzZXQsIGF0dHJpYkxvY2F0aW9ucyk7XG59XG5leHBvcnRzLmJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtcyA9IGJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtcztcbmZ1bmN0aW9uIHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZShnbCwgdGV4dHVyZSwgcGl4ZWxzKSB7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbHMpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xufVxuZXhwb3J0cy51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUgPSB1cGxvYWRQaXhlbERhdGFUb1RleHR1cmU7XG5mdW5jdGlvbiB1cGxvYWREYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCBkYXRhLCBudW1DaGFubmVscykge1xuICAgIHZhciB0ZXh0dXJlRm9ybWF0ID0gZ2V0VGV4dHVyZUZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpO1xuICAgIHdlYmdsX3V0aWwudmFsaWRhdGVUZXh0dXJlU2l6ZShnbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCB0ZXh0dXJlRm9ybWF0LCBnZXRUZXh0dXJlVHlwZShnbCksIGRhdGEpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xufVxuZnVuY3Rpb24gdXBsb2FkTWF0cml4VG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgsIG51bUNoYW5uZWxzKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdyA9IF9hWzBdLCBoID0gX2FbMV07XG4gICAgdmFyIHVucGFja2VkQXJyYXk7XG4gICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgdmFyIGNoYW5uZWxzUGVyVGV4dHVyZSA9IG51bUNoYW5uZWxzID09PSAxID8gd2ViZ2xfdXRpbC5nZXRDaGFubmVsc1BlclRleHR1cmUoKSA6IG51bUNoYW5uZWxzO1xuICAgICAgICBpZiAoY2hhbm5lbHNQZXJUZXh0dXJlID09PSAxKSB7XG4gICAgICAgICAgICB1bnBhY2tlZEFycmF5ID0gbWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5wYWNrZWRBcnJheSA9XG4gICAgICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKG1hdHJpeC5sZW5ndGgsIGNoYW5uZWxzUGVyVGV4dHVyZSkpO1xuICAgICAgICAgICAgdGV4X3V0aWwuZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5KG1hdHJpeCwgdW5wYWNrZWRBcnJheSwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdW5wYWNrZWRBcnJheSA9IHRleF91dGlsLmVuY29kZUZsb2F0QXJyYXkobWF0cml4KTtcbiAgICB9XG4gICAgdXBsb2FkRGF0YVRvVGV4dHVyZShnbCwgdGV4dHVyZSwgdywgaCwgdW5wYWNrZWRBcnJheSwgbnVtQ2hhbm5lbHMpO1xufVxuZXhwb3J0cy51cGxvYWRNYXRyaXhUb1RleHR1cmUgPSB1cGxvYWRNYXRyaXhUb1RleHR1cmU7XG5mdW5jdGlvbiB1cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUoZ2wsIHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCkge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICB2YXIgcGFja2VkUkdCQSA9IG5ldyBGbG9hdDMyQXJyYXkodGV4X3V0aWwuZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKSk7XG4gICAgdGV4X3V0aWwuZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBKG1hdHJpeCwgcm93cywgY29sdW1ucywgcGFja2VkUkdCQSk7XG4gICAgdmFyIG51bUNoYW5uZWxzID0gNDtcbiAgICB1cGxvYWREYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCB3LCBoLCBwYWNrZWRSR0JBLCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLnVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZSA9IHVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZTtcbmZ1bmN0aW9uIGdldERvd25sb2FkVGFyZ2V0QXJyYXlCdWZmZXIocm93cywgY29sdW1ucywgY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgdmFyIGlzRmxvYXRUZXh0dXJlID0gZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKTtcbiAgICB2YXIgZG93bmxvYWRUYXJnZXQ7XG4gICAgaWYgKGlzRmxvYXRUZXh0dXJlKSB7XG4gICAgICAgIGRvd25sb2FkVGFyZ2V0ID1cbiAgICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkodGV4X3V0aWwuZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShyb3dzICogY29sdW1ucywgY2hhbm5lbHNQZXJUZXh0dXJlKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkb3dubG9hZFRhcmdldCA9IG5ldyBVaW50OEFycmF5KHJvd3MgKiBjb2x1bW5zICogY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvd25sb2FkVGFyZ2V0O1xufVxuZnVuY3Rpb24gZGVjb2RlRG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihkb3dubG9hZFRhcmdldCwgcm93cywgY29sdW1ucywgY2hhbm5lbHNQZXJQaXhlbCkge1xuICAgIHZhciBpc0Zsb2F0VGV4dHVyZSA9IGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJyk7XG4gICAgaWYgKGlzRmxvYXRUZXh0dXJlKSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHJvd3MgKiBjb2x1bW5zKTtcbiAgICAgICAgdGV4X3V0aWwuZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXkoZG93bmxvYWRUYXJnZXQsIG1hdHJpeCwgY2hhbm5lbHNQZXJQaXhlbCk7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGV4X3V0aWwuZGVjb2RlVG9GbG9hdEFycmF5KGRvd25sb2FkVGFyZ2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBkb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlQXN5bmMoZ2wsIGdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbiwgcm93cywgY29sdW1ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdsMiwgY2hhbm5lbHNQZXJQaXhlbCwgZG93bmxvYWRUYXJnZXQsIGJ1ZmZlclNpemVCeXRlcywgYnVmZmVyO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBnbDIgPSBnbDtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHNQZXJQaXhlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGRvd25sb2FkVGFyZ2V0ID0gZ2V0RG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihyb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclBpeGVsKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyU2l6ZUJ5dGVzID0gZG93bmxvYWRUYXJnZXQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRUYXJnZXQubGVuZ3RoICogNCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZFRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsMi5QSVhFTF9QQUNLX0JVRkZFUiwgYnVmZmVyKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5idWZmZXJEYXRhKGdsMi5QSVhFTF9QQUNLX0JVRkZFUiwgYnVmZmVyU2l6ZUJ5dGVzLCBnbC5TVEFUSUNfRFJBVyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdsMi5yZWFkUGl4ZWxzKDAsIDAsIGNvbHVtbnMsIHJvd3MsIGdsLlJHQkEsIGdldFRleHR1cmVUeXBlKGdsKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbi5nZXRCdWZmZXJTdWJEYXRhQXN5bmMoZ2wyLlBJWEVMX1BBQ0tfQlVGRkVSLCAwLCBkb3dubG9hZFRhcmdldCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGRlY29kZURvd25sb2FkVGFyZ2V0QXJyYXlCdWZmZXIoZG93bmxvYWRUYXJnZXQsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzUGVyUGl4ZWwpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmVBc3luYyA9IGRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmVBc3luYztcbmZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICB2YXIgY2hhbm5lbHNQZXJQaXhlbCA9IDQ7XG4gICAgdmFyIGRvd25sb2FkVGFyZ2V0ID0gZ2V0RG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihyb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclBpeGVsKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wucmVhZFBpeGVscygwLCAwLCB3LCBoLCBnbC5SR0JBLCBnZXRUZXh0dXJlVHlwZShnbCksIGRvd25sb2FkVGFyZ2V0KTsgfSk7XG4gICAgcmV0dXJuIGRlY29kZURvd25sb2FkVGFyZ2V0QXJyYXlCdWZmZXIoZG93bmxvYWRUYXJnZXQsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzUGVyUGl4ZWwpO1xufVxuZXhwb3J0cy5kb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlID0gZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZTtcbmZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbVJHQkFDb2xvclRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzKSB7XG4gICAgdmFyIHNpemUgPSByb3dzICogY29sdW1ucyAqIDQ7XG4gICAgdmFyIGRvd25sb2FkVGFyZ2V0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnJlYWRQaXhlbHMoMCwgMCwgY29sdW1ucywgcm93cywgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZG93bmxvYWRUYXJnZXQpOyB9KTtcbiAgICB2YXIgcGFja2VkUkdCQSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb3dubG9hZFRhcmdldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYWNrZWRSR0JBW2ldID0gZG93bmxvYWRUYXJnZXRbaV07XG4gICAgfVxuICAgIHZhciBtYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHJvd3MgKiBjb2x1bW5zICogY2hhbm5lbHMpO1xuICAgIHRleF91dGlsLmRlY29kZU1hdHJpeEZyb21VbnBhY2tlZENvbG9yUkdCQUFycmF5KHBhY2tlZFJHQkEsIG1hdHJpeCwgY2hhbm5lbHMpO1xuICAgIHJldHVybiBtYXRyaXg7XG59XG5leHBvcnRzLmRvd25sb2FkTWF0cml4RnJvbVJHQkFDb2xvclRleHR1cmUgPSBkb3dubG9hZE1hdHJpeEZyb21SR0JBQ29sb3JUZXh0dXJlO1xuZnVuY3Rpb24gZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZShnbCwgcm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICB2YXIgcGFja2VkUkdCQSA9IG5ldyBGbG9hdDMyQXJyYXkodGV4X3V0aWwuZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnJlYWRQaXhlbHMoMCwgMCwgdywgaCwgZ2wuUkdCQSwgZ2V0VGV4dHVyZVR5cGUoZ2wpLCBwYWNrZWRSR0JBKTsgfSk7XG4gICAgdmFyIG1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkocm93cyAqIGNvbHVtbnMpO1xuICAgIHJldHVybiB0ZXhfdXRpbC5kZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQShwYWNrZWRSR0JBLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpO1xufVxuZXhwb3J0cy5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlID0gZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdwZ3B1X3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXhQb29sMkRCYWNrcHJvcFByb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydkeScsICdtYXhQb3MnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmluU2hhcGU7XG4gICAgICAgIHZhciBkeVJvd3MgPSBjb252SW5mby5vdXRTaGFwZVswXTtcbiAgICAgICAgdmFyIGR5Q29scyA9IGNvbnZJbmZvLm91dFNoYXBlWzFdO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgbGFzdEluZGV4ID0gZmlsdGVySGVpZ2h0ICogZmlsdGVyV2lkdGggLSAxO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHMuejtcXG5cXG4gICAgICAgIGl2ZWMyIGR5UkNDb3JuZXIgPSBjb29yZHMueHkgLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5UkNDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeVJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkKSB3aXRoIHBvcyBtYXNrKDosIDosIGQpIHRvIGdldCBkeCh4UiwgeEMsIGQpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIgKyBzdHJpZGVIZWlnaHQgKyBcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIiArIGR5Um93cyArIFwiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIiArIHN0cmlkZVdpZHRoICsgXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIiArIGR5Q29scyArIFwiLjAgfHwgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGlkeVIsIGlkeUMsIGQpO1xcbiAgICAgICAgICAgIGludCBtYXhQb3NWYWx1ZSA9IFwiICsgbGFzdEluZGV4ICsgXCIgLSBpbnQoZ2V0TWF4UG9zKGlkeVIsIGlkeUMsIGQpKTtcXG5cXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUsIGNoZWNrIGl0IGFnYWluc3QgdGhlIHZhbHVlIGZyb20gdGhlXFxuICAgICAgICAgICAgLy8gcG9zaXRpb24gbWF0cml4LlxcbiAgICAgICAgICAgIGludCBjdXJQb3NWYWx1ZSA9IHdSICogXCIgKyBmaWx0ZXJXaWR0aCArIFwiICsgd0M7XFxuICAgICAgICAgICAgZmxvYXQgbWFzayA9IGZsb2F0KG1heFBvc1ZhbHVlID09IGN1clBvc1ZhbHVlID8gMS4wIDogMC4wKTtcXG5cXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBtYXNrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIE1heFBvb2wyREJhY2twcm9wUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLk1heFBvb2wyREJhY2twcm9wUHJvZ3JhbSA9IE1heFBvb2wyREJhY2twcm9wUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heF9wb29sX2JhY2twcm9wX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtYXRoXzEgPSByZXF1aXJlKFwiLi4vbWF0aFwiKTtcbnZhciBNYXRNdWxQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRNdWxQcm9ncmFtKGFTaGFwZSwgYlNoYXBlLCBhT3JpZW50LCBiT3JpZW50KSB7XG4gICAgICAgIGlmIChhT3JpZW50ID09PSB2b2lkIDApIHsgYU9yaWVudCA9IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSOyB9XG4gICAgICAgIGlmIChiT3JpZW50ID09PSB2b2lkIDApIHsgYk9yaWVudCA9IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSOyB9XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnbWF0cml4QScsICdtYXRyaXhCJ107XG4gICAgICAgIHZhciBvdXRlclNoYXBlQSA9IChhT3JpZW50ID09PSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBhU2hhcGVbMF0gOiBhU2hhcGVbMV07XG4gICAgICAgIHZhciBvdXRlclNoYXBlQiA9IChiT3JpZW50ID09PSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBiU2hhcGVbMV0gOiBiU2hhcGVbMF07XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbb3V0ZXJTaGFwZUEsIG91dGVyU2hhcGVCXTtcbiAgICAgICAgdmFyIHNoYXJlZERpbSA9IChhT3JpZW50ID09PSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUiA/IGFTaGFwZVsxXSA6IGFTaGFwZVswXSk7XG4gICAgICAgIHZhciBhU25pcHBldEZyb21PZmZzZXQgPSBmdW5jdGlvbiAodmVjNE9mZnNldCwgaW5kZXhWYXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoYU9yaWVudCA9PT0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID9cbiAgICAgICAgICAgICAgICBcImFSb3csIFwiICsgaW5kZXhWYXIgKyBcIiArIFwiICsgdmVjNE9mZnNldCA6XG4gICAgICAgICAgICAgICAgaW5kZXhWYXIgKyBcIiArIFwiICsgdmVjNE9mZnNldCArIFwiLCBhUm93XCI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBiU25pcHBldEZyb21PZmZzZXQgPSBmdW5jdGlvbiAodmVjNE9mZnNldCwgaW5kZXhWYXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoYk9yaWVudCA9PT0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID9cbiAgICAgICAgICAgICAgICBpbmRleFZhciArIFwiICsgXCIgKyB2ZWM0T2Zmc2V0ICsgXCIsIGJDb2xcIiA6XG4gICAgICAgICAgICAgICAgXCJiQ29sLCBcIiArIGluZGV4VmFyICsgXCIgKyBcIiArIHZlYzRPZmZzZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzaGFyZWREaW1OZWFyZXN0VmVjNCA9IE1hdGguZmxvb3Ioc2hhcmVkRGltIC8gNCkgKiA0O1xuICAgICAgICB2YXIgc2hhcmVkRGltVmVjNFJlbWFpbmRlciA9IHNoYXJlZERpbSAlIDQ7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIiBmbG9hdCBkb3RBUm93QkNvbChpbnQgYVJvdywgaW50IGJDb2wpIHtcXG4gICAgICBmbG9hdCByZXN1bHQgPSAwLjA7XFxuICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIHNoYXJlZERpbU5lYXJlc3RWZWM0ICsgXCI7IGkgKz0gNCkge1xcbiAgICAgICAgdmVjNCBhID0gdmVjNChcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgwLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDEsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMiwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgzLCAnaScpICsgXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgdmVjNCBiID0gdmVjNChcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgwLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDEsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMiwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgzLCAnaScpICsgXCIpXFxuICAgICAgICApO1xcblxcbiAgICAgICAgcmVzdWx0ICs9IGRvdChhLCBiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKFwiICsgKHNoYXJlZERpbVZlYzRSZW1haW5kZXIgPT09IDEpICsgXCIpIHtcXG4gICAgICAgIHJlc3VsdCArPSBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSAqXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpO1xcbiAgICAgIH0gZWxzZSBpZiAoXCIgKyAoc2hhcmVkRGltVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgdmVjMiBhID0gdmVjMihcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMSwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgdmVjMiBiID0gdmVjMihcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMSwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgcmVzdWx0ICs9IGRvdChhLCBiKTtcXG4gICAgICB9IGVsc2UgaWYgKFwiICsgKHNoYXJlZERpbVZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgIHZlYzMgYSA9IHZlYzMoXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDEsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgyLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICB2ZWMzIGIgPSB2ZWMzKFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgxLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMiwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpXFxuICAgICAgICApO1xcbiAgICAgICAgcmVzdWx0ICs9IGRvdChhLCBiKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgaXZlYzIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBzZXRPdXRwdXQoZG90QVJvd0JDb2wocmVzUkMueCwgcmVzUkMueSkpO1xcbiAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gTWF0TXVsUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLk1hdE11bFByb2dyYW0gPSBNYXRNdWxQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsbWF0X2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNdWx0aW5vbWlhbFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE11bHRpbm9taWFsUHJvZ3JhbShiYXRjaFNpemUsIG51bU91dGNvbWVzLCBudW1TYW1wbGVzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsncHJvYnMnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIG51bVNhbXBsZXNdO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IHNlZWQ7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuXFxuICAgICAgICBmbG9hdCByID0gcmFuZG9tKHNlZWQpO1xcbiAgICAgICAgZmxvYXQgY2RmID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIChudW1PdXRjb21lcyAtIDEpICsgXCI7IGkrKykge1xcbiAgICAgICAgICBjZGYgKz0gZ2V0UHJvYnMoYmF0Y2gsIGkpO1xcblxcbiAgICAgICAgICBpZiAociA8IGNkZikge1xcbiAgICAgICAgICAgIHNldE91dHB1dChmbG9hdChpKSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBJZiBubyBvdGhlciBldmVudCBoYXBwZW5lZCwgbGFzdCBldmVudCBoYXBwZW5lZC5cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChcIiArIChudW1PdXRjb21lcyAtIDEpICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBNdWx0aW5vbWlhbFByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ3BncHUsIHdlYkdMUHJvZ3JhbSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnNlZWRMb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlZWRMb2MgPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCAnc2VlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFmKF90aGlzLnNlZWRMb2MsIHNlZWQpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpbm9taWFsUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLk11bHRpbm9taWFsUHJvZ3JhbSA9IE11bHRpbm9taWFsUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpbm9taWFsX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBPbmVIb3RQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPbmVIb3RQcm9ncmFtKG51bUluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2luZGljZXMnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtudW1JbmRpY2VzLCBkZXB0aF07XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZ2V0SW5kaWNlcyhjb29yZHMueCkpO1xcbiAgICAgICAgc2V0T3V0cHV0KG1peChmbG9hdChcIiArIG9mZlZhbHVlICsgXCIpLCBmbG9hdChcIiArIG9uVmFsdWUgKyBcIiksXFxuICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGluZGV4ID09IGNvb3Jkcy55KSkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIE9uZUhvdFByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ3BncHUsIHdlYkdMUHJvZ3JhbSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnNlZWRMb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlZWRMb2MgPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCAnc2VlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFmKF90aGlzLnNlZWRMb2MsIHNlZWQpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIE9uZUhvdFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5PbmVIb3RQcm9ncmFtID0gT25lSG90UHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uZWhvdF9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUG9vbDJEUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9vbDJEUHJvZ3JhbShjb252SW5mbywgcG9vbFR5cGUsIGNvbXB1dGVQb3NpdGlvbnMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIGlmIChwb29sVHlwZSA9PT0gJ2F2ZycgJiYgY29tcHV0ZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcHV0ZSBwb3NpdGlvbnMgZm9yIGF2ZXJhZ2UgcG9vbC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciB4TnVtUm93cyA9IGNvbnZJbmZvLmluU2hhcGVbMF07XG4gICAgICAgIHZhciB4TnVtQ29scyA9IGNvbnZJbmZvLmluU2hhcGVbMV07XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgdmFyIGlzQXZnUG9vbCA9IHBvb2xUeXBlID09PSAnYXZnJztcbiAgICAgICAgdmFyIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnMC4wJztcbiAgICAgICAgaWYgKCFpc0F2Z1Bvb2wpIHtcbiAgICAgICAgICAgIGlmIChwb29sVHlwZSA9PT0gJ21pbicpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJzEuMCAvIDAuMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJy0xLjAgLyAwLjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wdXRlUG9zaXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFyZU9wXzEgPSBwb29sVHlwZSA9PT0gJ21pbicgPyAnPD0nIDogJz49JztcbiAgICAgICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGQgPSBjb29yZHMuejtcXG5cXG4gICAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnh5ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZUZvdW5kID0gMC4wO1xcbiAgICAgICAgICBpbnQgbWluTWF4UG9zaXRpb24gPSAwO1xcbiAgICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyB4TnVtUm93cyArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRYKHhSLCB4QywgZCk7XFxuXFxuICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XFxuICAgICAgICAgICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIC8vIElmIGEgbWluIC8gbWF4IHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZm91bmQsIHVzZSBpdC4gSWYgbm90LFxcbiAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxcbiAgICAgICAgICAgICAgZmxvYXQgY3Vyck1pbk1heFZhbHVlID0gbWl4KFxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLCBtaW5NYXhWYWx1ZSwgbWluTWF4VmFsdWVGb3VuZCk7XFxuICAgICAgICAgICAgICBpZiAodmFsdWUgXCIgKyBjb21wYXJlT3BfMSArIFwiIGN1cnJNaW5NYXhWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IHZhbHVlO1xcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZUZvdW5kID0gMS4wO1xcbiAgICAgICAgICAgICAgICBtaW5NYXhQb3NpdGlvbiA9IHdSICogXCIgKyBmaWx0ZXJXaWR0aCArIFwiICsgd0M7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChtaW5NYXhQb3NpdGlvbikpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wYXJlT3AgPSBwb29sVHlwZSA9PT0gJ21pbicgPyAnbWluJyA6ICdtYXgnO1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBwb29sVHlwZSArIFwiKFwiICsgcG9vbFR5cGUgKyBcIihcIiArIHBvb2xUeXBlICsgXCIoXCIgK1xuICAgICAgICAgICAgJ21pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pJztcbiAgICAgICAgaWYgKHBvb2xUeXBlID09PSAnYXZnJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBcImF2Z1ZhbHVlIC8gXCIgKyBmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCArIFwiLjBcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsdGVyV2lkdGhOZWFyZXN0VmVjNCA9IE1hdGguZmxvb3IoZmlsdGVyV2lkdGggLyA0KSAqIDQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPSBmaWx0ZXJXaWR0aCAlIDQ7XG4gICAgICAgIHZhciB1cGRhdGVTbmlwcGV0ID0gXCJcXG4gICAgICBpZiAoaGFzTmFOKHZhbHVlcykpIHtcXG4gICAgICAgIHNldE91dHB1dChnZXROYU4odmFsdWVzKSk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIGlmIChcIiArIGlzQXZnUG9vbCArIFwiKSB7XFxuICAgICAgICBhdmdWYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWluTWF4VmFsdWUgPSBcIiArIGNvbXBhcmVPcCArIFwiKHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIiArIHN0cmlkZUhlaWdodCArIFwiLCBcIiArIHN0cmlkZVdpZHRoICsgXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiICsgaW5pdGlhbGl6YXRpb25WYWx1ZSArIFwiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgeFIsIGludCB4QywgaW50IGQpIHtcXG4gICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGdldFgoeFIsIHhDLCBkKTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkcy56O1xcblxcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnh5ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIgKyBpbml0aWFsaXphdGlvblZhbHVlICsgXCIpO1xcbiAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgeE51bVJvd3MgKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoTmVhcmVzdFZlYzQgKyBcIjsgd0MgKz0gNCkge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XFxuXFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKHhSLCB4QyArIDEsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDICsgMiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZSh4UiwgeEMgKyAzLCBkKVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIFwiICsgZmlsdGVyV2lkdGhOZWFyZXN0VmVjNCArIFwiO1xcbiAgICAgICAgICBpZiAoXCIgKyAoZmlsdGVyV2lkdGhWZWM0UmVtYWluZGVyID09PSAxKSArIFwiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgICAgfSBlbHNlIGlmIChcIiArIChmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZSh4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDICsgMSwgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgICAgfSBlbHNlIGlmIChcIiArIChmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZSh4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDICsgMSwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZSh4UiwgeEMgKyAyLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChcIiArIHJldHVyblZhbHVlICsgXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBQb29sMkRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuUG9vbDJEUHJvZ3JhbSA9IFBvb2wyRFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb29sX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZWR1Y2VQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWR1Y2VQcm9ncmFtKHJlZHVjZUluZm8sIHJlZHVjZVR5cGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIHZhciB3aW5kb3dTaXplID0gcmVkdWNlSW5mby53aW5kb3dTaXplO1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gcmVkdWNlSW5mby5iYXRjaFNpemU7XG4gICAgICAgIHZhciBpblNpemUgPSByZWR1Y2VJbmZvLmluU2l6ZTtcbiAgICAgICAgdmFyIG91dFNpemUgPSBNYXRoLmNlaWwoaW5TaXplIC8gd2luZG93U2l6ZSk7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBvdXRTaXplXTtcbiAgICAgICAgdmFyIGlzUmVkdWNlU3VtID0gcmVkdWNlVHlwZSA9PT0gJ3N1bSc7XG4gICAgICAgIHZhciBpbml0aWFsaXphdGlvblZhbHVlID0gJzAuMCc7XG4gICAgICAgIGlmICghaXNSZWR1Y2VTdW0pIHtcbiAgICAgICAgICAgIGlmIChyZWR1Y2VUeXBlID09PSAnbWluJykge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnMS4wIC8gMC4wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnLTEuMCAvIDAuMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBhcmVPcCA9IHJlZHVjZVR5cGUgPT09ICdtaW4nID8gJ21pbicgOiAnbWF4JztcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gcmVkdWNlVHlwZSArIFwiKFwiICsgcmVkdWNlVHlwZSArIFwiKFwiICsgcmVkdWNlVHlwZSArIFwiKFwiICtcbiAgICAgICAgICAgICdtaW5NYXhWYWx1ZVswXSwgbWluTWF4VmFsdWVbMV0pLCBtaW5NYXhWYWx1ZVsyXSksIG1pbk1heFZhbHVlWzNdKSc7XG4gICAgICAgIGlmIChyZWR1Y2VUeXBlID09PSAnc3VtJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBcInN1bVZhbHVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpbmRvd1NpemVOZWFyZXN0VmVjNCA9IE1hdGguZmxvb3Iod2luZG93U2l6ZSAvIDQpICogNDtcbiAgICAgICAgdmFyIHdpbmRvd1NpemVWZWM0UmVtYWluZGVyID0gd2luZG93U2l6ZSAlIDQ7XG4gICAgICAgIHZhciB1cGRhdGVTbmlwcGV0ID0gXCJcXG4gICAgICBpZiAoXCIgKyBpc1JlZHVjZVN1bSArIFwiKSB7XFxuICAgICAgICBzdW1WYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGhhc05hTih2YWx1ZXMpKSB7XFxuICAgICAgICAgIHNldE91dHB1dChnZXROYU4odmFsdWVzKSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIG1pbk1heFZhbHVlID0gXCIgKyBjb21wYXJlT3AgKyBcIih2YWx1ZXMsIG1pbk1heFZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgICAgICB2YXIgY2hlY2tPdXRPZkJvdW5kcyA9ICcnO1xuICAgICAgICBpZiAoaW5TaXplICUgd2luZG93U2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNoZWNrT3V0T2ZCb3VuZHMgPSBcIlxcbiAgICAgICAgaWYgKGluSWR4IDwgMCB8fCBpbklkeCA+PSBcIiArIGluU2l6ZSArIFwiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSBcIiArIGluaXRpYWxpemF0aW9uVmFsdWUgKyBcIjtcXG4gICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCk7XFxuXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgaW5JZHgpIHtcXG4gICAgICAgIFwiICsgY2hlY2tPdXRPZkJvdW5kcyArIFwiXFxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgaW5JZHgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgaW5PZmZzZXQgPSBvdXRJZHggKiBcIiArIHdpbmRvd1NpemUgKyBcIjtcXG5cXG4gICAgICAgIHZlYzQgbWluTWF4VmFsdWUgPSB2ZWM0KFwiICsgaW5pdGlhbGl6YXRpb25WYWx1ZSArIFwiKTtcXG4gICAgICAgIGZsb2F0IHN1bVZhbHVlID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIHdpbmRvd1NpemVOZWFyZXN0VmVjNCArIFwiOyBpICs9IDQpIHtcXG4gICAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBpO1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAzKVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBcIiArIHdpbmRvd1NpemVOZWFyZXN0VmVjNCArIFwiO1xcbiAgICAgICAgaWYgKFwiICsgKHdpbmRvd1NpemVWZWM0UmVtYWluZGVyID09PSAxKSArIFwiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICB9IGVsc2UgaWYgKFwiICsgKHdpbmRvd1NpemVWZWM0UmVtYWluZGVyID09PSAyKSArIFwiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcbiAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIiArICh3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoXCIgKyByZXR1cm5WYWx1ZSArIFwiKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUmVkdWNlUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlJlZHVjZVByb2dyYW0gPSBSZWR1Y2VQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdWNlX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2xfdXRpbFwiKTtcbmZ1bmN0aW9uIGdldFJlbmRlclJHQlNoYWRlcihncGdwdSwgZGVzdGluYXRpb25XaWR0aCkge1xuICAgIHZhciBmcmFnbWVudFNoYWRlclNvdXJjZSA9IFwiXFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgc291cmNlO1xcbiAgICB2YXJ5aW5nIHZlYzIgcmVzdWx0VVY7XFxuXFxuICAgIGNvbnN0IGZsb2F0IGRlc3RpbmF0aW9uV2lkdGggPSBcIiArIGRlc3RpbmF0aW9uV2lkdGggKyBcIi4wO1xcbiAgICBjb25zdCBmbG9hdCBhID0gMS4wO1xcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZmxvYXQgeHIgPSBmbG9vcihyZXN1bHRVVi5zICogZGVzdGluYXRpb25XaWR0aCkgKiAzLjA7XFxuICAgICAgdmVjMyB4ID0geHIgKyB2ZWMzKDAsIDEsIDIpO1xcblxcbiAgICAgIGZsb2F0IHNvdXJjZVdpZHRoID0gZGVzdGluYXRpb25XaWR0aCAqIDMuMDtcXG4gICAgICB2ZWMzIHUgPSAoeCArIDAuNSkgLyBzb3VyY2VXaWR0aDtcXG4gICAgICBmbG9hdCB2ID0gMS4wIC0gcmVzdWx0VVYudDtcXG5cXG4gICAgICBmbG9hdCByID0gdGV4dHVyZTJEKHNvdXJjZSwgdmVjMih1WzBdLCB2KSkucjtcXG4gICAgICBmbG9hdCBnID0gdGV4dHVyZTJEKHNvdXJjZSwgdmVjMih1WzFdLCB2KSkucjtcXG4gICAgICBmbG9hdCBiID0gdGV4dHVyZTJEKHNvdXJjZSwgdmVjMih1WzJdLCB2KSkucjtcXG5cXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHIsIGcsIGIsIGEpO1xcbiAgICB9XCI7XG4gICAgcmV0dXJuIGdwZ3B1LmNyZWF0ZVByb2dyYW0oZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xufVxuZXhwb3J0cy5nZXRSZW5kZXJSR0JTaGFkZXIgPSBnZXRSZW5kZXJSR0JTaGFkZXI7XG5mdW5jdGlvbiByZW5kZXJUb0NhbnZhcyhncGdwdSwgcmVuZGVyU2hhZGVyLCBzb3VyY2VUZXgpIHtcbiAgICB3ZWJnbF91dGlsLmJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyKGdwZ3B1LmdsKTtcbiAgICByZW5kZXJUb0ZyYW1lYnVmZmVyKGdwZ3B1LCByZW5kZXJTaGFkZXIsIHNvdXJjZVRleCk7XG59XG5leHBvcnRzLnJlbmRlclRvQ2FudmFzID0gcmVuZGVyVG9DYW52YXM7XG5mdW5jdGlvbiByZW5kZXJUb0ZyYW1lYnVmZmVyKGdwZ3B1LCByZW5kZXJTaGFkZXIsIHNvdXJjZVRleCkge1xuICAgIGdwZ3B1LnNldFByb2dyYW0ocmVuZGVyU2hhZGVyKTtcbiAgICB2YXIgc291cmNlU2FtcGxlckxvY2F0aW9uID0gd2ViZ2xfdXRpbC5nZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdyhncGdwdS5nbCwgcmVuZGVyU2hhZGVyLCAnc291cmNlJyk7XG4gICAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHNvdXJjZVRleCwgc291cmNlU2FtcGxlckxvY2F0aW9uLCAwKTtcbiAgICBncGdwdS5leGVjdXRlUHJvZ3JhbSgpO1xufVxuZXhwb3J0cy5yZW5kZXJUb0ZyYW1lYnVmZmVyID0gcmVuZGVyVG9GcmFtZWJ1ZmZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlcl9uZGFycmF5X2dwdV91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlc2l6ZUJpbGluZWFyM0RQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNpemVCaWxpbmVhcjNEUHJvZ3JhbShpbnB1dFNoYXBlLCBvdXRwdXREaW1lbnNpb25zUm93Q29sLCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdmFyIGRlcHRoID0gaW5wdXRTaGFwZVsyXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9XG4gICAgICAgICAgICBbb3V0cHV0RGltZW5zaW9uc1Jvd0NvbFswXSwgb3V0cHV0RGltZW5zaW9uc1Jvd0NvbFsxXSwgZGVwdGhdO1xuICAgICAgICB2YXIgZWZmZWN0aXZlSW5wdXRTaGFwZSA9IGFsaWduQ29ybmVycyA/XG4gICAgICAgICAgICBbaW5wdXRTaGFwZVswXSAtIDEsIGlucHV0U2hhcGVbMV0gLSAxLCBkZXB0aF0gOlxuICAgICAgICAgICAgaW5wdXRTaGFwZTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZU91dHB1dFNoYXBlID0gYWxpZ25Db3JuZXJzID9cbiAgICAgICAgICAgIFt0aGlzLm91dHB1dFNoYXBlWzBdIC0gMSwgdGhpcy5vdXRwdXRTaGFwZVsxXSAtIDEsIGRlcHRoXSA6XG4gICAgICAgICAgICB0aGlzLm91dHB1dFNoYXBlO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCB2ZWMyIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMyKFxcbiAgICAgICAgICBcIiArIGVmZmVjdGl2ZUlucHV0U2hhcGVbMF0gLyBlZmZlY3RpdmVPdXRwdXRTaGFwZVswXSArIFwiLFxcbiAgICAgICAgICBcIiArIGVmZmVjdGl2ZUlucHV0U2hhcGVbMV0gLyBlZmZlY3RpdmVPdXRwdXRTaGFwZVsxXSArIFwiKTtcXG4gICAgICBjb25zdCB2ZWMyIGlucHV0U2hhcGVSQyA9IHZlYzIoXCIgKyBpbnB1dFNoYXBlWzBdICsgXCIuMCwgXCIgKyBpbnB1dFNoYXBlWzFdICsgXCIuMCk7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpdmVjMiB5UkMgPSBjb29yZHMueHk7XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkcy56O1xcblxcbiAgICAgICAgLy8gRnJhY3Rpb25hbCBzb3VyY2UgaW5kZXguXFxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleFJDID0gdmVjMih5UkMpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQztcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGZvdXIgaW50ZWdlciBpbmRpY2VzLlxcbiAgICAgICAgaXZlYzIgc291cmNlRmxvb3JSQyA9IGl2ZWMyKHNvdXJjZUZyYWNJbmRleFJDKTtcXG4gICAgICAgIGl2ZWMyIHNvdXJjZUNlaWxSQyA9IGl2ZWMyKFxcbiAgICAgICAgICBtaW4oaW5wdXRTaGFwZVJDIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWNJbmRleFJDKSkpO1xcblxcbiAgICAgICAgZmxvYXQgdG9wTGVmdCA9IGdldEEoc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgYm90dG9tTGVmdCA9IGdldEEoc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueSwgZCk7XFxuICAgICAgICBmbG9hdCB0b3BSaWdodCA9IGdldEEoc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XFxuICAgICAgICBmbG9hdCBib3R0b21SaWdodCA9IGdldEEoc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy55LCBkKTtcXG5cXG4gICAgICAgIHZlYzIgZnJhY1JDID0gc291cmNlRnJhY0luZGV4UkMgLSB2ZWMyKHNvdXJjZUZsb29yUkMpO1xcblxcbiAgICAgICAgZmxvYXQgdG9wID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogZnJhY1JDLnk7XFxuICAgICAgICBmbG9hdCBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBmcmFjUkMueTtcXG4gICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gdG9wICsgKGJvdHRvbSAtIHRvcCkgKiBmcmFjUkMueDtcXG5cXG4gICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFJlc2l6ZUJpbGluZWFyM0RQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuUmVzaXplQmlsaW5lYXIzRFByb2dyYW0gPSBSZXNpemVCaWxpbmVhcjNEUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc2l6ZV9iaWxpbmVhcl9ncHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi4vYnJvYWRjYXN0X3V0aWxcIik7XG52YXIgdGV4X3V0aWwgPSByZXF1aXJlKFwiLi90ZXhfdXRpbFwiKTtcbnZhciB0ZXhfdXRpbF8xID0gcmVxdWlyZShcIi4vdGV4X3V0aWxcIik7XG5mdW5jdGlvbiBtYWtlU2hhZGVyKGlucHV0c0luZm8sIG91dHB1dFNoYXBlLCB1c2VyQ29kZSwgYnJvYWRjYXN0KSB7XG4gICAgdmFyIHNhbXBsZVNuaXBwZXQgPSBnZXRTYW1wbGVTbmlwcGV0KCk7XG4gICAgdmFyIHNldE91dHB1dFNuaXBwZXQgPSBnZXRTZXRPdXRwdXRTbmlwcGV0KCk7XG4gICAgdmFyIGlucHV0UHJlZml4U25pcHBldCA9IGlucHV0c0luZm8ubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBcInVuaWZvcm0gc2FtcGxlcjJEIFwiICsgeC5uYW1lICsgXCI7XCI7IH0pLmpvaW4oJ1xcbicpO1xuICAgIHZhciBpbnB1dFNhbXBsaW5nU25pcHBldCA9IGlucHV0c0luZm8ubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBnZXRJbnB1dFNhbXBsaW5nU25pcHBldCh4LCBvdXRwdXRTaGFwZSwgYnJvYWRjYXN0KTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIHZhciBvdXRUZXhTaGFwZSA9IG91dHB1dFNoYXBlLnRleFNoYXBlO1xuICAgIHZhciBvdXRwdXRTYW1wbGluZ1NuaXBwZXQgPSBnZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQob3V0cHV0U2hhcGUubG9naWNhbFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgdmFyIHNvdXJjZSA9IFtcbiAgICAgICAgU0hBREVSX1BSRUZJWCwgc2FtcGxlU25pcHBldCwgc2V0T3V0cHV0U25pcHBldCwgaW5wdXRQcmVmaXhTbmlwcGV0LFxuICAgICAgICBvdXRwdXRTYW1wbGluZ1NuaXBwZXQsIGlucHV0U2FtcGxpbmdTbmlwcGV0LCB1c2VyQ29kZVxuICAgIF0uam9pbignXFxuJyk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbn1cbmV4cG9ydHMubWFrZVNoYWRlciA9IG1ha2VTaGFkZXI7XG5mdW5jdGlvbiBnZXRTYW1wbGVTbmlwcGV0KCkge1xuICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpID9cbiAgICAgICAgRkxPQVRfVEVYVFVSRV9TQU1QTEVfU05JUFBFVCA6XG4gICAgICAgIFVOU0lHTkVEX0JZVEVfVEVYVFVSRV9TQU1QTEVfU05JUFBFVDtcbn1cbmZ1bmN0aW9uIGdldFNldE91dHB1dFNuaXBwZXQoKSB7XG4gICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykgP1xuICAgICAgICBGTE9BVF9URVhUVVJFX1NFVE9VVFBVVF9TTklQUEVUIDpcbiAgICAgICAgVU5TSUdORURfQllURV9URVhUVVJFX1NFVE9VVFBVVF9TTklQUEVUO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlckZyb21JbkluZm8oaW5JbmZvKSB7XG4gICAgdmFyIHNoYXBlID0gaW5JbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgc3dpdGNoIChzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXJTY2FsYXIoaW5JbmZvKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXIxRChpbkluZm8pO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlcjJEKGluSW5mbyk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBnZXRTYW1wbGVyM0QoaW5JbmZvKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXI0RChpbkluZm8pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNoYXBlLmxlbmd0aCArIFwiLUQgaW5wdXQgc2FtcGxpbmdcIiArXG4gICAgICAgICAgICAgICAgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SW5wdXRTYW1wbGluZ1NuaXBwZXQoaW5JbmZvLCBvdXRTaGFwZUluZm8sIGJyb2FkY2FzdCkge1xuICAgIHZhciByZXMgPSBnZXRTYW1wbGVyRmxhdChpbkluZm8pO1xuICAgIHJlcyArPSBnZXRTYW1wbGVyRnJvbUluSW5mbyhpbkluZm8pO1xuICAgIGlmIChicm9hZGNhc3QgfHxcbiAgICAgICAgdXRpbC5hcnJheXNFcXVhbChpbkluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSwgb3V0U2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSkpIHtcbiAgICAgICAgcmVzICs9IGdldFNhbXBsZXJBdE91dHB1dENvb3JkcyhpbkluZm8sIG91dFNoYXBlSW5mbywgYnJvYWRjYXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRTaGFwZSwgb3V0VGV4U2hhcGUpIHtcbiAgICBzd2l0Y2ggKG91dFNoYXBlLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0U2NhbGFyQ29vcmRzKCk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXQxRENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0MkRDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDNEQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXQ0RENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG91dFNoYXBlLmxlbmd0aCArIFwiLUQgb3V0cHV0IHNhbXBsaW5nIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cbnZhciBTQU1QTEVfMURfU05JUFBFVCA9IFwiXFxudmVjMiBVVmZyb20xRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCI7XG52YXIgU0FNUExFXzJEX1NOSVBQRVQgPSBcIlxcbnZlYzIgVVZmcm9tMkQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgbnVtQywgaW50IHJvdywgaW50IGNvbCkge1xcbiAgaW50IGluZGV4ID0gcm93ICogbnVtQyArIGNvbDtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFNBTVBMRV8zRF9TTklQUEVUID0gXCJcXG52ZWMyIFVWZnJvbTNEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHN0cmlkZTAsXFxuICAgIGludCBzdHJpZGUxLCBpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gIGludCBpbmRleCA9IHJvdyAqIHN0cmlkZTAgKyBjb2wgKiBzdHJpZGUxICsgZGVwdGg7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIjtcbnZhciBTQU1QTEVfNERfU05JUFBFVCA9IFwiXFxudmVjMiBVVmZyb200RChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBzdHJpZGUwLFxcbiAgICBpbnQgc3RyaWRlMSwgaW50IHN0cmlkZTIsIGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgaW50IGRlcHRoMikge1xcbiAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgaW50IGluZGV4ID0gcm93ICogc3RyaWRlMCArIGNvbCAqIHN0cmlkZTEgKyBkZXB0aCAqIHN0cmlkZTIgKyBkZXB0aDI7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIjtcbnZhciBVTlNJR05FRF9CWVRFX1RFWFRVUkVfU0FNUExFX1NOSVBQRVQgPSBcIlxcbiAgdW5pZm9ybSBmbG9hdCBOYU47XFxuXFxuICBjb25zdCB2ZWM0IGZsb2F0RGVsdGFzID0gdmVjNChcXG4gICAgICAxLjAsXFxuICAgICAgMS4wIC8gMjU1LjAsXFxuICAgICAgMS4wIC8gKDI1NS4wICogMjU1LjApLFxcbiAgICAgIDEuMCAvICgyNTUuMCAqIDI1NS4wICogMjU1LjApXFxuICApO1xcbiAgY29uc3QgZmxvYXQgbWluVmFsdWUgPSBcIiArIHRleF91dGlsLkZMT0FUX01JTiArIFwiLjA7XFxuICBjb25zdCBmbG9hdCBtYXhWYWx1ZSA9IFwiICsgdGV4X3V0aWwuRkxPQVRfTUFYICsgXCIuMDtcXG4gIGNvbnN0IGZsb2F0IHJhbmdlID0gKG1heFZhbHVlIC0gbWluVmFsdWUpIC8gMjU1LjA7XFxuICBjb25zdCB2ZWMyIGRvdFJhbmdlID0gdmVjMigxLjAsIHJhbmdlKTtcXG5cXG4gIGZsb2F0IHNhbXBsZShzYW1wbGVyMkQgdGV4dHVyZSwgdmVjMiB1dikge1xcbiAgICB2ZWM0IHNhbXBsZVZhbHVlID0gdGV4dHVyZTJEKHRleHR1cmUsIHV2KTtcXG4gICAgaWYgKGFsbChlcXVhbChzYW1wbGVWYWx1ZSwgdmVjNChcIiArIHRleF91dGlsLkJZVEVfTkFOX1ZBTFVFICsgXCIpKSkpIHtcXG4gICAgICByZXR1cm4gTmFOO1xcbiAgICB9XFxuXFxuICAgIHZlYzQgZW5jVmFsdWUgPSBmbG9vcihzYW1wbGVWYWx1ZSAqIDI1NS4wICsgMC41KTtcXG4gICAgZmxvYXQgZGVjb2RlZFZhbHVlID0gZG90KGVuY1ZhbHVlLCBmbG9hdERlbHRhcyk7XFxuICAgIHJldHVybiBkb3QodmVjMihtaW5WYWx1ZSwgZGVjb2RlZFZhbHVlKSwgZG90UmFuZ2UpO1xcbiAgfVxcblwiO1xudmFyIFVOU0lHTkVEX0JZVEVfVEVYVFVSRV9TRVRPVVRQVVRfU05JUFBFVCA9IFwiXFxuICBjb25zdCB2ZWM0IGZsb2F0UG93ZXJzID0gdmVjNChcXG4gICAgMS4wLFxcbiAgICAyNTUuMCxcXG4gICAgMjU1LjAgKiAyNTUuMCxcXG4gICAgMjU1LjAgKiAyNTUuMCAqIDI1NS4wXFxuICApO1xcbiAgY29uc3QgdmVjMiByZWNpcFJhbmdlID0gdmVjMigxLjAvcmFuZ2UpO1xcbiAgY29uc3QgdmVjMiByZWNpcFJhbmdlMjU1ID0gdmVjMigxLjAvKG1heFZhbHVlIC0gbWluVmFsdWUpKTtcXG5cXG4gIHZvaWQgc2V0T3V0cHV0KGZsb2F0IGRlY29kZWRWYWx1ZSkge1xcbiAgICBpZiAoaXNOYU4oZGVjb2RlZFZhbHVlKSkge1xcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoXCIgKyB0ZXhfdXRpbC5CWVRFX05BTl9WQUxVRSArIFwiKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZmxvYXQgYSA9IGRvdCh2ZWMyKGRlY29kZWRWYWx1ZSwgLW1pblZhbHVlKSwgcmVjaXBSYW5nZSk7XFxuICAgIGZsb2F0IGIgPSBmcmFjdChhKSAqIDI1NS4wO1xcbiAgICBmbG9hdCBjID0gZnJhY3QoYikgKiAyNTUuMDtcXG4gICAgZmxvYXQgZCA9IGZyYWN0KGMpICogMjU1LjA7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGZsb29yKHZlYzQoYSwgYiwgYywgZCkpIC8gMjU1LjA7XFxuXFxuICAgIC8vIFRPRE8oZHNtaWxrb3YpOiBWZXJzaW9uIGFib3ZlIGdldHMgYmV0dGVyIGFjY3VyYWN5IGJ1dCBwcm9iYWJseSBzbG93ZXJcXG4gICAgLy8gdGhhbiB0aGUgdmVyc2lvbiBiZWxvdy4gQmVuY2htYXJrIHRvIGRldGVybWluZSBpZiB0aGUgYWNjdXJhY3kgaXMgd29ydGhcXG4gICAgLy8gdGhlIGNvc3QuXFxuXFxuICAgIC8vIGZsb2F0IG5vcm1WYWx1ZSA9IGRvdCh2ZWMyKGRlY29kZWRWYWx1ZSwgLW1pblZhbHVlKSwgcmVjaXBSYW5nZTI1NSk7XFxuICAgIC8vIHZlYzQgZiA9IG5vcm1WYWx1ZSAqIGZsb2F0UG93ZXJzO1xcbiAgICAvLyBnbF9GcmFnQ29sb3IgPSBmbG9vcihmcmFjdChmKSAqIDI1NS4wKSAvIDI1NS4wO1xcbiAgfVxcblwiO1xudmFyIEZMT0FUX1RFWFRVUkVfU0FNUExFX1NOSVBQRVQgPSBcIlxcbiAgZmxvYXQgc2FtcGxlKHNhbXBsZXIyRCB0ZXh0dXJlLCB2ZWMyIHV2KSB7XFxuICAgIHJldHVybiB0ZXh0dXJlMkQodGV4dHVyZSwgdXYpLnI7XFxuICB9XFxuXCI7XG52YXIgRkxPQVRfVEVYVFVSRV9TRVRPVVRQVVRfU05JUFBFVCA9IFwiXFxuICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2YWwsIDAsIDAsIDApO1xcbiAgfVxcblwiO1xudmFyIFNIQURFUl9QUkVGSVggPSBcIlxcbiAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgcHJlY2lzaW9uIGhpZ2hwIGludDtcXG4gIHZhcnlpbmcgdmVjMiByZXN1bHRVVjtcXG4gIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XFxuXFxuICBib29sIGlzTmFOKGZsb2F0IHZhbCkge1xcbiAgICByZXR1cm4gdmFsID09IHZhbCA/IGZhbHNlIDogdHJ1ZTtcXG4gIH1cXG5cXG4gIGJvb2wgaGFzTmFOKHZlYzQgdmFsdWVzKSB7XFxuICAgIHJldHVybiBhbnkobm90RXF1YWwodmFsdWVzLCB2YWx1ZXMpKTtcXG4gIH1cXG5cXG4gIGZsb2F0IGdldE5hTih2ZWM0IHZhbHVlcykge1xcbiAgICByZXR1cm4gZG90KHZlYzQoMSksIHZhbHVlcyk7XFxuICB9XFxuXFxuICBpbnQgcm91bmQoZmxvYXQgdmFsdWUpIHtcXG4gICAgcmV0dXJuIGludChmbG9vcih2YWx1ZSArIDAuNSkpO1xcbiAgfVxcblxcbiAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XFxuICAgIHJldHVybiB4IC0geSAqICh4IC8geSk7XFxuICB9XFxuXFxuICBjb25zdCB2ZWMyIHJhbmRvbUNvbnN0ID0gdmVjMihcXG4gICAgMjMuMTQwNjkyNjMyNzc5MjYsIC8vIGVecGkgKEdlbGZvbmQncyBjb25zdGFudClcXG4gICAgIDIuNjY1MTQ0MTQyNjkwMjI1IC8vIDJec3FydCgyKSAoR2VsZm9uZFxcdTIwMTNTY2huZWlkZXIgY29uc3RhbnQpXFxuICApO1xcblxcbiAgZmxvYXQgcmFuZG9tKGZsb2F0IHNlZWQpIHtcXG4gICAgICByZXR1cm4gZnJhY3QoY29zKGRvdChyZXN1bHRVViAqIHNlZWQsIHJhbmRvbUNvbnN0KSkgKiAxMjM0NS42Nzg5KTtcXG4gIH1cXG5cXG4gIGZsb2F0IHNhbXBsZVVWQW5kRGVwdGgoc2FtcGxlcjJEIHRleHR1cmUsIHZlYzIgdXYsIGludCBkZXB0aCkge1xcbiAgICBmbG9hdCB2YWx1ZTtcXG4gICAgaWYgKGRlcHRoID09IDApIHtcXG4gICAgICB2YWx1ZSA9IHRleHR1cmUyRCh0ZXh0dXJlLCB1dikucjtcXG4gICAgfSBlbHNlIGlmIChkZXB0aCA9PSAxKSB7XFxuICAgICAgdmFsdWUgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdXYpLmc7XFxuICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMikge1xcbiAgICAgIHZhbHVlID0gdGV4dHVyZTJEKHRleHR1cmUsIHV2KS5iO1xcbiAgICB9IGVsc2UgaWYgKGRlcHRoID09IDMpIHtcXG4gICAgICB2YWx1ZSA9IHRleHR1cmUyRCh0ZXh0dXJlLCB1dikuYTtcXG4gICAgfVxcbiAgICByZXR1cm4gZmxvb3IodmFsdWUgKiAyNTUuMCArIDAuNSk7XFxuICB9XFxuXFxuICBcIiArIFNBTVBMRV8xRF9TTklQUEVUICsgXCJcXG4gIFwiICsgU0FNUExFXzJEX1NOSVBQRVQgKyBcIlxcbiAgXCIgKyBTQU1QTEVfM0RfU05JUFBFVCArIFwiXFxuICBcIiArIFNBTVBMRV80RF9TTklQUEVUICsgXCJcXG5cIjtcbmZ1bmN0aW9uIGdldE91dHB1dFNjYWxhckNvb3JkcygpIHtcbiAgICByZXR1cm4gXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQxRENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICBpZiAodGV4U2hhcGVbMF0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4U2hhcGVbMV0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueSAqIFwiICsgdGV4U2hhcGVbMF0gKyBcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICByZXR1cm4gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0M0RDb29yZHMoc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHNoYXBlWzJdO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl07XG4gICAgcmV0dXJuIFwiXFxuICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICBpbnQgciA9IGluZGV4IC8gXCIgKyBzdHJpZGUwICsgXCI7XFxuICAgICAgaW5kZXggLT0gciAqIFwiICsgc3RyaWRlMCArIFwiO1xcbiAgICAgIGludCBjID0gaW5kZXggLyBcIiArIHN0cmlkZTEgKyBcIjtcXG4gICAgICBpbnQgZCA9IGluZGV4IC0gYyAqIFwiICsgc3RyaWRlMSArIFwiO1xcbiAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQ0RENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICB2YXIgc3RyaWRlMiA9IHNoYXBlWzNdO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICAgIHZhciBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuICAgIHJldHVybiBcIlxcbiAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgaW50IHIgPSBpbmRleCAvIFwiICsgc3RyaWRlMCArIFwiO1xcbiAgICAgIGluZGV4IC09IHIgKiBcIiArIHN0cmlkZTAgKyBcIjtcXG5cXG4gICAgICBpbnQgYyA9IGluZGV4IC8gXCIgKyBzdHJpZGUxICsgXCI7XFxuICAgICAgaW5kZXggLT0gYyAqIFwiICsgc3RyaWRlMSArIFwiO1xcblxcbiAgICAgIGludCBkID0gaW5kZXggLyBcIiArIHN0cmlkZTIgKyBcIjtcXG4gICAgICBpbnQgZDIgPSBpbmRleCAtIGQgKiBcIiArIHN0cmlkZTIgKyBcIjtcXG5cXG4gICAgICByZXR1cm4gaXZlYzQociwgYywgZCwgZDIpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dDJEQ29vcmRzKHNoYXBlLCB0ZXhTaGFwZSkge1xuICAgIGlmICh1dGlsLmFycmF5c0VxdWFsKHNoYXBlLCB0ZXhTaGFwZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmIChzaGFwZVsxXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgICByZXR1cm4gaXZlYzIoaW5kZXgsIDApO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmIChzaGFwZVswXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgICByZXR1cm4gaXZlYzIoMCwgaW5kZXgpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgaW50IHIgPSBpbmRleCAvIFwiICsgc2hhcGVbMV0gKyBcIjtcXG4gICAgICBpbnQgYyA9IGluZGV4IC0gciAqIFwiICsgc2hhcGVbMV0gKyBcIjtcXG4gICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlclNjYWxhcihpbnB1dEluZm8pIHtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIigpIHtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCBoYWxmQ1IpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXIxRChpbnB1dEluZm8pIHtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICByZXR1cm4gXCIgKyBmdW5jTmFtZSArIFwiRmxhdChpbmRleCk7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlcjJEKGlucHV0SW5mbykge1xuICAgIHZhciBzaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICAgIHZhciB0ZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciB0ZXhOdW1SID0gdGV4U2hhcGVbMF07XG4gICAgdmFyIHRleE51bUMgPSB0ZXhTaGFwZVsxXTtcbiAgICBpZiAodXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xuICAgIH1cbiAgICB2YXIgX2EgPSB1dGlsLnNxdWVlemVTaGFwZShzaGFwZSksIG5ld1NoYXBlID0gX2EubmV3U2hhcGUsIGtlcHREaW1zID0gX2Eua2VwdERpbXM7XG4gICAgdmFyIHNxdWVlemVkU2hhcGUgPSBuZXdTaGFwZTtcbiAgICBpZiAoc3F1ZWV6ZWRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5ld0lucHV0SW5mbyA9IHNxdWVlemVJbnB1dEluZm8oaW5wdXRJbmZvLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFsncm93JywgJ2NvbCddO1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBcIiArIGdldFNhbXBsZXJGcm9tSW5JbmZvKG5ld0lucHV0SW5mbykgKyBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICByZXR1cm4gXCIgKyBmdW5jTmFtZSArIFwiKFwiICsgZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcykgKyBcIik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleE51bUMgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgaW50IGluZGV4ID0gcm93ICogXCIgKyBzaGFwZVsxXSArIFwiICsgY29sO1xcbiAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4KSArIDAuNSkgLyBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xuICAgIH1cbiAgICBpZiAodGV4TnVtUiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiBcIiArIHNoYXBlWzFdICsgXCIgKyBjb2w7XFxuICAgICAgdmVjMiB1diA9IHZlYzIoKGZsb2F0KGluZGV4KSArIDAuNSkgLyBcIiArIHRleE51bUMgKyBcIi4wLCAwLjUpO1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgdmVjMiB1diA9IFVWZnJvbTJEKFwiICsgdGV4TnVtUiArIFwiLCBcIiArIHRleE51bUMgKyBcIiwgXCIgKyBzaGFwZVsxXSArIFwiLCByb3csIGNvbCk7XFxuICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gIH1cXG5cIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXIzRChpbnB1dEluZm8pIHtcbiAgICB2YXIgdGV4U2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIHZhciBzaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICB2YXIgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIHZhciB0ZXhOdW1DID0gdGV4U2hhcGVbMV07XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHNoYXBlWzJdO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl07XG4gICAgdmFyIHRleFR5cGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleHR1cmVUeXBlO1xuICAgIGlmICh0ZXhUeXBlID09PSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLkRFRkFVTFQpIHtcbiAgICAgICAgdmFyIF9hID0gdXRpbC5zcXVlZXplU2hhcGUoc2hhcGUpLCBuZXdTaGFwZSA9IF9hLm5ld1NoYXBlLCBrZXB0RGltcyA9IF9hLmtlcHREaW1zO1xuICAgICAgICB2YXIgc3F1ZWV6ZWRTaGFwZSA9IG5ld1NoYXBlO1xuICAgICAgICBpZiAoc3F1ZWV6ZWRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuZXdJbnB1dEluZm8gPSBzcXVlZXplSW5wdXRJbmZvKGlucHV0SW5mbywgc3F1ZWV6ZWRTaGFwZSk7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gWydyb3cnLCAnY29sJywgJ2RlcHRoJ107XG4gICAgICAgICAgICByZXR1cm4gXCJcXG4gICAgICAgIFwiICsgZ2V0U2FtcGxlckZyb21JbkluZm8obmV3SW5wdXRJbmZvKSArIFwiXFxuICAgICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICAgIHJldHVybiBcIiArIGZ1bmNOYW1lICsgXCIoXCIgKyBnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKSArIFwiKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGV4TnVtQyA9PT0gc3RyaWRlMCkge1xuICAgICAgICBpZiAodGV4VHlwZSA9PT0gdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5ERUZBVUxUKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXG4gICAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgICAgaW50IHRleFIgPSByb3c7XFxuICAgICAgICAgIGludCB0ZXhDID0gY29sICogXCIgKyBzdHJpZGUxICsgXCIgKyBkZXB0aDtcXG4gICAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleFR5cGUgPT09IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuUkdCQV9DT0xPUikge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVVZBbmREZXB0aChcIiArIHRleE5hbWUgKyBcIiwgdXYsIGRlcHRoKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gVGV4dHVyZVR5cGUgXCIgKyB0ZXhUeXBlICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUxICYmIHRleFR5cGUgPT09IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuREVGQVVMVCkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgIGludCB0ZXhSID0gcm93ICogXCIgKyBzaGFwZVsxXSArIFwiICsgY29sO1xcbiAgICAgIGludCB0ZXhDID0gZGVwdGg7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbiAgICB9XG4gICAgaWYgKHRleFR5cGUgPT09IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuREVGQVVMVCkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICB2ZWMyIHV2ID0gVVZmcm9tM0QoXFxuICAgICAgICAgICAgXCIgKyB0ZXhOdW1SICsgXCIsIFwiICsgdGV4TnVtQyArIFwiLCBcIiArIHN0cmlkZTAgKyBcIiwgXCIgKyBzdHJpZGUxICsgXCIsIHJvdywgY29sLCBkZXB0aCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRleFR5cGUgPT09IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuUkdCQV9DT0xPUikge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICB2ZWMyIHV2ID0gVVZmcm9tMkQoXCIgKyB0ZXhOdW1SICsgXCIsIFwiICsgdGV4TnVtQyArIFwiLCBcIiArIHNoYXBlWzFdICsgXCIsIHJvdywgY29sKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVVVkFuZERlcHRoKFwiICsgdGV4TmFtZSArIFwiLCB1diwgZGVwdGgpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIFRleHR1cmVUeXBlIFwiICsgdGV4VHlwZSArIFwiLlwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyNEQoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIHRleE51bVIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdGV4TnVtQyA9IHRleFNoYXBlWzFdO1xuICAgIHZhciBzdHJpZGUyID0gc2hhcGVbM107XG4gICAgdmFyIHN0cmlkZTEgPSBzaGFwZVsyXSAqIHN0cmlkZTI7XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG4gICAgdmFyIF9hID0gdXRpbC5zcXVlZXplU2hhcGUoc2hhcGUpLCBuZXdTaGFwZSA9IF9hLm5ld1NoYXBlLCBrZXB0RGltcyA9IF9hLmtlcHREaW1zO1xuICAgIGlmIChuZXdTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5ld0lucHV0SW5mbyA9IHNxdWVlemVJbnB1dEluZm8oaW5wdXRJbmZvLCBuZXdTaGFwZSk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbJ3JvdycsICdjb2wnLCAnZGVwdGgnLCAnZGVwdGgyJ107XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIFwiICsgZ2V0U2FtcGxlckZyb21JbkluZm8obmV3SW5wdXRJbmZvKSArIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgcmV0dXJuIFwiICsgZnVuY05hbWUgKyBcIihcIiArIGdldFNxdWVlemVkUGFyYW1zKHBhcmFtcywga2VwdERpbXMpICsgXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUwKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGludCB0ZXhSID0gcm93O1xcbiAgICAgICAgaW50IHRleEMgPSBjb2wgKiBcIiArIHN0cmlkZTEgKyBcIiArIGRlcHRoICogXCIgKyBzdHJpZGUyICsgXCIgKyBkZXB0aDI7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4TnVtQyA9PT0gc3RyaWRlMikge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdyAqIFwiICsgc2hhcGVbMV0gKiBzaGFwZVsyXSArIFwiICsgY29sICogXCIgKyBzaGFwZVsyXSArIFwiICsgZGVwdGg7XFxuICAgICAgICBpbnQgdGV4QyA9IGRlcHRoMjtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICB2ZWMyIHV2ID0gVVZmcm9tNEQoXCIgKyB0ZXhOdW1SICsgXCIsIFwiICsgdGV4TnVtQyArIFwiLCBcIiArIHN0cmlkZTAgKyBcIiwgXCIgKyBzdHJpZGUxICsgXCIsXFxuICAgICAgICAgIFwiICsgc3RyaWRlMiArIFwiLCByb3csIGNvbCwgZGVwdGgsIGRlcHRoMik7XFxuICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXJGbGF0KGlucHV0SW5mbykge1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpICsgJ0ZsYXQnO1xuICAgIHZhciB0TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIHZhciB0TnVtQyA9IHRleFNoYXBlWzFdO1xuICAgIGlmICh0TnVtQyA9PT0gMSAmJiB0TnVtUiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IGluZGV4KSB7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCBoYWxmQ1IpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0TnVtQyA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChmbG9hdChpbmRleCkgKyAwLjUpIC8gXCIgKyB0TnVtUiArIFwiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0TnVtUiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvIFwiICsgdE51bUMgKyBcIi4wLCAwLjUpO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IGluZGV4KSB7XFxuICAgICAgdmVjMiB1diA9IFVWZnJvbTFEKFwiICsgdE51bVIgKyBcIiwgXCIgKyB0TnVtQyArIFwiLCBpbmRleCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldEJyb2FkY2FzdE91dHB1dENvb3Jkc1NhbXBsZXIoaW5wdXRJbmZvLCBvdXRTaGFwZUluZm8sIHRleEZ1bmNTbmlwcGV0LCBmdW5jTmFtZSkge1xuICAgIHZhciBpblJhbmsgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGg7XG4gICAgdmFyIG91dFJhbmsgPSBvdXRTaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aDtcbiAgICB2YXIgdHlwZSA9ICdpbnQnO1xuICAgIGlmIChvdXRSYW5rID09PSAyKSB7XG4gICAgICAgIHR5cGUgPSAnaXZlYzInO1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXRSYW5rID09PSAzKSB7XG4gICAgICAgIHR5cGUgPSAnaXZlYzMnO1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXRSYW5rID09PSA0KSB7XG4gICAgICAgIHR5cGUgPSAnaXZlYzQnO1xuICAgIH1cbiAgICB2YXIgYnJvYWRjYXN0RGltcyA9IGJyb2FkY2FzdF91dGlsLmdldEJyb2FkY2FzdERpbXMoaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsIG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO1xuICAgIHZhciByYW5rRGlmZiA9IG91dFJhbmsgLSBpblJhbms7XG4gICAgdmFyIGNvb3Jkc1NuaXBwZXQ7XG4gICAgaWYgKGluUmFuayA9PT0gMCkge1xuICAgICAgICBjb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dFJhbmsgPCAyICYmIGJyb2FkY2FzdERpbXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgY29vcmRzU25pcHBldCA9ICdjb29yZHMgPSAwOyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb29yZHNTbmlwcGV0ID1cbiAgICAgICAgICAgIGJyb2FkY2FzdERpbXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBcImNvb3Jkc1tcIiArIChkICsgcmFua0RpZmYpICsgXCJdID0gMDtcIjsgfSkuam9pbignXFxuJyk7XG4gICAgfVxuICAgIHZhciB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnJztcbiAgICBpZiAob3V0UmFuayA8IDIgJiYgaW5SYW5rID4gMCkge1xuICAgICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnY29vcmRzJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzLCBpKSB7IHJldHVybiBcImNvb3Jkc1tcIiArIChpICsgcmFua0RpZmYpICsgXCJdXCI7IH0pXG4gICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIigpIHtcXG4gICAgICBcIiArIHR5cGUgKyBcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBcIiArIGNvb3Jkc1NuaXBwZXQgKyBcIlxcbiAgICAgIHJldHVybiBnZXRcIiArIHRleEZ1bmNTbmlwcGV0ICsgXCIoXCIgKyB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgKyBcIik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlckF0T3V0cHV0Q29vcmRzKGlucHV0SW5mbywgb3V0U2hhcGVJbmZvLCBzdXBwb3J0c0Jyb2FkY2FzdGluZykge1xuICAgIHZhciBpblRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBpc1JHQkFDb2xvclRleHR1cmUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleHR1cmVUeXBlID09PSB0ZXhfdXRpbF8xLlRleHR1cmVUeXBlLlJHQkFfQ09MT1I7XG4gICAgdmFyIHRleEZ1bmNTbmlwcGV0ID0gdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhGdW5jU25pcHBldCArICdBdE91dENvb3Jkcyc7XG4gICAgdmFyIGJyb2FkY2FzdERpbXMgPSBicm9hZGNhc3RfdXRpbC5nZXRCcm9hZGNhc3REaW1zKGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLCBvdXRTaGFwZUluZm8ubG9naWNhbFNoYXBlKTtcbiAgICB2YXIgaW5SYW5rID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoO1xuICAgIHZhciBvdXRSYW5rID0gb3V0U2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGg7XG4gICAgdmFyIGRvQnJvYWRjYXN0ID0gc3VwcG9ydHNCcm9hZGNhc3RpbmcgJiYgKChvdXRSYW5rID4gaW5SYW5rKSB8fCBicm9hZGNhc3REaW1zLmxlbmd0aCA+IDApO1xuICAgIHZhciBicm9hZGNhc3RPdmVyT3V0ZXIgPSBicm9hZGNhc3RfdXRpbC5icm9hZGNhc3REaW1zQXJlT3V0ZXIoYnJvYWRjYXN0RGltcyk7XG4gICAgaWYgKGRvQnJvYWRjYXN0ICYmICFicm9hZGNhc3RPdmVyT3V0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEJyb2FkY2FzdE91dHB1dENvb3Jkc1NhbXBsZXIoaW5wdXRJbmZvLCBvdXRTaGFwZUluZm8sIHRleEZ1bmNTbmlwcGV0LCBmdW5jTmFtZSk7XG4gICAgfVxuICAgIHZhciBvdXRUZXhTaGFwZSA9IG91dFNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICBpZiAodXRpbC5hcnJheXNFcXVhbChpblRleFNoYXBlLCBvdXRUZXhTaGFwZSkgJiYgIWlzUkdCQUNvbG9yVGV4dHVyZSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoKSB7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCByZXN1bHRVVik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgdmFyIGluVGV4RXhwYW5kZWRTaGFwZSA9IGlzUkdCQUNvbG9yVGV4dHVyZSA/XG4gICAgICAgIFtpblRleFNoYXBlWzBdLCBpblRleFNoYXBlWzFdICogaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGVbMl1dIDpcbiAgICAgICAgaW5UZXhTaGFwZTtcbiAgICB2YXIgc2FtcGxlU25pcHBldCA9IFwicmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1wiO1xuICAgIHZhciByZ2JhQ29sb3JTbmlwcGV0ID0gJyc7XG4gICAgaWYgKGlzUkdCQUNvbG9yVGV4dHVyZSkge1xuICAgICAgICByZ2JhQ29sb3JTbmlwcGV0ID0gXCJcXG4gICAgICBpbnQgY29sID0gdGV4QyAvIFwiICsgaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGVbMl0gKyBcIjtcXG4gICAgICBpbnQgdGV4RCA9IHRleEMgLSBjb2wgKiBcIiArIGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlWzJdICsgXCI7XFxuICAgICAgdGV4QyA9IGNvbDtcXG4gICAgXCI7XG4gICAgICAgIHNhbXBsZVNuaXBwZXQgPSBcInJldHVybiBzYW1wbGVVVkFuZERlcHRoKFwiICsgdGV4TmFtZSArIFwiLCB1diwgdGV4RCk7XCI7XG4gICAgfVxuICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoaW5UZXhFeHBhbmRlZFNoYXBlKTtcbiAgICB2YXIgYnJvYWRjYXN0U25pcHBldCA9ICcnO1xuICAgIGlmIChkb0Jyb2FkY2FzdCAmJiBicm9hZGNhc3RPdmVyT3V0ZXIpIHtcbiAgICAgICAgYnJvYWRjYXN0U25pcHBldCA9IFwiXFxuICAgICAgICBpbnQgbWFpblBhcnQgPSBpbmRleCAvIFwiICsgaW5TaXplICsgXCI7XFxuICAgICAgICBpbmRleCAtPSBtYWluUGFydCAqIFwiICsgaW5TaXplICsgXCI7XFxuICAgICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgb3V0VGV4U2hhcGVbMF0gKyBcIiwgXCIgKyBvdXRUZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgb3V0VGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgXCIgKyBicm9hZGNhc3RTbmlwcGV0ICsgXCJcXG4gICAgICBpbnQgdGV4UiA9IGluZGV4IC8gXCIgKyBpblRleEV4cGFuZGVkU2hhcGVbMV0gKyBcIjtcXG4gICAgICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIFwiICsgaW5UZXhFeHBhbmRlZFNoYXBlWzFdICsgXCI7XFxuXFxuICAgICAgXCIgKyByZ2JhQ29sb3JTbmlwcGV0ICsgXCJcXG5cXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgIHZlYzIoXCIgKyBpblRleFNoYXBlWzFdICsgXCIuMCwgXCIgKyBpblRleFNoYXBlWzBdICsgXCIuMCk7XFxuXFxuICAgICAgXCIgKyBzYW1wbGVTbmlwcGV0ICsgXCJcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRDb29yZHNEYXRhVHlwZShyYW5rKSB7XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdpbnQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAyKSB7XG4gICAgICAgIHJldHVybiAnaXZlYzInO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAzKSB7XG4gICAgICAgIHJldHVybiAnaXZlYzMnO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgICAgIHJldHVybiAnaXZlYzQnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJHUFUgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRDb29yZHNEYXRhVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlO1xuZnVuY3Rpb24gc3F1ZWV6ZUlucHV0SW5mbyhpbkluZm8sIHNxdWVlemVkU2hhcGUpIHtcbiAgICB2YXIgbmV3SW5wdXRJbmZvID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbkluZm8pKTtcbiAgICBuZXdJbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSA9IHNxdWVlemVkU2hhcGU7XG4gICAgcmV0dXJuIG5ld0lucHV0SW5mbztcbn1cbmZ1bmN0aW9uIGdldFNxdWVlemVkUGFyYW1zKHBhcmFtcywga2VwdERpbXMpIHtcbiAgICByZXR1cm4ga2VwdERpbXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBwYXJhbXNbZF07IH0pLmpvaW4oJywgJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkZXJfY29tcGlsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgU2xpY2VQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbGljZVByb2dyYW0oZGVzdFNpemUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydzb3VyY2UnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGRlc3RTaXplO1xuICAgICAgICB0aGlzLnJhbmsgPSBkZXN0U2l6ZS5sZW5ndGg7XG4gICAgICAgIHZhciBkdHlwZSA9IHNoYWRlcl9jb21waWxlcl8xLmdldENvb3Jkc0RhdGFUeXBlKHRoaXMucmFuayk7XG4gICAgICAgIHZhciBzb3VyY2VDb29yZHMgPSBnZXRDb29yZHModGhpcy5yYW5rKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdW5pZm9ybSBcIiArIGR0eXBlICsgXCIgc3RhcnQ7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyBkdHlwZSArIFwiIHNvdXJjZUxvYyA9IHN0YXJ0ICsgZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0U291cmNlKFwiICsgc291cmNlQ29vcmRzICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBTbGljZVByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoc3RhcnQubGVuZ3RoICE9PSB0aGlzLnJhbmspIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIHJhbmsgKFwiICsgdGhpcy5yYW5rICsgXCIpIG9mIHRoZSBwcm9ncmFtIG11c3QgbWF0Y2ggdGhlIFwiICtcbiAgICAgICAgICAgICAgICAoXCJsZW5ndGggb2Ygc3RhcnQgKFwiICsgc3RhcnQubGVuZ3RoICsgXCIpXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdwZ3B1LCB3ZWJHTFByb2dyYW0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGFydExvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRMb2MgPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KHdlYkdMUHJvZ3JhbSwgJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXJ0TG9jID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFpKF90aGlzLnN0YXJ0TG9jLCBzdGFydFswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5yYW5rID09PSAyKSB7XG4gICAgICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTJpKF90aGlzLnN0YXJ0TG9jLCBzdGFydFswXSwgc3RhcnRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucmFuayA9PT0gMykge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0zaShfdGhpcy5zdGFydExvYywgc3RhcnRbMF0sIHN0YXJ0WzFdLCBzdGFydFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5yYW5rID09PSA0KSB7XG4gICAgICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTRpKF90aGlzLnN0YXJ0TG9jLCBzdGFydFswXSwgc3RhcnRbMV0sIHN0YXJ0WzJdLCBzdGFydFszXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNsaWNpbmcgZm9yIHJhbmsgXCIgKyBfdGhpcy5yYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gU2xpY2VQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuU2xpY2VQcm9ncmFtID0gU2xpY2VQcm9ncmFtO1xuZnVuY3Rpb24gZ2V0Q29vcmRzKHJhbmspIHtcbiAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZUxvYyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2VMb2MueCwgc291cmNlTG9jLnknO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAzKSB7XG4gICAgICAgIHJldHVybiAnc291cmNlTG9jLngsIHNvdXJjZUxvYy55LCBzb3VyY2VMb2Mueic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDQpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2VMb2MueCwgc291cmNlTG9jLnksIHNvdXJjZUxvYy56LCBzb3VyY2VMb2Mudyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlNsaWNpbmcgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2xpY2VfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRleHR1cmVUeXBlO1xuKGZ1bmN0aW9uIChUZXh0dXJlVHlwZSkge1xuICAgIFRleHR1cmVUeXBlW1RleHR1cmVUeXBlW1wiREVGQVVMVFwiXSA9IDBdID0gXCJERUZBVUxUXCI7XG4gICAgVGV4dHVyZVR5cGVbVGV4dHVyZVR5cGVbXCJSR0JBX0NPTE9SXCJdID0gMV0gPSBcIlJHQkFfQ09MT1JcIjtcbn0pKFRleHR1cmVUeXBlID0gZXhwb3J0cy5UZXh0dXJlVHlwZSB8fCAoZXhwb3J0cy5UZXh0dXJlVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBnZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gW2NvbHVtbnMsIHJvd3NdO1xufVxuZXhwb3J0cy5nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0ID0gZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodDtcbmZ1bmN0aW9uIGdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUobWF0cml4U2l6ZSwgY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgcmV0dXJuIG1hdHJpeFNpemUgKiBjaGFubmVsc1BlclRleHR1cmU7XG59XG5leHBvcnRzLmdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUgPSBnZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplO1xuZnVuY3Rpb24gZ2V0Q29sb3JNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIFtjb2x1bW5zICogNCwgcm93c107XG59XG5leHBvcnRzLmdldENvbG9yTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQgPSBnZXRDb2xvck1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0O1xuZnVuY3Rpb24gZ2V0TWF0cml4U2l6ZUZyb21VbnBhY2tlZEFycmF5U2l6ZSh1bnBhY2tlZFNpemUsIGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgIGlmICh1bnBhY2tlZFNpemUgJSBjaGFubmVsc1BlclRleHR1cmUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5wYWNrZWRTaXplIChcIiArIHVucGFja2VkU2l6ZSArIFwiKSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgXCIgK1xuICAgICAgICAgICAgKFwiXCIgKyBjaGFubmVsc1BlclRleHR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVucGFja2VkU2l6ZSAvIGNoYW5uZWxzUGVyVGV4dHVyZTtcbn1cbmV4cG9ydHMuZ2V0TWF0cml4U2l6ZUZyb21VbnBhY2tlZEFycmF5U2l6ZSA9IGdldE1hdHJpeFNpemVGcm9tVW5wYWNrZWRBcnJheVNpemU7XG5mdW5jdGlvbiBlbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXkobWF0cml4LCB1bnBhY2tlZEFycmF5LCBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICB2YXIgcmVxdWlyZWRTaXplID0gZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShtYXRyaXgubGVuZ3RoLCBjaGFubmVsc1BlclRleHR1cmUpO1xuICAgIGlmICh1bnBhY2tlZEFycmF5Lmxlbmd0aCA8IHJlcXVpcmVkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnBhY2tlZEFycmF5IGxlbmd0aCAoXCIgKyB1bnBhY2tlZEFycmF5Lmxlbmd0aCArIFwiKSBtdXN0IGJlID49IFwiICtcbiAgICAgICAgICAgIChcIlwiICsgcmVxdWlyZWRTaXplKSk7XG4gICAgfVxuICAgIHZhciBkc3QgPSAwO1xuICAgIGZvciAodmFyIHNyYyA9IDA7IHNyYyA8IG1hdHJpeC5sZW5ndGg7ICsrc3JjKSB7XG4gICAgICAgIHVucGFja2VkQXJyYXlbZHN0XSA9IG1hdHJpeFtzcmNdO1xuICAgICAgICBkc3QgKz0gY2hhbm5lbHNQZXJUZXh0dXJlO1xuICAgIH1cbn1cbmV4cG9ydHMuZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5ID0gZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5O1xuZXhwb3J0cy5GTE9BVF9NQVggPSAyMDAwMDtcbmV4cG9ydHMuRkxPQVRfTUlOID0gLWV4cG9ydHMuRkxPQVRfTUFYO1xudmFyIEZMT0FUX1JBTkdFID0gKGV4cG9ydHMuRkxPQVRfTUFYIC0gZXhwb3J0cy5GTE9BVF9NSU4pIC8gMjU1O1xudmFyIEZMT0FUX0RFTFRBUyA9IFsxLCAxIC8gMjU1LCAxIC8gKDI1NSAqIDI1NSksIDEgLyAoMjU1ICogMjU1ICogMjU1KV07XG52YXIgRkxPQVRfUE9XRVJTID0gWzEsIDI1NSwgMjU1ICogMjU1XTtcbmV4cG9ydHMuQllURV9OQU5fVkFMVUUgPSAwO1xuZnVuY3Rpb24gZW5jb2RlRmxvYXRBcnJheShmbG9hdEFycmF5KSB7XG4gICAgdmFyIHVpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGZsb2F0QXJyYXkubGVuZ3RoICogNCk7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBmbG9hdEFycmF5W2kgLyA0XTtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgdWludEFycmF5W2ldID0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRTtcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgMV0gPSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFO1xuICAgICAgICAgICAgdWludEFycmF5W2kgKyAyXSA9IGV4cG9ydHMuQllURV9OQU5fVkFMVUU7XG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDNdID0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRTtcbiAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZSA9ICh2YWx1ZSAtIGV4cG9ydHMuRkxPQVRfTUlOKSAvIEZMT0FUX1JBTkdFO1xuICAgICAgICB2YXIgZW5jID0gRkxPQVRfUE9XRVJTLm1hcChmdW5jdGlvbiAocG93KSB7IHJldHVybiBwb3cgKiBub3JtYWxpemVkVmFsdWU7IH0pO1xuICAgICAgICB2YXIgYnVja2V0cyA9IGVuYy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBNYXRoLmZsb29yKCh2YWx1ZSAlIDEpICogMjU1KTsgfSk7XG4gICAgICAgIHVpbnRBcnJheVtpXSA9IE1hdGguZmxvb3Iobm9ybWFsaXplZFZhbHVlKTtcbiAgICAgICAgdWludEFycmF5W2kgKyAxXSA9IGJ1Y2tldHNbMF07XG4gICAgICAgIHVpbnRBcnJheVtpICsgMl0gPSBidWNrZXRzWzFdO1xuICAgICAgICB1aW50QXJyYXlbaSArIDNdID0gYnVja2V0c1syXTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdWludEFycmF5Lmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIF9sb29wXzEoaSk7XG4gICAgfVxuICAgIHJldHVybiB1aW50QXJyYXk7XG59XG5leHBvcnRzLmVuY29kZUZsb2F0QXJyYXkgPSBlbmNvZGVGbG9hdEFycmF5O1xuZnVuY3Rpb24gZGVjb2RlVG9GbG9hdEFycmF5KHVpbnRBcnJheSkge1xuICAgIHZhciBmbG9hdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSh1aW50QXJyYXkubGVuZ3RoIC8gNCk7XG4gICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICBpZiAodWludEFycmF5W2ldID09PSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFICYmXG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDFdID09PSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFICYmXG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDJdID09PSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFICYmXG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDNdID09PSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFKSB7XG4gICAgICAgICAgICBmbG9hdEFycmF5W2kgLyA0XSA9IE5hTjtcbiAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRvdCA9IDA7XG4gICAgICAgIEZMT0FUX0RFTFRBUy5mb3JFYWNoKGZ1bmN0aW9uIChkZWx0YSwgaikge1xuICAgICAgICAgICAgZG90ICs9IGRlbHRhICogdWludEFycmF5W2kgKyBqXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRvdCAqIEZMT0FUX1JBTkdFICsgZXhwb3J0cy5GTE9BVF9NSU47XG4gICAgICAgIGZsb2F0QXJyYXlbaSAvIDRdID0gdmFsdWU7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVpbnRBcnJheS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBfbG9vcF8yKGkpO1xuICAgIH1cbiAgICByZXR1cm4gZmxvYXRBcnJheTtcbn1cbmV4cG9ydHMuZGVjb2RlVG9GbG9hdEFycmF5ID0gZGVjb2RlVG9GbG9hdEFycmF5O1xuZnVuY3Rpb24gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXkodW5wYWNrZWRBcnJheSwgbWF0cml4LCBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICB2YXIgcmVxdWlyZWRTaXplID0gZ2V0TWF0cml4U2l6ZUZyb21VbnBhY2tlZEFycmF5U2l6ZSh1bnBhY2tlZEFycmF5Lmxlbmd0aCwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgICBpZiAobWF0cml4Lmxlbmd0aCA8IHJlcXVpcmVkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXRyaXggbGVuZ3RoIChcIiArIG1hdHJpeC5sZW5ndGggKyBcIikgbXVzdCBiZSA+PSBcIiArIHJlcXVpcmVkU2l6ZSk7XG4gICAgfVxuICAgIHZhciBkc3QgPSAwO1xuICAgIGZvciAodmFyIHNyYyA9IDA7IHNyYyA8IHVucGFja2VkQXJyYXkubGVuZ3RoOyBzcmMgKz0gY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgICAgIG1hdHJpeFtkc3QrK10gPSB1bnBhY2tlZEFycmF5W3NyY107XG4gICAgfVxufVxuZXhwb3J0cy5kZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRBcnJheSA9IGRlY29kZU1hdHJpeEZyb21VbnBhY2tlZEFycmF5O1xuZnVuY3Rpb24gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQ29sb3JSR0JBQXJyYXkodW5wYWNrZWRBcnJheSwgbWF0cml4LCBjaGFubmVscykge1xuICAgIHZhciByZXF1aXJlZFNpemUgPSB1bnBhY2tlZEFycmF5Lmxlbmd0aCAqIGNoYW5uZWxzIC8gNDtcbiAgICBpZiAobWF0cml4Lmxlbmd0aCA8IHJlcXVpcmVkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXRyaXggbGVuZ3RoIChcIiArIG1hdHJpeC5sZW5ndGggKyBcIikgbXVzdCBiZSA+PSBcIiArIHJlcXVpcmVkU2l6ZSk7XG4gICAgfVxuICAgIHZhciBkc3QgPSAwO1xuICAgIGZvciAodmFyIHNyYyA9IDA7IHNyYyA8IHVucGFja2VkQXJyYXkubGVuZ3RoOyBzcmMgKz0gNCkge1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgICAgIG1hdHJpeFtkc3QrK10gPSB1bnBhY2tlZEFycmF5W3NyYyArIGNdO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRDb2xvclJHQkFBcnJheSA9IGRlY29kZU1hdHJpeEZyb21VbnBhY2tlZENvbG9yUkdCQUFycmF5O1xuZnVuY3Rpb24gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiBbTWF0aC5jZWlsKGNvbHVtbnMgLyAyKSwgTWF0aC5jZWlsKHJvd3MgLyAyKV07XG59XG5leHBvcnRzLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0ID0gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQ7XG5mdW5jdGlvbiBnZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdyA9IF9hWzBdLCBoID0gX2FbMV07XG4gICAgcmV0dXJuIHcgKiBoICogNDtcbn1cbmV4cG9ydHMuZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZSA9IGdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGU7XG5mdW5jdGlvbiBlbmNvZGVNYXRyaXhUb1BhY2tlZFJHQkEobWF0cml4LCByb3dzLCBjb2x1bW5zLCBwYWNrZWRSR0JBKSB7XG4gICAgdmFyIHJlcXVpcmVkU2l6ZSA9IGdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUocm93cywgY29sdW1ucyk7XG4gICAgaWYgKHBhY2tlZFJHQkEubGVuZ3RoIDwgcmVxdWlyZWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBhY2tlZFJHQkEgbGVuZ3RoIChcIiArIHBhY2tlZFJHQkEubGVuZ3RoICsgXCIpIG11c3QgYmUgPj0gXCIgKyByZXF1aXJlZFNpemUpO1xuICAgIH1cbiAgICB2YXIgX2EgPSBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdGV4dHVyZVdpZHRoID0gX2FbMF0sIHRleHR1cmVIZWlnaHQgPSBfYVsxXTtcbiAgICB2YXIgb2RkV2lkdGggPSAoY29sdW1ucyAlIDIpID09PSAxO1xuICAgIHZhciBvZGRIZWlnaHQgPSAocm93cyAlIDIpID09PSAxO1xuICAgIHZhciB3aWR0aEluRnVsbEJsb2NrcyA9IE1hdGguZmxvb3IoY29sdW1ucyAvIDIpO1xuICAgIHZhciBoZWlnaHRJbkZ1bGxCbG9ja3MgPSBNYXRoLmZsb29yKHJvd3MgLyAyKTtcbiAgICB7XG4gICAgICAgIHZhciBkc3RTdHJpZGUgPSAob2RkV2lkdGggPyA0IDogMCk7XG4gICAgICAgIHZhciBvbmVSb3cgPSBjb2x1bW5zO1xuICAgICAgICB2YXIgZHN0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgYmxvY2tZID0gMDsgYmxvY2tZIDwgaGVpZ2h0SW5GdWxsQmxvY2tzOyArK2Jsb2NrWSkge1xuICAgICAgICAgICAgdmFyIG1hdHJpeFNyY1JvdyA9IChibG9ja1kgKiAyICogY29sdW1ucyk7XG4gICAgICAgICAgICBmb3IgKHZhciBibG9ja1ggPSAwOyBibG9ja1ggPCB3aWR0aEluRnVsbEJsb2NrczsgKytibG9ja1gpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0cml4U3JjQ29sID0gYmxvY2tYICogMjtcbiAgICAgICAgICAgICAgICB2YXIgc3JjID0gbWF0cml4U3JjUm93ICsgbWF0cml4U3JjQ29sO1xuICAgICAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0XSA9IG1hdHJpeFtzcmNdO1xuICAgICAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0ICsgMV0gPSBtYXRyaXhbc3JjICsgMV07XG4gICAgICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAyXSA9IG1hdHJpeFtzcmMgKyBvbmVSb3ddO1xuICAgICAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0ICsgM10gPSBtYXRyaXhbc3JjICsgb25lUm93ICsgMV07XG4gICAgICAgICAgICAgICAgZHN0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkc3QgKz0gZHN0U3RyaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRXaWR0aCkge1xuICAgICAgICB2YXIgc3JjID0gY29sdW1ucyAtIDE7XG4gICAgICAgIHZhciBkc3QgPSAodGV4dHVyZVdpZHRoIC0gMSkgKiA0O1xuICAgICAgICB2YXIgc3JjU3RyaWRlID0gMiAqIGNvbHVtbnM7XG4gICAgICAgIHZhciBkc3RTdHJpZGUgPSB0ZXh0dXJlV2lkdGggKiA0O1xuICAgICAgICBmb3IgKHZhciBibG9ja1kgPSAwOyBibG9ja1kgPCBoZWlnaHRJbkZ1bGxCbG9ja3M7ICsrYmxvY2tZKSB7XG4gICAgICAgICAgICBwYWNrZWRSR0JBW2RzdF0gPSBtYXRyaXhbc3JjXTtcbiAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0ICsgMl0gPSBtYXRyaXhbc3JjICsgY29sdW1uc107XG4gICAgICAgICAgICBzcmMgKz0gc3JjU3RyaWRlO1xuICAgICAgICAgICAgZHN0ICs9IGRzdFN0cmlkZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2RkSGVpZ2h0KSB7XG4gICAgICAgIHZhciBzcmMgPSAocm93cyAtIDEpICogY29sdW1ucztcbiAgICAgICAgdmFyIGRzdCA9ICh0ZXh0dXJlSGVpZ2h0IC0gMSkgKiB0ZXh0dXJlV2lkdGggKiA0O1xuICAgICAgICBmb3IgKHZhciBibG9ja1ggPSAwOyBibG9ja1ggPCB3aWR0aEluRnVsbEJsb2NrczsgKytibG9ja1gpIHtcbiAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0KytdID0gbWF0cml4W3NyYysrXTtcbiAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0KytdID0gbWF0cml4W3NyYysrXTtcbiAgICAgICAgICAgIGRzdCArPSAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRXaWR0aCAmJiBvZGRIZWlnaHQpIHtcbiAgICAgICAgcGFja2VkUkdCQVtwYWNrZWRSR0JBLmxlbmd0aCAtIDRdID0gbWF0cml4W21hdHJpeC5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhY2tlZFJHQkE7XG59XG5leHBvcnRzLmVuY29kZU1hdHJpeFRvUGFja2VkUkdCQSA9IGVuY29kZU1hdHJpeFRvUGFja2VkUkdCQTtcbmZ1bmN0aW9uIGRlY29kZU1hdHJpeEZyb21QYWNrZWRSR0JBKHBhY2tlZFJHQkEsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCkge1xuICAgIHZhciByZXF1aXJlZFNpemUgPSByb3dzICogY29sdW1ucztcbiAgICBpZiAocmVxdWlyZWRTaXplIDwgbWF0cml4Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXRyaXggbGVuZ3RoIChcIiArIG1hdHJpeC5sZW5ndGggKyBcIikgbXVzdCBiZSA+PSBcIiArIHJlcXVpcmVkU2l6ZSk7XG4gICAgfVxuICAgIHZhciBvZGRXaWR0aCA9IChjb2x1bW5zICUgMikgPT09IDE7XG4gICAgdmFyIG9kZEhlaWdodCA9IChyb3dzICUgMikgPT09IDE7XG4gICAgdmFyIHdpZHRoSW5GdWxsQmxvY2tzID0gTWF0aC5mbG9vcihjb2x1bW5zIC8gMik7XG4gICAgdmFyIGhlaWdodEluRnVsbEJsb2NrcyA9IE1hdGguZmxvb3Iocm93cyAvIDIpO1xuICAgIHZhciBfYSA9IGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB0ZXh0dXJlV2lkdGggPSBfYVswXSwgdGV4dHVyZUhlaWdodCA9IF9hWzFdO1xuICAgIHtcbiAgICAgICAgdmFyIHNyY1N0cmlkZSA9IG9kZFdpZHRoID8gNCA6IDA7XG4gICAgICAgIHZhciBkc3RTdHJpZGUgPSBjb2x1bW5zICsgKG9kZFdpZHRoID8gMSA6IDApO1xuICAgICAgICB2YXIgc3JjID0gMDtcbiAgICAgICAgdmFyIGRzdFJvdzEgPSAwO1xuICAgICAgICB2YXIgZHN0Um93MiA9IGNvbHVtbnM7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgICAgICAgICAgIG1hdHJpeFtkc3RSb3cxKytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgICAgICAgICAgbWF0cml4W2RzdFJvdzErK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgICAgICBtYXRyaXhbZHN0Um93MisrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgICAgIG1hdHJpeFtkc3RSb3cyKytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcmMgKz0gc3JjU3RyaWRlO1xuICAgICAgICAgICAgZHN0Um93MSArPSBkc3RTdHJpZGU7XG4gICAgICAgICAgICBkc3RSb3cyICs9IGRzdFN0cmlkZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2RkV2lkdGgpIHtcbiAgICAgICAgdmFyIHNyYyA9ICh0ZXh0dXJlV2lkdGggLSAxKSAqIDQ7XG4gICAgICAgIHZhciBkc3QgPSBjb2x1bW5zIC0gMTtcbiAgICAgICAgdmFyIHNyY1N0cmlkZSA9IHRleHR1cmVXaWR0aCAqIDQ7XG4gICAgICAgIHZhciBkc3RTdHJpZGUgPSAyICogY29sdW1ucztcbiAgICAgICAgZm9yICh2YXIgYmxvY2tZID0gMDsgYmxvY2tZIDwgaGVpZ2h0SW5GdWxsQmxvY2tzOyArK2Jsb2NrWSkge1xuICAgICAgICAgICAgbWF0cml4W2RzdF0gPSBwYWNrZWRSR0JBW3NyY107XG4gICAgICAgICAgICBtYXRyaXhbZHN0ICsgY29sdW1uc10gPSBwYWNrZWRSR0JBW3NyYyArIDJdO1xuICAgICAgICAgICAgc3JjICs9IHNyY1N0cmlkZTtcbiAgICAgICAgICAgIGRzdCArPSBkc3RTdHJpZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZEhlaWdodCkge1xuICAgICAgICB2YXIgc3JjID0gKHRleHR1cmVIZWlnaHQgLSAxKSAqIHRleHR1cmVXaWR0aCAqIDQ7XG4gICAgICAgIHZhciBkc3QgPSAocm93cyAtIDEpICogY29sdW1ucztcbiAgICAgICAgZm9yICh2YXIgYmxvY2tYID0gMDsgYmxvY2tYIDwgd2lkdGhJbkZ1bGxCbG9ja3M7ICsrYmxvY2tYKSB7XG4gICAgICAgICAgICBtYXRyaXhbZHN0KytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgICAgICBtYXRyaXhbZHN0KytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgICAgICBzcmMgKz0gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2RkV2lkdGggJiYgb2RkSGVpZ2h0KSB7XG4gICAgICAgIG1hdHJpeFttYXRyaXgubGVuZ3RoIC0gMV0gPSBwYWNrZWRSR0JBW3BhY2tlZFJHQkEubGVuZ3RoIC0gNF07XG4gICAgfVxuICAgIHJldHVybiBtYXRyaXg7XG59XG5leHBvcnRzLmRlY29kZU1hdHJpeEZyb21QYWNrZWRSR0JBID0gZGVjb2RlTWF0cml4RnJvbVBhY2tlZFJHQkE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXhfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUZXh0dXJlTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGV4dHVyZU1hbmFnZXIoZ3BncHUpIHtcbiAgICAgICAgdGhpcy5ncGdwdSA9IGdwZ3B1O1xuICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcyA9IDA7XG4gICAgICAgIHRoaXMubnVtRnJlZVRleHR1cmVzID0gMDtcbiAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXMgPSB7fTtcbiAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXNlZFRleHR1cmVDb3VudCA9IHt9O1xuICAgIH1cbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuYWNxdWlyZVRleHR1cmUgPSBmdW5jdGlvbiAoc2hhcGVSQykge1xuICAgICAgICB2YXIgc2hhcGVLZXkgPSBnZXRLZXlGcm9tVGV4dHVyZVNoYXBlKHNoYXBlUkMpO1xuICAgICAgICBpZiAoIShzaGFwZUtleSBpbiB0aGlzLmZyZWVUZXh0dXJlcykpIHtcbiAgICAgICAgICAgIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHNoYXBlS2V5IGluIHRoaXMudXNlZFRleHR1cmVDb3VudCkpIHtcbiAgICAgICAgICAgIHRoaXMudXNlZFRleHR1cmVDb3VudFtzaGFwZUtleV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNlZFRleHR1cmVDb3VudFtzaGFwZUtleV0rKztcbiAgICAgICAgaWYgKHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm51bUZyZWVUZXh0dXJlcy0tO1xuICAgICAgICAgICAgdGhpcy5udW1Vc2VkVGV4dHVyZXMrKztcbiAgICAgICAgICAgIHRoaXMubG9nKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5udW1Vc2VkVGV4dHVyZXMrKztcbiAgICAgICAgdGhpcy5sb2coKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3BncHUuY3JlYXRlTWF0cml4VGV4dHVyZShzaGFwZVJDWzBdLCBzaGFwZVJDWzFdKTtcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5yZWxlYXNlVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBzaGFwZSkge1xuICAgICAgICB2YXIgc2hhcGVLZXkgPSBnZXRLZXlGcm9tVGV4dHVyZVNoYXBlKHNoYXBlKTtcbiAgICAgICAgaWYgKCEoc2hhcGVLZXkgaW4gdGhpcy5mcmVlVGV4dHVyZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0ucHVzaCh0ZXh0dXJlKTtcbiAgICAgICAgdGhpcy5udW1GcmVlVGV4dHVyZXMrKztcbiAgICAgICAgdGhpcy5udW1Vc2VkVGV4dHVyZXMtLTtcbiAgICAgICAgdGhpcy51c2VkVGV4dHVyZUNvdW50W3NoYXBlS2V5XS0tO1xuICAgICAgICB0aGlzLmxvZygpO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLm51bUZyZWVUZXh0dXJlcyArIHRoaXMubnVtVXNlZFRleHR1cmVzO1xuICAgICAgICBjb25zb2xlLmxvZygnRnJlZS9Vc2VkJywgdGhpcy5udW1GcmVlVGV4dHVyZXMgKyBcIiAvIFwiICsgdGhpcy5udW1Vc2VkVGV4dHVyZXMsIFwiKFwiICsgdG90YWwgKyBcIilcIik7XG4gICAgfTtcbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuZ2V0TnVtVXNlZFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1Vc2VkVGV4dHVyZXM7XG4gICAgfTtcbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuZ2V0TnVtRnJlZVRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1GcmVlVGV4dHVyZXM7XG4gICAgfTtcbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgc2hhcGUgaW4gdGhpcy5mcmVlVGV4dHVyZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyZWVUZXh0dXJlcy5oYXNPd25Qcm9wZXJ0eShzaGFwZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUodGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVdW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUZXh0dXJlTWFuYWdlcjtcbn0oKSk7XG5leHBvcnRzLlRleHR1cmVNYW5hZ2VyID0gVGV4dHVyZU1hbmFnZXI7XG5mdW5jdGlvbiBnZXRLZXlGcm9tVGV4dHVyZVNoYXBlKHNoYXBlUm93c0NvbCkge1xuICAgIHJldHVybiBzaGFwZVJvd3NDb2xbMF0gKyBcIl9cIiArIHNoYXBlUm93c0NvbFsxXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHR1cmVfbWFuYWdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzaGFkZXJfY29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL3NoYWRlcl9jb21waWxlclwiKTtcbnZhciBUaWxlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGlsZVByb2dyYW0oYVNoYXBlLCByZXBzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBuZXcgQXJyYXkoYVNoYXBlLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlW2ldID0gYVNoYXBlW2ldICogcmVwc1tpXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMucmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIGR0eXBlID0gc2hhZGVyX2NvbXBpbGVyXzEuZ2V0Q29vcmRzRGF0YVR5cGUodGhpcy5yYW5rKTtcbiAgICAgICAgdmFyIHNvdXJjZUNvb3JkcyA9IGdldFNvdXJjZUNvb3JkcyhhU2hhcGUpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRBKFwiICsgc291cmNlQ29vcmRzICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gVGlsZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5UaWxlUHJvZ3JhbSA9IFRpbGVQcm9ncmFtO1xuZnVuY3Rpb24gZ2V0U291cmNlQ29vcmRzKGFTaGFwZSkge1xuICAgIHZhciByYW5rID0gYVNoYXBlLmxlbmd0aDtcbiAgICBpZiAocmFuayA+IDQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUaWxlIGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJpbW9kKHJlc1JDLCBcIiArIGFTaGFwZVswXSArIFwiKVwiO1xuICAgIH1cbiAgICB2YXIgY3VycmVudENvb3JkcyA9IFsncmVzUkMueCcsICdyZXNSQy55JywgJ3Jlc1JDLnonLCAncmVzUkMudyddO1xuICAgIHZhciBzb3VyY2VDb29yZHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzb3VyY2VDb29yZHMucHVzaChcImltb2QoXCIgKyBjdXJyZW50Q29vcmRzW2ldICsgXCIsIFwiICsgYVNoYXBlW2ldICsgXCIpXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlQ29vcmRzLmpvaW4oKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbGVfZ3B1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIFRyYW5zcG9zZVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9zZVByb2dyYW0oYVNoYXBlLCBuZXdEaW0pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IG5ldyBBcnJheShhU2hhcGUubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGVbaV0gPSBhU2hhcGVbbmV3RGltW2ldXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMucmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIGR0eXBlID0gc2hhZGVyX2NvbXBpbGVyXzEuZ2V0Q29vcmRzRGF0YVR5cGUodGhpcy5yYW5rKTtcbiAgICAgICAgdmFyIHN3aXRjaGVkID0gZ2V0U3dpdGNoZWRDb29yZHMobmV3RGltKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBcIiArIGR0eXBlICsgXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBzZXRPdXRwdXQoZ2V0QShcIiArIHN3aXRjaGVkICsgXCIpKTtcXG4gICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFRyYW5zcG9zZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5UcmFuc3Bvc2VQcm9ncmFtID0gVHJhbnNwb3NlUHJvZ3JhbTtcbmZ1bmN0aW9uIGdldFN3aXRjaGVkQ29vcmRzKG5ld0RpbSkge1xuICAgIHZhciByYW5rID0gbmV3RGltLmxlbmd0aDtcbiAgICBpZiAocmFuayA+IDQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUcmFuc3Bvc2UgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIHZhciBvcmlnaW5hbE9yZGVyID0gWydyZXNSQy54JywgJ3Jlc1JDLnknLCAncmVzUkMueicsICdyZXNSQy53J107XG4gICAgdmFyIHN3aXRjaGVkQ29vcmRzID0gbmV3IEFycmF5KHJhbmspO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RGltLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaGVkQ29vcmRzW25ld0RpbVtpXV0gPSBvcmlnaW5hbE9yZGVyW2ldO1xuICAgIH1cbiAgICByZXR1cm4gc3dpdGNoZWRDb29yZHMuam9pbigpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNwb3NlX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBVbmFyeU9wUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5hcnlPcFByb2dyYW0oYVNoYXBlLCBvcFNuaXBwZXQpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBhU2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGZsb2F0IHVuYXJ5T3BlcmF0aW9uKGZsb2F0IHgpIHtcXG4gICAgICAgIFwiICsgb3BTbmlwcGV0ICsgXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgeCA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgeSA9IHVuYXJ5T3BlcmF0aW9uKHgpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KHkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBVbmFyeU9wUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlVuYXJ5T3BQcm9ncmFtID0gVW5hcnlPcFByb2dyYW07XG5leHBvcnRzLkNIRUNLX05BTl9TTklQUEVUID0gXCJcXG4gIGlmIChpc05hTih4KSkge1xcbiAgICByZXR1cm4geDtcXG4gIH1cXG5cIjtcbmV4cG9ydHMuQUJTID0gXCJcXG4gIHJldHVybiBhYnMoeCk7XFxuXCI7XG5leHBvcnRzLlJFTFUgPSBcIlxcbiAgcmV0dXJuICh4IDwgMC4wKSA/IDAuMCA6IHg7XFxuXCI7XG5leHBvcnRzLkVMVSA9IFwiXFxuICByZXR1cm4gKHggPj0gMC4wKSA/IHggOiAoZXhwKHgpIC0gMS4wKTtcXG5cIjtcbmZ1bmN0aW9uIExFQUtZX1JFTFUoYWxwaGEpIHtcbiAgICByZXR1cm4gXCJcXG4gICAgcmV0dXJuICh4ID49IDAuMCkgPyB4IDogXCIgKyBhbHBoYSArIFwiICogeDtcXG4gIFwiO1xufVxuZXhwb3J0cy5MRUFLWV9SRUxVID0gTEVBS1lfUkVMVTtcbmZ1bmN0aW9uIFNURVAoYWxwaGEpIHtcbiAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDAuMDsgfVxuICAgIHJldHVybiBcIlxcbiAgICByZXR1cm4gKHggPT0geCkgPyAoeCA+IDAuMCA/IDEuMCA6IGZsb2F0KFwiICsgYWxwaGEgKyBcIikpIDogeDtcXG4gIFwiO1xufVxuZXhwb3J0cy5TVEVQID0gU1RFUDtcbmV4cG9ydHMuTkVHID0gXCJcXG4gIHJldHVybiAteDtcXG5cIjtcbmV4cG9ydHMuQ0VJTCA9IFwiXFxuICByZXR1cm4gY2VpbCh4KTtcXG5cIjtcbmV4cG9ydHMuRkxPT1IgPSBcIlxcbiAgcmV0dXJuIGZsb29yKHgpO1xcblwiO1xuZXhwb3J0cy5FWFAgPSBcIlxcbiAgcmV0dXJuIGV4cCh4KTtcXG5cIjtcbmV4cG9ydHMuTE9HID0gXCJcXG4gIHJldHVybiBsb2coeCk7XFxuXCI7XG5leHBvcnRzLlNRUlQgPSBleHBvcnRzLkNIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBzcXJ0KHgpO1xcblwiO1xuZXhwb3J0cy5TSUdNT0lEID0gXCJcXG4gIHJldHVybiAxLjAgLyAoMS4wICsgZXhwKC0xLjAgKiB4KSk7XFxuXCI7XG5leHBvcnRzLlNJTiA9IGV4cG9ydHMuQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIHNpbih4KTtcXG5cIjtcbmV4cG9ydHMuQ09TID0gZXhwb3J0cy5DSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gY29zKHgpO1xcblwiO1xuZXhwb3J0cy5UQU4gPSBcIlxcbiAgcmV0dXJuIHRhbih4KTtcXG5cIjtcbmV4cG9ydHMuQVNJTiA9IGV4cG9ydHMuQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGFzaW4oeCk7XFxuXCI7XG5leHBvcnRzLkFDT1MgPSBleHBvcnRzLkNIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBhY29zKHgpO1xcblwiO1xuZXhwb3J0cy5BVEFOID0gZXhwb3J0cy5DSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gYXRhbih4KTtcXG5cIjtcbmV4cG9ydHMuU0lOSCA9IFwiXFxuICBmbG9hdCBlMnggPSBleHAoeCk7XFxuICByZXR1cm4gKGUyeCAtIDEuMCAvIGUyeCkgLyAyLjA7XFxuXCI7XG5leHBvcnRzLkNPU0ggPSBcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKC14KTtcXG4gIHJldHVybiAoZTJ4ICsgMS4wIC8gZTJ4KSAvIDIuMDtcXG5cIjtcbmV4cG9ydHMuVEFOSCA9IFwiXFxuICBmbG9hdCBlMnggPSBleHAoLTIuMCAqIGFicyh4KSk7XFxuICByZXR1cm4gc2lnbih4KSAqICgxLjAgLSBlMngpIC8gKDEuMCArIGUyeCk7XFxuXCI7XG5leHBvcnRzLlNRVUFSRSA9IFwiXFxuICByZXR1cm4geCAqIHg7XFxuXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmFyeW9wX2dwdS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNQVhfVEVYVFVSRV9TSVpFID0gbnVsbDtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dChhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgcmV0dXJuIGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMoY2FudmFzLCBhdHRyaWJ1dGVzKTtcbn1cbmV4cG9ydHMuY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0ID0gY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuZnVuY3Rpb24gY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0RnJvbUNhbnZhcyhjYW52YXMsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgZ2w7XG4gICAgdmFyIHdlYmdsVmVyc2lvbiA9IGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpO1xuICAgIGlmICh3ZWJnbFZlcnNpb24gPT09IDIpIHtcbiAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdlYmdsVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICBnbCA9IChjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBhdHRyaWJ1dGVzKSB8fFxuICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgaWYgKHdlYmdsVmVyc2lvbiA9PT0gMCB8fCBnbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViR0wuJyk7XG4gICAgfVxuICAgIHJldHVybiBnbDtcbn1cbmV4cG9ydHMuY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0RnJvbUNhbnZhcyA9IGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXM7XG5mdW5jdGlvbiBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmMpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBmdW5jKCk7XG4gICAgY2hlY2tXZWJHTEVycm9yKGdsKTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5leHBvcnRzLmNhbGxBbmRDaGVjayA9IGNhbGxBbmRDaGVjaztcbnZhciB3ZWJHTERlYnVnRXJyb3JDaGVja2luZ0VuYWJsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGVuYWJsZURlYnVnV2ViR0xFcnJvckNoZWNraW5nKGVuYWJsZWQpIHtcbiAgICB3ZWJHTERlYnVnRXJyb3JDaGVja2luZ0VuYWJsZWQgPSBlbmFibGVkO1xufVxuZXhwb3J0cy5lbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZyA9IGVuYWJsZURlYnVnV2ViR0xFcnJvckNoZWNraW5nO1xuZnVuY3Rpb24gY2hlY2tXZWJHTEVycm9yKGdsKSB7XG4gICAgaWYgKHdlYkdMRGVidWdFcnJvckNoZWNraW5nRW5hYmxlZCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBnbC5nZXRFcnJvcigpO1xuICAgICAgICBpZiAoZXJyb3IgIT09IGdsLk5PX0VSUk9SKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMIEVycm9yOiAnICsgZ2V0V2ViR0xFcnJvck1lc3NhZ2UoZ2wsIGVycm9yKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNoZWNrV2ViR0xFcnJvciA9IGNoZWNrV2ViR0xFcnJvcjtcbmZ1bmN0aW9uIGdldFdlYkdMRXJyb3JNZXNzYWdlKGdsLCBzdGF0dXMpIHtcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICBjYXNlIGdsLk5PX0VSUk9SOlxuICAgICAgICAgICAgcmV0dXJuICdOT19FUlJPUic7XG4gICAgICAgIGNhc2UgZ2wuSU5WQUxJRF9FTlVNOlxuICAgICAgICAgICAgcmV0dXJuICdJTlZBTElEX0VOVU0nO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfVkFMVUU6XG4gICAgICAgICAgICByZXR1cm4gJ0lOVkFMSURfVkFMVUUnO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfT1BFUkFUSU9OOlxuICAgICAgICAgICAgcmV0dXJuICdJTlZBTElEX09QRVJBVElPTic7XG4gICAgICAgIGNhc2UgZ2wuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046XG4gICAgICAgICAgICByZXR1cm4gJ0lOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OJztcbiAgICAgICAgY2FzZSBnbC5PVVRfT0ZfTUVNT1JZOlxuICAgICAgICAgICAgcmV0dXJuICdPVVRfT0ZfTUVNT1JZJztcbiAgICAgICAgY2FzZSBnbC5DT05URVhUX0xPU1RfV0VCR0w6XG4gICAgICAgICAgICByZXR1cm4gJ0NPTlRFWFRfTE9TVF9XRUJHTCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJVbmtub3duIGVycm9yIGNvZGUgXCIgKyBzdGF0dXM7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRXZWJHTEVycm9yTWVzc2FnZSA9IGdldFdlYkdMRXJyb3JNZXNzYWdlO1xuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uT3JUaHJvdyhnbCwgZXh0ZW5zaW9uTmFtZSkge1xuICAgIHJldHVybiB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZ2V0RXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUpOyB9LCAnRXh0ZW5zaW9uIFwiJyArIGV4dGVuc2lvbk5hbWUgKyAnXCIgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuJyk7XG59XG5leHBvcnRzLmdldEV4dGVuc2lvbk9yVGhyb3cgPSBnZXRFeHRlbnNpb25PclRocm93O1xuZnVuY3Rpb24gY3JlYXRlVmVydGV4U2hhZGVyKGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpIHtcbiAgICB2YXIgdmVydGV4U2hhZGVyID0gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgdmVydGV4IFdlYkdMU2hhZGVyLicpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuc2hhZGVyU291cmNlKHZlcnRleFNoYWRlciwgdmVydGV4U2hhZGVyU291cmNlKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7IH0pO1xuICAgIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydGV4U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGdsLmdldFNoYWRlckluZm9Mb2codmVydGV4U2hhZGVyKSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbXBpbGUgdmVydGV4IHNoYWRlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbn1cbmV4cG9ydHMuY3JlYXRlVmVydGV4U2hhZGVyID0gY3JlYXRlVmVydGV4U2hhZGVyO1xuZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRTaGFkZXIoZ2wsIGZyYWdtZW50U2hhZGVyU291cmNlKSB7XG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBmcmFnbWVudCBXZWJHTFNoYWRlci4nKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnNoYWRlclNvdXJjZShmcmFnbWVudFNoYWRlciwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpOyB9KTtcbiAgICBpZiAoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdtZW50U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykgPT09IGZhbHNlKSB7XG4gICAgICAgIGxvZ1NoYWRlclNvdXJjZUFuZEluZm9Mb2coZnJhZ21lbnRTaGFkZXJTb3VyY2UsIGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29tcGlsZSBmcmFnbWVudCBzaGFkZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbn1cbmV4cG9ydHMuY3JlYXRlRnJhZ21lbnRTaGFkZXIgPSBjcmVhdGVGcmFnbWVudFNoYWRlcjtcbnZhciBsaW5lTnVtYmVyUmVnZXggPSAvRVJST1I6IFswLTldKzooWzAtOV0rKTovZztcbmZ1bmN0aW9uIGxvZ1NoYWRlclNvdXJjZUFuZEluZm9Mb2coc2hhZGVyU291cmNlLCBzaGFkZXJJbmZvTG9nKSB7XG4gICAgdmFyIGxpbmVOdW1iZXJSZWdleFJlc3VsdCA9IGxpbmVOdW1iZXJSZWdleC5leGVjKHNoYWRlckluZm9Mb2cpO1xuICAgIGlmIChsaW5lTnVtYmVyUmVnZXhSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNvdWxkbid0IHBhcnNlIGxpbmUgbnVtYmVyIGluIGVycm9yOiBcIiArIHNoYWRlckluZm9Mb2cpO1xuICAgICAgICBjb25zb2xlLmxvZyhzaGFkZXJTb3VyY2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsaW5lTnVtYmVyID0gK2xpbmVOdW1iZXJSZWdleFJlc3VsdFsxXTtcbiAgICB2YXIgc2hhZGVyTGluZXMgPSBzaGFkZXJTb3VyY2Uuc3BsaXQoJ1xcbicpO1xuICAgIHZhciBwYWQgPSBzaGFkZXJMaW5lcy5sZW5ndGgudG9TdHJpbmcoKS5sZW5ndGggKyAyO1xuICAgIHZhciBsaW5lc1dpdGhMaW5lTnVtYmVycyA9IHNoYWRlckxpbmVzLm1hcChmdW5jdGlvbiAobGluZSwgbGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gdXRpbC5yaWdodFBhZCgobGluZU51bWJlciArIDEpLnRvU3RyaW5nKCksIHBhZCkgKyBsaW5lO1xuICAgIH0pO1xuICAgIHZhciBtYXhMaW5lTGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzV2l0aExpbmVOdW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1heExpbmVMZW5ndGggPSBNYXRoLm1heChsaW5lc1dpdGhMaW5lTnVtYmVyc1tpXS5sZW5ndGgsIG1heExpbmVMZW5ndGgpO1xuICAgIH1cbiAgICB2YXIgYmVmb3JlRXJyb3JMaW5lcyA9IGxpbmVzV2l0aExpbmVOdW1iZXJzLnNsaWNlKDAsIGxpbmVOdW1iZXIgLSAxKTtcbiAgICB2YXIgZXJyb3JMaW5lID0gbGluZXNXaXRoTGluZU51bWJlcnMuc2xpY2UobGluZU51bWJlciAtIDEsIGxpbmVOdW1iZXIpO1xuICAgIHZhciBhZnRlckVycm9yTGluZXMgPSBsaW5lc1dpdGhMaW5lTnVtYmVycy5zbGljZShsaW5lTnVtYmVyKTtcbiAgICBjb25zb2xlLmxvZyhiZWZvcmVFcnJvckxpbmVzLmpvaW4oJ1xcbicpKTtcbiAgICBjb25zb2xlLmxvZyhzaGFkZXJJbmZvTG9nLnNwbGl0KCdcXG4nKVswXSk7XG4gICAgY29uc29sZS5sb2coXCIlYyBcIiArIHV0aWwucmlnaHRQYWQoZXJyb3JMaW5lWzBdLCBtYXhMaW5lTGVuZ3RoKSwgJ2JvcmRlcjoxcHggc29saWQgcmVkOyBiYWNrZ3JvdW5kLWNvbG9yOiNlM2QyZDI7IGNvbG9yOiNhNjE3MTcnKTtcbiAgICBjb25zb2xlLmxvZyhhZnRlckVycm9yTGluZXMuam9pbignXFxuJykpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShnbCkge1xuICAgIHJldHVybiB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlUHJvZ3JhbSgpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFByb2dyYW0uJyk7XG59XG5leHBvcnRzLmNyZWF0ZVByb2dyYW0gPSBjcmVhdGVQcm9ncmFtO1xuZnVuY3Rpb24gbGlua1Byb2dyYW0oZ2wsIHByb2dyYW0pIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pOyB9KTtcbiAgICBpZiAoZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbGluayB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMuJyk7XG4gICAgfVxufVxuZXhwb3J0cy5saW5rUHJvZ3JhbSA9IGxpbmtQcm9ncmFtO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9ncmFtKGdsLCBwcm9ncmFtKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC52YWxpZGF0ZVByb2dyYW0ocHJvZ3JhbSk7IH0pO1xuICAgIGlmIChnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUykgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkZXIgcHJvZ3JhbSB2YWxpZGF0aW9uIGZhaWxlZC4nKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlUHJvZ3JhbSA9IHZhbGlkYXRlUHJvZ3JhbTtcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcihnbCwgZGF0YSkge1xuICAgIHZhciBidWZmZXIgPSB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlQnVmZmVyKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMQnVmZmVyJyk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpOyB9KTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5jcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXIgPSBjcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXI7XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNJbmRleEJ1ZmZlcihnbCwgZGF0YSkge1xuICAgIHZhciBidWZmZXIgPSB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlQnVmZmVyKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMQnVmZmVyJyk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTsgfSk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMuY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIgPSBjcmVhdGVTdGF0aWNJbmRleEJ1ZmZlcjtcbmZ1bmN0aW9uIHF1ZXJ5TWF4VGV4dHVyZVNpemUoZ2wpIHtcbiAgICBpZiAoTUFYX1RFWFRVUkVfU0laRSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBNQVhfVEVYVFVSRV9TSVpFO1xuICAgIH1cbiAgICBNQVhfVEVYVFVSRV9TSVpFID1cbiAgICAgICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSk7IH0pO1xuICAgIHJldHVybiBNQVhfVEVYVFVSRV9TSVpFO1xufVxuZXhwb3J0cy5xdWVyeU1heFRleHR1cmVTaXplID0gcXVlcnlNYXhUZXh0dXJlU2l6ZTtcbmZ1bmN0aW9uIGdldENoYW5uZWxzUGVyVGV4dHVyZSgpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDQ7XG59XG5leHBvcnRzLmdldENoYW5uZWxzUGVyVGV4dHVyZSA9IGdldENoYW5uZWxzUGVyVGV4dHVyZTtcbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUoZ2wpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZVRleHR1cmUoKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xUZXh0dXJlLicpO1xufVxuZXhwb3J0cy5jcmVhdGVUZXh0dXJlID0gY3JlYXRlVGV4dHVyZTtcbmZ1bmN0aW9uIHZhbGlkYXRlVGV4dHVyZVNpemUoZ2wsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgbWF4VGV4dHVyZVNpemUgPSBxdWVyeU1heFRleHR1cmVTaXplKGdsKTtcbiAgICBpZiAoKHdpZHRoIDw9IDApIHx8IChoZWlnaHQgPD0gMCkpIHtcbiAgICAgICAgdmFyIHJlcXVlc3RlZCA9IFwiW1wiICsgd2lkdGggKyBcInhcIiArIGhlaWdodCArIFwiXVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3RlZCB0ZXh0dXJlIHNpemUgJyArIHJlcXVlc3RlZCArICcgaXMgaW52YWxpZC4nKTtcbiAgICB9XG4gICAgaWYgKCh3aWR0aCA+IG1heFRleHR1cmVTaXplKSB8fCAoaGVpZ2h0ID4gbWF4VGV4dHVyZVNpemUpKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ZWQgPSBcIltcIiArIHdpZHRoICsgXCJ4XCIgKyBoZWlnaHQgKyBcIl1cIjtcbiAgICAgICAgdmFyIG1heCA9IFwiW1wiICsgbWF4VGV4dHVyZVNpemUgKyBcInhcIiArIG1heFRleHR1cmVTaXplICsgXCJdXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSAnICsgcmVxdWVzdGVkICtcbiAgICAgICAgICAgICcgZ3JlYXRlciB0aGFuIFdlYkdMIG1heGltdW0gb24gdGhpcyBicm93c2VyIC8gR1BVICcgKyBtYXggKyAnLicpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUZXh0dXJlU2l6ZSA9IHZhbGlkYXRlVGV4dHVyZVNpemU7XG5mdW5jdGlvbiBjcmVhdGVGcmFtZWJ1ZmZlcihnbCkge1xuICAgIHJldHVybiB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xGcmFtZWJ1ZmZlci4nKTtcbn1cbmV4cG9ydHMuY3JlYXRlRnJhbWVidWZmZXIgPSBjcmVhdGVGcmFtZWJ1ZmZlcjtcbmZ1bmN0aW9uIGJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUoZ2wsIHByb2dyYW0sIGF0dHJpYnV0ZSwgYnVmZmVyLCBhcnJheUVudHJpZXNQZXJJdGVtLCBpdGVtU3RyaWRlSW5CeXRlcywgaXRlbU9mZnNldEluQnl0ZXMsIGF0dHJpYkxvY2F0aW9ucykge1xuICAgIHZhciBsb2MgPSAtMTtcbiAgICBpZiAoKGF0dHJpYkxvY2F0aW9ucyAhPSBudWxsKSAmJiAoYXR0cmlidXRlIGluIGF0dHJpYkxvY2F0aW9ucykpIHtcbiAgICAgICAgbG9jID0gYXR0cmliTG9jYXRpb25zW2F0dHJpYnV0ZV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2MgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJ1dGUpO1xuICAgIH1cbiAgICBpZiAobG9jID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudmVydGV4QXR0cmliUG9pbnRlcihsb2MsIGFycmF5RW50cmllc1Blckl0ZW0sIGdsLkZMT0FULCBmYWxzZSwgaXRlbVN0cmlkZUluQnl0ZXMsIGl0ZW1PZmZzZXRJbkJ5dGVzKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2MpOyB9KTtcbn1cbmV4cG9ydHMuYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZSA9IGJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGU7XG5mdW5jdGlvbiBiaW5kVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmUsIHRleHR1cmVVbml0KSB7XG4gICAgdmFsaWRhdGVUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTsgfSk7XG59XG5leHBvcnRzLmJpbmRUZXh0dXJlVW5pdCA9IGJpbmRUZXh0dXJlVW5pdDtcbmZ1bmN0aW9uIHVuYmluZFRleHR1cmVVbml0KGdsLCB0ZXh0dXJlVW5pdCkge1xuICAgIHZhbGlkYXRlVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmVVbml0KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xufVxuZXhwb3J0cy51bmJpbmRUZXh0dXJlVW5pdCA9IHVuYmluZFRleHR1cmVVbml0O1xuZnVuY3Rpb24gZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3coZ2wsIHByb2dyYW0sIHVuaWZvcm1OYW1lKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdW5pZm9ybU5hbWUpOyB9LCAndW5pZm9ybSBcIicgKyB1bmlmb3JtTmFtZSArICdcIiBub3QgcHJlc2VudCBpbiBwcm9ncmFtLicpO1xufVxuZXhwb3J0cy5nZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdyA9IGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93O1xuZnVuY3Rpb24gYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcihnbCwgcHJvZ3JhbSwgdGV4dHVyZSwgdW5pZm9ybVNhbXBsZXJMb2NhdGlvbiwgdGV4dHVyZVVuaXQpIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpbmRUZXh0dXJlVW5pdChnbCwgdGV4dHVyZSwgdGV4dHVyZVVuaXQpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnVuaWZvcm0xaSh1bmlmb3JtU2FtcGxlckxvY2F0aW9uLCB0ZXh0dXJlVW5pdCk7IH0pO1xufVxuZXhwb3J0cy5iaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyID0gYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcjtcbmZ1bmN0aW9uIGJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyKGdsKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuc2Npc3NvcigwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpOyB9KTtcbn1cbmV4cG9ydHMuYmluZENhbnZhc1RvRnJhbWVidWZmZXIgPSBiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcjtcbmZ1bmN0aW9uIGJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKGdsLCB0ZXh0dXJlLCBmcmFtZWJ1ZmZlcikge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTsgfSk7XG59XG5leHBvcnRzLmJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyID0gYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXI7XG5mdW5jdGlvbiB1bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIoZ2wsIGZyYW1lYnVmZmVyKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIG51bGwsIDApOyB9KTtcbn1cbmV4cG9ydHMudW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyID0gdW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyO1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFtZWJ1ZmZlcihnbCkge1xuICAgIHZhciBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcbiAgICBpZiAoc3RhdHVzICE9PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGJpbmRpbmcgZnJhbWVidWZmZXI6ICcgKyBnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZShnbCwgc3RhdHVzKSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUZyYW1lYnVmZmVyID0gdmFsaWRhdGVGcmFtZWJ1ZmZlcjtcbmZ1bmN0aW9uIGdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlKGdsLCBzdGF0dXMpIHtcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UJztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQnO1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzpcbiAgICAgICAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TJztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpcbiAgICAgICAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwidW5rbm93biBlcnJvciBcIiArIHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLmdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlID0gZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2U7XG5mdW5jdGlvbiB0aHJvd0lmTnVsbChnbCwgcmV0dXJuVE9yTnVsbCwgZmFpbHVyZU1lc3NhZ2UpIHtcbiAgICB2YXIgdE9yTnVsbCA9IGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmV0dXJuVE9yTnVsbCgpOyB9KTtcbiAgICBpZiAodE9yTnVsbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmYWlsdXJlTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB0T3JOdWxsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpIHtcbiAgICB2YXIgbWF4VGV4dHVyZVVuaXQgPSBnbC5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyAtIDE7XG4gICAgdmFyIGdsVGV4dHVyZVVuaXQgPSB0ZXh0dXJlVW5pdCArIGdsLlRFWFRVUkUwO1xuICAgIGlmIChnbFRleHR1cmVVbml0IDwgZ2wuVEVYVFVSRTAgfHwgZ2xUZXh0dXJlVW5pdCA+IG1heFRleHR1cmVVbml0KSB7XG4gICAgICAgIHZhciB0ZXh0dXJlVW5pdFJhbmdlID0gXCJbZ2wuVEVYVFVSRTAsIGdsLlRFWFRVUkVcIiArIG1heFRleHR1cmVVbml0ICsgXCJdXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRleHR1cmVVbml0IG11c3QgYmUgaW4gXCIgKyB0ZXh0dXJlVW5pdFJhbmdlICsgXCIuXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUoZ2wsIGxvZ1NoYXBlKSB7XG4gICAgaWYgKGxvZ1NoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB2YXIgc3F1ZWV6ZVJlc3VsdCA9IHV0aWwuc3F1ZWV6ZVNoYXBlKGxvZ1NoYXBlKTtcbiAgICAgICAgbG9nU2hhcGUgPSBzcXVlZXplUmVzdWx0Lm5ld1NoYXBlO1xuICAgIH1cbiAgICB2YXIgbWF4VGV4U2l6ZSA9IHF1ZXJ5TWF4VGV4dHVyZVNpemUoZ2wpO1xuICAgIHZhciBzaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKGxvZ1NoYXBlKTtcbiAgICBpZiAobG9nU2hhcGUubGVuZ3RoIDw9IDEgJiYgc2l6ZSA8PSBtYXhUZXhTaXplKSB7XG4gICAgICAgIHJldHVybiBbc2l6ZSwgMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gMiAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXhTaXplICYmXG4gICAgICAgIGxvZ1NoYXBlWzFdIDw9IG1heFRleFNpemUpIHtcbiAgICAgICAgcmV0dXJuIGxvZ1NoYXBlO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDMgJiYgbG9nU2hhcGVbMF0gPD0gbWF4VGV4U2l6ZSAmJlxuICAgICAgICBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdIDw9IG1heFRleFNpemUpIHtcbiAgICAgICAgcmV0dXJuIFtsb2dTaGFwZVswXSwgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gNCAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXhTaXplICYmXG4gICAgICAgIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gKiBsb2dTaGFwZVszXSA8PSBtYXhUZXhTaXplKSB7XG4gICAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0sIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gKiBsb2dTaGFwZVszXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdXRpbC5zaXplVG9TcXVhcmlzaFNoYXBlKHNpemUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZSA9IGdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJnbF91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xudmFyIG1hdGhfY3B1XzEgPSByZXF1aXJlKFwiLi9tYXRoL21hdGhfY3B1XCIpO1xudmFyIG1hdGhfZ3B1XzEgPSByZXF1aXJlKFwiLi9tYXRoL21hdGhfZ3B1XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZXhwb3J0cy5URVNUX0VQU0lMT04gPSAxZS0yO1xuZnVuY3Rpb24gbWVhbih2YWx1ZXMpIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdW0gKz0gdmFsdWVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gc3VtIC8gdmFsdWVzLmxlbmd0aDtcbn1cbmV4cG9ydHMubWVhbiA9IG1lYW47XG5mdW5jdGlvbiBzdGFuZGFyZERldmlhdGlvbih2YWx1ZXMsIG1lYW4pIHtcbiAgICB2YXIgc3F1YXJlRGlmZlN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRpZmYgPSB2YWx1ZXNbaV0gLSBtZWFuO1xuICAgICAgICBzcXVhcmVEaWZmU3VtICs9IGRpZmYgKiBkaWZmO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHNxdWFyZURpZmZTdW0gLyB2YWx1ZXMubGVuZ3RoKTtcbn1cbmV4cG9ydHMuc3RhbmRhcmREZXZpYXRpb24gPSBzdGFuZGFyZERldmlhdGlvbjtcbmZ1bmN0aW9uIGt1cnRvc2lzKHZhbHVlcykge1xuICAgIHZhciB2YWx1ZXNNZWFuID0gbWVhbih2YWx1ZXMpO1xuICAgIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgc3VtMiA9IDA7XG4gICAgdmFyIHN1bTQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciB2ID0gdmFsdWVzW2ldIC0gdmFsdWVzTWVhbjtcbiAgICAgICAgc3VtMiArPSBNYXRoLnBvdyh2LCAyKTtcbiAgICAgICAgc3VtNCArPSBNYXRoLnBvdyh2LCA0KTtcbiAgICB9XG4gICAgcmV0dXJuICgxIC8gbikgKiBzdW00IC8gTWF0aC5wb3coKDEgLyBuKSAqIHN1bTIsIDIpIC0gMztcbn1cbmV4cG9ydHMua3VydG9zaXMgPSBrdXJ0b3NpcztcbmZ1bmN0aW9uIHNrZXduZXNzKHZhbHVlcykge1xuICAgIHZhciB2YWx1ZXNNZWFuID0gbWVhbih2YWx1ZXMpO1xuICAgIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgc3VtMiA9IDA7XG4gICAgdmFyIHN1bTMgPSAwO1xuICAgIHZhciBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgdmFyIHYgPSB2YWx1ZXNbaV0gLSB2YWx1ZXNNZWFuO1xuICAgICAgICBzdW0yICs9IE1hdGgucG93KHYsIDIpO1xuICAgICAgICBzdW0zICs9IE1hdGgucG93KHYsIDMpO1xuICAgIH1cbiAgICByZXR1cm4gKDEgLyBuKSAqIHN1bTMgLyBNYXRoLnBvdygoMSAvIChuIC0gMSkpICogc3VtMiwgMyAvIDIpO1xufVxuZXhwb3J0cy5za2V3bmVzcyA9IHNrZXduZXNzO1xuZnVuY3Rpb24gamFycXVlQmVyYU5vcm1hbGl0eVRlc3QodmFsdWVzKSB7XG4gICAgdmFyIHMgPSBza2V3bmVzcyh2YWx1ZXMpO1xuICAgIHZhciBrID0ga3VydG9zaXModmFsdWVzKTtcbiAgICB2YXIgamIgPSB2YWx1ZXMubGVuZ3RoICogKChNYXRoLnBvdyhzLCAyKSAvIDYpICsgKE1hdGgucG93KGssIDIpIC8gMjQpKTtcbiAgICB2YXIgQ0hJX1NRVUFSRV8yREVHID0gNS45OTE7XG4gICAgaWYgKGpiID4gQ0hJX1NRVUFSRV8yREVHKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcC12YWx1ZSBmb3IgSkI6IFwiICsgamIpO1xuICAgIH1cbn1cbmV4cG9ydHMuamFycXVlQmVyYU5vcm1hbGl0eVRlc3QgPSBqYXJxdWVCZXJhTm9ybWFsaXR5VGVzdDtcbmZ1bmN0aW9uIGV4cGVjdEFycmF5SW5NZWFuU3RkUmFuZ2UoYWN0dWFsLCBleHBlY3RlZE1lYW4sIGV4cGVjdGVkU3RkRGV2LCBlcHNpbG9uKSB7XG4gICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gZXhwb3J0cy5URVNUX0VQU0lMT047IH1cbiAgICB2YXIgYWN0dWFsTWVhbiA9IG1lYW4oYWN0dWFsKTtcbiAgICBleHBlY3ROdW1iZXJzQ2xvc2UoYWN0dWFsTWVhbiwgZXhwZWN0ZWRNZWFuLCBlcHNpbG9uKTtcbiAgICBleHBlY3ROdW1iZXJzQ2xvc2Uoc3RhbmRhcmREZXZpYXRpb24oYWN0dWFsLCBhY3R1YWxNZWFuKSwgZXhwZWN0ZWRTdGREZXYsIGVwc2lsb24pO1xufVxuZXhwb3J0cy5leHBlY3RBcnJheUluTWVhblN0ZFJhbmdlID0gZXhwZWN0QXJyYXlJbk1lYW5TdGRSYW5nZTtcbmZ1bmN0aW9uIGV4cGVjdEFycmF5c0Nsb3NlKGFjdHVhbCwgZXhwZWN0ZWQsIGVwc2lsb24pIHtcbiAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSBleHBvcnRzLlRFU1RfRVBTSUxPTjsgfVxuICAgIHZhciBhVHlwZSA9IGFjdHVhbC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHZhciBiVHlwZSA9IGV4cGVjdGVkLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKGFUeXBlICE9PSBiVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgYXJlIG9mIGRpZmZlcmVudCB0eXBlIFwiICsgYVR5cGUgKyBcIiB2cyBcIiArIGJUeXBlKTtcbiAgICB9XG4gICAgaWYgKGFjdHVhbC5sZW5ndGggIT09IGV4cGVjdGVkLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYXRyaWNlcyBoYXZlIGRpZmZlcmVudCBsZW5ndGhzIChcIiArIGFjdHVhbC5sZW5ndGggKyBcIiB2cyBcIiArXG4gICAgICAgICAgICAoZXhwZWN0ZWQubGVuZ3RoICsgXCIpLlwiKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGEgPSBhY3R1YWxbaV07XG4gICAgICAgIHZhciBlID0gZXhwZWN0ZWRbaV07XG4gICAgICAgIGlmICghYXJlQ2xvc2UoYSwgZSwgZXBzaWxvbikpIHtcbiAgICAgICAgICAgIHZhciBhY3R1YWxTdHIgPSBcImFjdHVhbFtcIiArIGkgKyBcIl0gPT09IFwiICsgYTtcbiAgICAgICAgICAgIHZhciBleHBlY3RlZFN0ciA9IFwiZXhwZWN0ZWRbXCIgKyBpICsgXCJdID09PSBcIiArIGU7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5cyBkaWZmZXI6ICcgKyBhY3R1YWxTdHIgKyAnLCAnICsgZXhwZWN0ZWRTdHIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5leHBlY3RBcnJheXNDbG9zZSA9IGV4cGVjdEFycmF5c0Nsb3NlO1xuZnVuY3Rpb24gZXhwZWN0TnVtYmVyc0Nsb3NlKGEsIGUsIGVwc2lsb24pIHtcbiAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSBleHBvcnRzLlRFU1RfRVBTSUxPTjsgfVxuICAgIGlmICghYXJlQ2xvc2UoYSwgZSwgZXBzaWxvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVycyBkaWZmZXI6IGFjdHVhbCA9PT0gXCIgKyBhICsgXCIsIGV4cGVjdGVkID09PSBcIiArIGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZXhwZWN0TnVtYmVyc0Nsb3NlID0gZXhwZWN0TnVtYmVyc0Nsb3NlO1xuZnVuY3Rpb24gYXJlQ2xvc2UoYSwgZSwgZXBzaWxvbikge1xuICAgIGlmIChpc05hTihhKSAmJiBpc05hTihlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKGEpIHx8IGlzTmFOKGUpIHx8IE1hdGguYWJzKGEgLSBlKSA+IGVwc2lsb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGV4cGVjdFZhbHVlc0luUmFuZ2UoYWN0dWFsLCBsb3csIGhpZ2gpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYWN0dWFsW2ldIDwgbG93IHx8IGFjdHVhbFtpXSA+IGhpZ2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIG91dCBvZiByYW5nZTpcIiArIGFjdHVhbFtpXSArIFwiIGxvdzogXCIgKyBsb3cgKyBcIiwgaGlnaDogXCIgKyBoaWdoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZXhwZWN0VmFsdWVzSW5SYW5nZSA9IGV4cGVjdFZhbHVlc0luUmFuZ2U7XG5mdW5jdGlvbiByYW5kb21BcnJheUluUmFuZ2UobiwgbWluVmFsdWUsIG1heFZhbHVlKSB7XG4gICAgdmFyIHYgPSBuZXcgRmxvYXQzMkFycmF5KG4pO1xuICAgIHZhciByYW5nZSA9IG1heFZhbHVlIC0gbWluVmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdltpXSA9IChNYXRoLnJhbmRvbSgpICogcmFuZ2UpICsgbWluVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuZXhwb3J0cy5yYW5kb21BcnJheUluUmFuZ2UgPSByYW5kb21BcnJheUluUmFuZ2U7XG5mdW5jdGlvbiBtYWtlSWRlbnRpdHkobikge1xuICAgIHZhciBpID0gbmV3IEZsb2F0MzJBcnJheShuICogbik7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgaVsoaiAqIG4pICsgal0gPSAxO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbn1cbmV4cG9ydHMubWFrZUlkZW50aXR5ID0gbWFrZUlkZW50aXR5O1xuZnVuY3Rpb24gY3B1TXVsdGlwbHlNYXRyaXgoYSwgYVJvdywgYUNvbCwgYiwgYlJvdywgYkNvbCkge1xuICAgIHZhciByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGFSb3cgKiBiQ29sKTtcbiAgICBmb3IgKHZhciByID0gMDsgciA8IGFSb3c7ICsrcikge1xuICAgICAgICB2YXIgYU9mZnNldCA9IChyICogYUNvbCk7XG4gICAgICAgIHZhciBjT2Zmc2V0ID0gKHIgKiBiQ29sKTtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBiQ29sOyArK2MpIHtcbiAgICAgICAgICAgIHZhciBkID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYUNvbDsgKytrKSB7XG4gICAgICAgICAgICAgICAgZCArPSBhW2FPZmZzZXQgKyBrXSAqIGJbKGsgKiBiQ29sKSArIGNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2NPZmZzZXQgKyBjXSA9IGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY3B1TXVsdGlwbHlNYXRyaXggPSBjcHVNdWx0aXBseU1hdHJpeDtcbmZ1bmN0aW9uIGNwdURvdFByb2R1Y3QoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcHVEb3RQcm9kdWN0OiBpbmNvbXBhdGlibGUgdmVjdG9ycy4nKTtcbiAgICB9XG4gICAgdmFyIGQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICBkICs9IGFbaV0gKiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZDtcbn1cbmV4cG9ydHMuY3B1RG90UHJvZHVjdCA9IGNwdURvdFByb2R1Y3Q7XG5mdW5jdGlvbiBkZXNjcmliZU1hdGhDUFUobmFtZSwgdGVzdHMsIGZlYXR1cmVzTGlzdCkge1xuICAgIHZhciB0ZXN0TmFtZUJhc2UgPSAnbWF0aF9jcHUuJyArIG5hbWU7XG4gICAgZGVzY3JpYmVXaXRoRmVhdHVyZXNBbmRFeGVjdXRvcih0ZXN0TmFtZUJhc2UsIHRlc3RzLCBmdW5jdGlvbiAodGVzdE5hbWUsIHRlc3RzLCBmZWF0dXJlcykgeyByZXR1cm4gZXhlY3V0ZU1hdGhUZXN0cyh0ZXN0TmFtZSwgdGVzdHMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBtYXRoX2NwdV8xLk5EQXJyYXlNYXRoQ1BVKCk7IH0sIGZlYXR1cmVzKTsgfSwgZmVhdHVyZXNMaXN0KTtcbn1cbmV4cG9ydHMuZGVzY3JpYmVNYXRoQ1BVID0gZGVzY3JpYmVNYXRoQ1BVO1xuZnVuY3Rpb24gZGVzY3JpYmVNYXRoR1BVKG5hbWUsIHRlc3RzLCBmZWF0dXJlc0xpc3QpIHtcbiAgICB2YXIgdGVzdE5hbWVCYXNlID0gJ21hdGhfZ3B1LicgKyBuYW1lO1xuICAgIGRlc2NyaWJlV2l0aEZlYXR1cmVzQW5kRXhlY3V0b3IodGVzdE5hbWVCYXNlLCB0ZXN0cywgZnVuY3Rpb24gKHRlc3ROYW1lLCB0ZXN0cywgZmVhdHVyZXMpIHsgcmV0dXJuIGV4ZWN1dGVNYXRoVGVzdHModGVzdE5hbWUsIHRlc3RzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgbWF0aF9ncHVfMS5OREFycmF5TWF0aEdQVSgpOyB9LCBmZWF0dXJlcyk7IH0sIGZlYXR1cmVzTGlzdCk7XG59XG5leHBvcnRzLmRlc2NyaWJlTWF0aEdQVSA9IGRlc2NyaWJlTWF0aEdQVTtcbmZ1bmN0aW9uIGRlc2NyaWJlQ3VzdG9tKG5hbWUsIHRlc3RzLCBmZWF0dXJlc0xpc3QsIGN1c3RvbUJlZm9yZUVhY2gsIGN1c3RvbUFmdGVyRWFjaCkge1xuICAgIGRlc2NyaWJlV2l0aEZlYXR1cmVzQW5kRXhlY3V0b3IobmFtZSwgW3Rlc3RzXSwgZnVuY3Rpb24gKHRlc3ROYW1lLCB0ZXN0cywgZmVhdHVyZXMpIHsgcmV0dXJuIGV4ZWN1dGVUZXN0cyh0ZXN0TmFtZSwgdGVzdHMsIGZlYXR1cmVzLCBjdXN0b21CZWZvcmVFYWNoLCBjdXN0b21BZnRlckVhY2gpOyB9LCBmZWF0dXJlc0xpc3QpO1xufVxuZXhwb3J0cy5kZXNjcmliZUN1c3RvbSA9IGRlc2NyaWJlQ3VzdG9tO1xuZnVuY3Rpb24gZGVzY3JpYmVXaXRoRmVhdHVyZXNBbmRFeGVjdXRvcih0ZXN0TmFtZUJhc2UsIHRlc3RzLCBleGVjdXRvciwgZmVhdHVyZXNMaXN0KSB7XG4gICAgaWYgKGZlYXR1cmVzTGlzdCAhPSBudWxsKSB7XG4gICAgICAgIGZlYXR1cmVzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlcykge1xuICAgICAgICAgICAgdmFyIHRlc3ROYW1lID0gdGVzdE5hbWVCYXNlICsgJyAnICsgSlNPTi5zdHJpbmdpZnkoZmVhdHVyZXMpO1xuICAgICAgICAgICAgZXhlY3V0b3IodGVzdE5hbWUsIHRlc3RzLCBmZWF0dXJlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXhlY3V0b3IodGVzdE5hbWVCYXNlLCB0ZXN0cyk7XG4gICAgfVxufVxudmFyIFBST01JU0VfSVQgPSBmdW5jdGlvbiAobmFtZSwgdGVzdEZ1bmMpIHtcbiAgICBpdChuYW1lLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGVzdEZ1bmMoKTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKGRvbmUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZmFpbChlKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGV4ZWN1dGVNYXRoVGVzdHModGVzdE5hbWUsIHRlc3RzLCBtYXRoRmFjdG9yeSwgZmVhdHVyZXMpIHtcbiAgICB2YXIgbWF0aDtcbiAgICB2YXIgY3VzdG9tQmVmb3JlRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWF0aCA9IG1hdGhGYWN0b3J5KCk7XG4gICAgICAgIG1hdGguc3RhcnRTY29wZSgpO1xuICAgIH07XG4gICAgdmFyIGN1c3RvbUFmdGVyRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWF0aC5lbmRTY29wZShudWxsKTtcbiAgICAgICAgbWF0aC5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICB2YXIgY3VzdG9tSXQgPSBmdW5jdGlvbiAobmFtZSwgdGVzdEZ1bmMpIHtcbiAgICAgICAgUFJPTUlTRV9JVChuYW1lLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZXN0RnVuYyhtYXRoKTsgfSk7XG4gICAgfTtcbiAgICBleGVjdXRlVGVzdHModGVzdE5hbWUsIHRlc3RzLCBmZWF0dXJlcywgY3VzdG9tQmVmb3JlRWFjaCwgY3VzdG9tQWZ0ZXJFYWNoLCBjdXN0b21JdCk7XG59XG5leHBvcnRzLmV4ZWN1dGVNYXRoVGVzdHMgPSBleGVjdXRlTWF0aFRlc3RzO1xuZnVuY3Rpb24gZXhlY3V0ZVRlc3RzKHRlc3ROYW1lLCB0ZXN0cywgZmVhdHVyZXMsIGN1c3RvbUJlZm9yZUVhY2gsIGN1c3RvbUFmdGVyRWFjaCwgY3VzdG9tSXQpIHtcbiAgICBpZiAoY3VzdG9tSXQgPT09IHZvaWQgMCkgeyBjdXN0b21JdCA9IFBST01JU0VfSVQ7IH1cbiAgICBkZXNjcmliZSh0ZXN0TmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQuc2V0RW52aXJvbm1lbnQobmV3IGVudmlyb25tZW50XzEuRW52aXJvbm1lbnQoZmVhdHVyZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXN0b21CZWZvcmVFYWNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXN0b21CZWZvcmVFYWNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhZnRlckVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGN1c3RvbUFmdGVyRWFjaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQWZ0ZXJFYWNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmVhdHVyZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVudmlyb25tZW50LnNldEVudmlyb25tZW50KG5ldyBlbnZpcm9ubWVudF8xLkVudmlyb25tZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGVzdHMuZm9yRWFjaChmdW5jdGlvbiAodGVzdCkgeyByZXR1cm4gdGVzdChjdXN0b21JdCk7IH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5leGVjdXRlVGVzdHMgPSBleGVjdXRlVGVzdHM7XG5mdW5jdGlvbiBhc3NlcnRJc05hbih2YWwsIGR0eXBlKSB7XG4gICAgaWYgKCF1dGlsLmlzVmFsTmFOKHZhbCwgZHR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIFwiICsgdmFsICsgXCIgZG9lcyBub3QgcmVwcmVzZW50IE5hTiBmb3IgZHR5cGUgXCIgKyBkdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRJc05hbiA9IGFzc2VydElzTmFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVzdF91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xuICAgIHZhciBjb3VudGVyID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciB0ZW1wID0gMDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChjb3VudGVyID4gMCkge1xuICAgICAgICBpbmRleCA9IChNYXRoLnJhbmRvbSgpICogY291bnRlcikgfCAwO1xuICAgICAgICBjb3VudGVyLS07XG4gICAgICAgIHRlbXAgPSBhcnJheVtjb3VudGVyXTtcbiAgICAgICAgYXJyYXlbY291bnRlcl0gPSBhcnJheVtpbmRleF07XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHRlbXA7XG4gICAgfVxufVxuZXhwb3J0cy5zaHVmZmxlID0gc2h1ZmZsZTtcbmZ1bmN0aW9uIGNsYW1wKG1pbiwgeCwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4oeCwgbWF4KSk7XG59XG5leHBvcnRzLmNsYW1wID0gY2xhbXA7XG5mdW5jdGlvbiByYW5kVW5pZm9ybShhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAoYiAtIGEpICsgYTtcbn1cbmV4cG9ydHMucmFuZFVuaWZvcm0gPSByYW5kVW5pZm9ybTtcbmZ1bmN0aW9uIHJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIHRydW5jYXRlZCkge1xuICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgIGlmICh0cnVuY2F0ZWQgPT09IHZvaWQgMCkgeyB0cnVuY2F0ZWQgPSBmYWxzZTsgfVxuICAgIHZhciB2MSwgdjIsIHM7XG4gICAgZG8ge1xuICAgICAgICB2MSA9IDIgKiBNYXRoLnJhbmRvbSgpIC0gMTtcbiAgICAgICAgdjIgPSAyICogTWF0aC5yYW5kb20oKSAtIDE7XG4gICAgICAgIHMgPSB2MSAqIHYxICsgdjIgKiB2MjtcbiAgICB9IHdoaWxlIChzID4gMSk7XG4gICAgdmFyIHJlc3VsdCA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHMpIC8gcykgKiB2MTtcbiAgICBpZiAodHJ1bmNhdGVkICYmIE1hdGguYWJzKHJlc3VsdCkgPiAyKSB7XG4gICAgICAgIHJldHVybiByYW5kR2F1c3MobWVhbiwgc3RkRGV2LCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lYW4gKyBzdGREZXYgKiByZXN1bHQ7XG59XG5leHBvcnRzLnJhbmRHYXVzcyA9IHJhbmRHYXVzcztcbmZ1bmN0aW9uIGRpc3RTcXVhcmVkKGEsIGIpIHtcbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRpZmYgPSBOdW1iZXIoYVtpXSkgLSBOdW1iZXIoYltpXSk7XG4gICAgICAgIHJlc3VsdCArPSBkaWZmICogZGlmZjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZGlzdFNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbmZ1bmN0aW9uIGFzc2VydChleHByLCBtc2cpIHtcbiAgICBpZiAoIWV4cHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5mdW5jdGlvbiBhc3NlcnRTaGFwZXNNYXRjaChzaGFwZUEsIHNoYXBlQiwgZXJyb3JNZXNzYWdlUHJlZml4KSB7XG4gICAgaWYgKGVycm9yTWVzc2FnZVByZWZpeCA9PT0gdm9pZCAwKSB7IGVycm9yTWVzc2FnZVByZWZpeCA9ICcnOyB9XG4gICAgYXNzZXJ0KGFycmF5c0VxdWFsKHNoYXBlQSwgc2hhcGVCKSwgZXJyb3JNZXNzYWdlUHJlZml4ICsgKFwiU2hhcGVzIFwiICsgc2hhcGVBICsgXCIgYW5kIFwiICsgc2hhcGVCICsgXCIgbXVzdCBtYXRjaFwiKSk7XG59XG5leHBvcnRzLmFzc2VydFNoYXBlc01hdGNoID0gYXNzZXJ0U2hhcGVzTWF0Y2g7XG5mdW5jdGlvbiBmbGF0dGVuKGFyciwgcmV0KSB7XG4gICAgaWYgKHJldCA9PT0gdm9pZCAwKSB7IHJldCA9IFtdOyB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZmxhdHRlbihhcnJbaV0sIHJldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldC5wdXNoKGFycik7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5leHBvcnRzLmZsYXR0ZW4gPSBmbGF0dGVuO1xuZnVuY3Rpb24gaW5mZXJTaGFwZShhcnIpIHtcbiAgICB2YXIgc2hhcGUgPSBbXTtcbiAgICB3aGlsZSAoYXJyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgc2hhcGUucHVzaChhcnIubGVuZ3RoKTtcbiAgICAgICAgYXJyID0gYXJyWzBdO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcGU7XG59XG5leHBvcnRzLmluZmVyU2hhcGUgPSBpbmZlclNoYXBlO1xuZnVuY3Rpb24gc2l6ZUZyb21TaGFwZShzaGFwZSkge1xuICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHZhciBzaXplID0gc2hhcGVbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzaXplICo9IHNoYXBlW2ldO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbmV4cG9ydHMuc2l6ZUZyb21TaGFwZSA9IHNpemVGcm9tU2hhcGU7XG5mdW5jdGlvbiBpc1NjYWxhclNoYXBlKHNoYXBlKSB7XG4gICAgcmV0dXJuIHNoYXBlLmxlbmd0aCA9PT0gMDtcbn1cbmV4cG9ydHMuaXNTY2FsYXJTaGFwZSA9IGlzU2NhbGFyU2hhcGU7XG5mdW5jdGlvbiBhcnJheXNFcXVhbChuMSwgbjIpIHtcbiAgICBpZiAobjEubGVuZ3RoICE9PSBuMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4xLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChuMVtpXSAhPT0gbjJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuYXJyYXlzRXF1YWwgPSBhcnJheXNFcXVhbDtcbmZ1bmN0aW9uIGlzSW50KGEpIHtcbiAgICByZXR1cm4gYSAlIDEgPT09IDA7XG59XG5leHBvcnRzLmlzSW50ID0gaXNJbnQ7XG5mdW5jdGlvbiB0YW5oKHgpIHtcbiAgICBpZiAoTWF0aC50YW5oICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgudGFuaCh4KTtcbiAgICB9XG4gICAgaWYgKHggPT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIGlmICh4ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGUyeCA9IE1hdGguZXhwKDIgKiB4KTtcbiAgICAgICAgcmV0dXJuIChlMnggLSAxKSAvIChlMnggKyAxKTtcbiAgICB9XG59XG5leHBvcnRzLnRhbmggPSB0YW5oO1xuZnVuY3Rpb24gc2l6ZVRvU3F1YXJpc2hTaGFwZShzaXplKSB7XG4gICAgZm9yICh2YXIgYSA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KHNpemUpKTsgYSA+IDE7IC0tYSkge1xuICAgICAgICBpZiAoc2l6ZSAlIGEgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbYSwgc2l6ZSAvIGFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbMSwgc2l6ZV07XG59XG5leHBvcnRzLnNpemVUb1NxdWFyaXNoU2hhcGUgPSBzaXplVG9TcXVhcmlzaFNoYXBlO1xuZnVuY3Rpb24gY3JlYXRlU2h1ZmZsZWRJbmRpY2VzKG4pIHtcbiAgICB2YXIgc2h1ZmZsZWRJbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KG4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHNodWZmbGVkSW5kaWNlc1tpXSA9IGk7XG4gICAgfVxuICAgIHNodWZmbGUoc2h1ZmZsZWRJbmRpY2VzKTtcbiAgICByZXR1cm4gc2h1ZmZsZWRJbmRpY2VzO1xufVxuZXhwb3J0cy5jcmVhdGVTaHVmZmxlZEluZGljZXMgPSBjcmVhdGVTaHVmZmxlZEluZGljZXM7XG5mdW5jdGlvbiByaWdodFBhZChhLCBzaXplKSB7XG4gICAgaWYgKHNpemUgPD0gYS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHJldHVybiBhICsgJyAnLnJlcGVhdChzaXplIC0gYS5sZW5ndGgpO1xufVxuZXhwb3J0cy5yaWdodFBhZCA9IHJpZ2h0UGFkO1xuZnVuY3Rpb24gcmVwZWF0ZWRUcnkoY2hlY2tGbiwgZGVsYXlGbiwgbWF4Q291bnRlcikge1xuICAgIGlmIChkZWxheUZuID09PSB2b2lkIDApIHsgZGVsYXlGbiA9IGZ1bmN0aW9uIChjb3VudGVyKSB7IHJldHVybiAwOyB9OyB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHRyeUNvdW50ID0gMDtcbiAgICAgICAgdmFyIHRyeUZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGNoZWNrRm4oKSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnlDb3VudCsrO1xuICAgICAgICAgICAgdmFyIG5leHRCYWNrb2ZmID0gZGVsYXlGbih0cnlDb3VudCk7XG4gICAgICAgICAgICBpZiAobWF4Q291bnRlciAhPSBudWxsICYmIHRyeUNvdW50ID49IG1heENvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRyeUZuLCBuZXh0QmFja29mZik7XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQodHJ5Rm4sIDApO1xuICAgIH0pO1xufVxuZXhwb3J0cy5yZXBlYXRlZFRyeSA9IHJlcGVhdGVkVHJ5O1xuZnVuY3Rpb24gZ2V0UXVlcnlQYXJhbXMocXVlcnlTdHJpbmcpIHtcbiAgICB2YXIgcGFyYW1zID0ge307XG4gICAgcXVlcnlTdHJpbmcucmVwbGFjZSgvWz8mXShbXj0/Jl0rKSg/Oj0oW14mXSopKT8vZywgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHRbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlUGFyYW0ocGFyYW1zLCB0WzBdLCB0WzFdKTtcbiAgICAgICAgcmV0dXJuIHQuam9pbignPScpO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJhbXM7XG59XG5leHBvcnRzLmdldFF1ZXJ5UGFyYW1zID0gZ2V0UXVlcnlQYXJhbXM7XG5mdW5jdGlvbiBkZWNvZGVQYXJhbShwYXJhbXMsIG5hbWUsIHZhbHVlKSB7XG4gICAgcGFyYW1zW2RlY29kZVVSSUNvbXBvbmVudChuYW1lKV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUgfHwgJycpO1xufVxuZnVuY3Rpb24gaW5mZXJGcm9tSW1wbGljaXRTaGFwZShzaGFwZSwgc2l6ZSkge1xuICAgIHZhciBzaGFwZVByb2QgPSAxO1xuICAgIHZhciBpbXBsaWNpdElkeCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHNoYXBlW2ldID4gMCkge1xuICAgICAgICAgICAgc2hhcGVQcm9kICo9IHNoYXBlW2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNoYXBlW2ldID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKGltcGxpY2l0SWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2hhcGVzIGNhbiBvbmx5IGhhdmUgMSBpbXBsaWNpdCBzaXplLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIkZvdW5kIC0xIGF0IGRpbSBcIiArIGltcGxpY2l0SWR4ICsgXCIgYW5kIGRpbSBcIiArIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltcGxpY2l0SWR4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaGFwZVtpXSA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNoYXBlcyBjYW4gbm90IGJlIDw9IDAuIEZvdW5kIFwiICsgc2hhcGVbaV0gKyBcIiBhdCBkaW0gXCIgKyBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW1wbGljaXRJZHggPT09IC0xKSB7XG4gICAgICAgIGlmIChzaXplID4gMCAmJiBzaXplICE9PSBzaGFwZVByb2QpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2l6ZSAoXCIgKyBzaXplICsgXCIpIG11c3QgbWF0Y2ggdGhlIHByb2R1Y3Qgb2Ygc2hhcGUgXCIgKyBzaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH1cbiAgICBpZiAoc2l6ZSAlIHNoYXBlUHJvZCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBpbXBsaWNpdCBzaGFwZSBjYW4ndCBiZSBhIGZyYWN0aW9uYWwgbnVtYmVyLiBcIiArXG4gICAgICAgICAgICAoXCJHb3QgXCIgKyBzaXplICsgXCIgLyBcIiArIHNoYXBlUHJvZCkpO1xuICAgIH1cbiAgICB2YXIgbmV3U2hhcGUgPSBzaGFwZS5zbGljZSgpO1xuICAgIG5ld1NoYXBlW2ltcGxpY2l0SWR4XSA9IHNpemUgLyBzaGFwZVByb2Q7XG4gICAgcmV0dXJuIG5ld1NoYXBlO1xufVxuZXhwb3J0cy5pbmZlckZyb21JbXBsaWNpdFNoYXBlID0gaW5mZXJGcm9tSW1wbGljaXRTaGFwZTtcbmV4cG9ydHMuTkFOX0lOVDMyID0gMSA8PCAzMTtcbmV4cG9ydHMuTkFOX0JPT0wgPSAyNTU7XG5leHBvcnRzLk5BTl9GTE9BVDMyID0gTmFOO1xuZnVuY3Rpb24gZ2V0TmFOKGR0eXBlKSB7XG4gICAgaWYgKGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuTkFOX0ZMT0FUMzI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk5BTl9JTlQzMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5OQU5fQk9PTDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZHR5cGUgXCIgKyBkdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXROYU4gPSBnZXROYU47XG5mdW5jdGlvbiBpc1ZhbE5hTih2YWwsIGR0eXBlKSB7XG4gICAgaWYgKGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgIHJldHVybiB2YWwgPT09IGV4cG9ydHMuTkFOX0lOVDMyO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiB2YWwgPT09IGV4cG9ydHMuTkFOX0JPT0w7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGR0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuaXNWYWxOYU4gPSBpc1ZhbE5hTjtcbmZ1bmN0aW9uIHNxdWVlemVTaGFwZShzaGFwZSkge1xuICAgIHZhciBuZXdTaGFwZSA9IFtdO1xuICAgIHZhciBrZXB0RGltcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHNoYXBlW2ldID4gMSkge1xuICAgICAgICAgICAgbmV3U2hhcGUucHVzaChzaGFwZVtpXSk7XG4gICAgICAgICAgICBrZXB0RGltcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG5ld1NoYXBlOiBuZXdTaGFwZSwga2VwdERpbXM6IGtlcHREaW1zIH07XG59XG5leHBvcnRzLnNxdWVlemVTaGFwZSA9IHNxdWVlemVTaGFwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmVyc2lvbiA9ICcwLjMuMTEnO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIiwiLy8gQSBsaWJyYXJ5IG9mIHNlZWRhYmxlIFJOR3MgaW1wbGVtZW50ZWQgaW4gSmF2YXNjcmlwdC5cbi8vXG4vLyBVc2FnZTpcbi8vXG4vLyB2YXIgc2VlZHJhbmRvbSA9IHJlcXVpcmUoJ3NlZWRyYW5kb20nKTtcbi8vIHZhciByYW5kb20gPSBzZWVkcmFuZG9tKDEpOyAvLyBvciBhbnkgc2VlZC5cbi8vIHZhciB4ID0gcmFuZG9tKCk7ICAgICAgIC8vIDAgPD0geCA8IDEuICBFdmVyeSBiaXQgaXMgcmFuZG9tLlxuLy8gdmFyIHggPSByYW5kb20ucXVpY2soKTsgLy8gMCA8PSB4IDwgMS4gIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cblxuLy8gYWxlYSwgYSA1My1iaXQgbXVsdGlwbHktd2l0aC1jYXJyeSBnZW5lcmF0b3IgYnkgSm9oYW5uZXMgQmFhZ8O4ZS5cbi8vIFBlcmlvZDogfjJeMTE2XG4vLyBSZXBvcnRlZCB0byBwYXNzIGFsbCBCaWdDcnVzaCB0ZXN0cy5cbnZhciBhbGVhID0gcmVxdWlyZSgnLi9saWIvYWxlYScpO1xuXG4vLyB4b3IxMjgsIGEgcHVyZSB4b3Itc2hpZnQgZ2VuZXJhdG9yIGJ5IEdlb3JnZSBNYXJzYWdsaWEuXG4vLyBQZXJpb2Q6IDJeMTI4LTEuXG4vLyBSZXBvcnRlZCB0byBmYWlsOiBNYXRyaXhSYW5rIGFuZCBMaW5lYXJDb21wLlxudmFyIHhvcjEyOCA9IHJlcXVpcmUoJy4vbGliL3hvcjEyOCcpO1xuXG4vLyB4b3J3b3csIEdlb3JnZSBNYXJzYWdsaWEncyAxNjAtYml0IHhvci1zaGlmdCBjb21iaW5lZCBwbHVzIHdleWwuXG4vLyBQZXJpb2Q6IDJeMTkyLTJeMzJcbi8vIFJlcG9ydGVkIHRvIGZhaWw6IENvbGxpc2lvbk92ZXIsIFNpbXBQb2tlciwgYW5kIExpbmVhckNvbXAuXG52YXIgeG9yd293ID0gcmVxdWlyZSgnLi9saWIveG9yd293Jyk7XG5cbi8vIHhvcnNoaWZ0NywgYnkgRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXIsIHRha2VzXG4vLyBhIGRpZmZlcmVudCBhcHByb2FjaDogaXQgYWRkcyByb2J1c3RuZXNzIGJ5IGFsbG93aW5nIG1vcmUgc2hpZnRzXG4vLyB0aGFuIE1hcnNhZ2xpYSdzIG9yaWdpbmFsIHRocmVlLiAgSXQgaXMgYSA3LXNoaWZ0IGdlbmVyYXRvclxuLy8gd2l0aCAyNTYgYml0cywgdGhhdCBwYXNzZXMgQmlnQ3J1c2ggd2l0aCBubyBzeXN0bWF0aWMgZmFpbHVyZXMuXG4vLyBQZXJpb2QgMl4yNTYtMS5cbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgeG9yc2hpZnQ3ID0gcmVxdWlyZSgnLi9saWIveG9yc2hpZnQ3Jyk7XG5cbi8vIHhvcjQwOTYsIGJ5IFJpY2hhcmQgQnJlbnQsIGlzIGEgNDA5Ni1iaXQgeG9yLXNoaWZ0IHdpdGggYVxuLy8gdmVyeSBsb25nIHBlcmlvZCB0aGF0IGFsc28gYWRkcyBhIFdleWwgZ2VuZXJhdG9yLiBJdCBhbHNvIHBhc3Nlc1xuLy8gQmlnQ3J1c2ggd2l0aCBubyBzeXN0ZW1hdGljIGZhaWx1cmVzLiAgSXRzIGxvbmcgcGVyaW9kIG1heVxuLy8gYmUgdXNlZnVsIGlmIHlvdSBoYXZlIG1hbnkgZ2VuZXJhdG9ycyBhbmQgbmVlZCB0byBhdm9pZFxuLy8gY29sbGlzaW9ucy5cbi8vIFBlcmlvZDogMl40MTI4LTJeMzIuXG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHhvcjQwOTYgPSByZXF1aXJlKCcuL2xpYi94b3I0MDk2Jyk7XG5cbi8vIFR5Y2hlLWksIGJ5IFNhbXVlbCBOZXZlcyBhbmQgRmlsaXBlIEFyYXVqbywgaXMgYSBiaXQtc2hpZnRpbmcgcmFuZG9tXG4vLyBudW1iZXIgZ2VuZXJhdG9yIGRlcml2ZWQgZnJvbSBDaGFDaGEsIGEgbW9kZXJuIHN0cmVhbSBjaXBoZXIuXG4vLyBodHRwczovL2VkZW4uZGVpLnVjLnB0L35zbmV2ZXMvcHVicy8yMDExLXNuZmEyLnBkZlxuLy8gUGVyaW9kOiB+Ml4xMjdcbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgdHljaGVpID0gcmVxdWlyZSgnLi9saWIvdHljaGVpJyk7XG5cbi8vIFRoZSBvcmlnaW5hbCBBUkM0LWJhc2VkIHBybmcgaW5jbHVkZWQgaW4gdGhpcyBsaWJyYXJ5LlxuLy8gUGVyaW9kOiB+Ml4xNjAwXG52YXIgc3IgPSByZXF1aXJlKCcuL3NlZWRyYW5kb20nKTtcblxuc3IuYWxlYSA9IGFsZWE7XG5zci54b3IxMjggPSB4b3IxMjg7XG5zci54b3J3b3cgPSB4b3J3b3c7XG5zci54b3JzaGlmdDcgPSB4b3JzaGlmdDc7XG5zci54b3I0MDk2ID0geG9yNDA5NjtcbnNyLnR5Y2hlaSA9IHR5Y2hlaTtcblxubW9kdWxlLmV4cG9ydHMgPSBzcjtcbiIsIi8vIEEgcG9ydCBvZiBhbiBhbGdvcml0aG0gYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5jb20+LCAyMDEwXG4vLyBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbnF1aW5sYW4vYmV0dGVyLXJhbmRvbS1udW1iZXJzLWZvci1qYXZhc2NyaXB0LW1pcnJvclxuLy8gT3JpZ2luYWwgd29yayBpcyB1bmRlciBNSVQgbGljZW5zZSAtXG5cbi8vIENvcHlyaWdodCAoQykgMjAxMCBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLm9yZz5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vLyBcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vIFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cblxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBBbGVhKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgbWFzaCA9IE1hc2goKTtcblxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSAyMDkxNjM5ICogbWUuczAgKyBtZS5jICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgICBtZS5zMCA9IG1lLnMxO1xuICAgIG1lLnMxID0gbWUuczI7XG4gICAgcmV0dXJuIG1lLnMyID0gdCAtIChtZS5jID0gdCB8IDApO1xuICB9O1xuXG4gIC8vIEFwcGx5IHRoZSBzZWVkaW5nIGFsZ29yaXRobSBmcm9tIEJhYWdvZS5cbiAgbWUuYyA9IDE7XG4gIG1lLnMwID0gbWFzaCgnICcpO1xuICBtZS5zMSA9IG1hc2goJyAnKTtcbiAgbWUuczIgPSBtYXNoKCcgJyk7XG4gIG1lLnMwIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMCA8IDApIHsgbWUuczAgKz0gMTsgfVxuICBtZS5zMSAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczEgPCAwKSB7IG1lLnMxICs9IDE7IH1cbiAgbWUuczIgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMyIDwgMCkgeyBtZS5zMiArPSAxOyB9XG4gIG1hc2ggPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5jID0gZi5jO1xuICB0LnMwID0gZi5zMDtcbiAgdC5zMSA9IGYuczE7XG4gIHQuczIgPSBmLnMyO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBBbGVhKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0geGcubmV4dDtcbiAgcHJuZy5pbnQzMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSAqIDB4MTAwMDAwMDAwKSB8IDA7IH1cbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcHJuZygpICsgKHBybmcoKSAqIDB4MjAwMDAwIHwgMCkgKiAxLjExMDIyMzAyNDYyNTE1NjVlLTE2OyAvLyAyXi01M1xuICB9O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuZnVuY3Rpb24gTWFzaCgpIHtcbiAgdmFyIG4gPSAweGVmYzgyNDlkO1xuXG4gIHZhciBtYXNoID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuICs9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIGggKj0gbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7IC8vIDJeMzJcbiAgICB9XG4gICAgcmV0dXJuIChuID4+PiAwKSAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gIH07XG5cbiAgcmV0dXJuIG1hc2g7XG59XG5cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy5hbGVhID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJUeWNoZS1pXCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIFNhbXVlbCBOZXZlcyBhbmQgRmlsaXBlIEFyYXVqby5cbi8vIFNlZSBodHRwczovL2VkZW4uZGVpLnVjLnB0L35zbmV2ZXMvcHVicy8yMDExLXNuZmEyLnBkZlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBzdHJzZWVkID0gJyc7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiID0gbWUuYiwgYyA9IG1lLmMsIGQgPSBtZS5kLCBhID0gbWUuYTtcbiAgICBiID0gKGIgPDwgMjUpIF4gKGIgPj4+IDcpIF4gYztcbiAgICBjID0gKGMgLSBkKSB8IDA7XG4gICAgZCA9IChkIDw8IDI0KSBeIChkID4+PiA4KSBeIGE7XG4gICAgYSA9IChhIC0gYikgfCAwO1xuICAgIG1lLmIgPSBiID0gKGIgPDwgMjApIF4gKGIgPj4+IDEyKSBeIGM7XG4gICAgbWUuYyA9IGMgPSAoYyAtIGQpIHwgMDtcbiAgICBtZS5kID0gKGQgPDwgMTYpIF4gKGMgPj4+IDE2KSBeIGE7XG4gICAgcmV0dXJuIG1lLmEgPSAoYSAtIGIpIHwgMDtcbiAgfTtcblxuICAvKiBUaGUgZm9sbG93aW5nIGlzIG5vbi1pbnZlcnRlZCB0eWNoZSwgd2hpY2ggaGFzIGJldHRlciBpbnRlcm5hbFxuICAgKiBiaXQgZGlmZnVzaW9uLCBidXQgd2hpY2ggaXMgYWJvdXQgMjUlIHNsb3dlciB0aGFuIHR5Y2hlLWkgaW4gSlMuXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IG1lLmEsIGIgPSBtZS5iLCBjID0gbWUuYywgZCA9IG1lLmQ7XG4gICAgYSA9IChtZS5hICsgbWUuYiB8IDApID4+PiAwO1xuICAgIGQgPSBtZS5kIF4gYTsgZCA9IGQgPDwgMTYgXiBkID4+PiAxNjtcbiAgICBjID0gbWUuYyArIGQgfCAwO1xuICAgIGIgPSBtZS5iIF4gYzsgYiA9IGIgPDwgMTIgXiBkID4+PiAyMDtcbiAgICBtZS5hID0gYSA9IGEgKyBiIHwgMDtcbiAgICBkID0gZCBeIGE7IG1lLmQgPSBkID0gZCA8PCA4IF4gZCA+Pj4gMjQ7XG4gICAgbWUuYyA9IGMgPSBjICsgZCB8IDA7XG4gICAgYiA9IGIgXiBjO1xuICAgIHJldHVybiBtZS5iID0gKGIgPDwgNyBeIGIgPj4+IDI1KTtcbiAgfVxuICAqL1xuXG4gIG1lLmEgPSAwO1xuICBtZS5iID0gMDtcbiAgbWUuYyA9IDI2NTQ0MzU3NjkgfCAwO1xuICBtZS5kID0gMTM2NzEzMDU1MTtcblxuICBpZiAoc2VlZCA9PT0gTWF0aC5mbG9vcihzZWVkKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS5hID0gKHNlZWQgLyAweDEwMDAwMDAwMCkgfCAwO1xuICAgIG1lLmIgPSBzZWVkIHwgMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDIwOyBrKyspIHtcbiAgICBtZS5iIF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmEgPSBmLmE7XG4gIHQuYiA9IGYuYjtcbiAgdC5jID0gZi5jO1xuICB0LmQgPSBmLmQ7XG4gIHJldHVybiB0O1xufTtcblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy50eWNoZWkgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcjEyOFwiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBHZW9yZ2UgTWFyc2FnbGlhLiAgU2VlIGh0dHA6Ly93d3cuanN0YXRzb2Z0Lm9yZy92MDgvaTE0L3BhcGVyXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICBtZS54ID0gMDtcbiAgbWUueSA9IDA7XG4gIG1lLnogPSAwO1xuICBtZS53ID0gMDtcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBtZS54IF4gKG1lLnggPDwgMTEpO1xuICAgIG1lLnggPSBtZS55O1xuICAgIG1lLnkgPSBtZS56O1xuICAgIG1lLnogPSBtZS53O1xuICAgIHJldHVybiBtZS53IF49IChtZS53ID4+PiAxOSkgXiB0IF4gKHQgPj4+IDgpO1xuICB9O1xuXG4gIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLnggPSBzZWVkO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgNjQ7IGsrKykge1xuICAgIG1lLnggXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueDtcbiAgdC55ID0gZi55O1xuICB0LnogPSBmLno7XG4gIHQudyA9IGYudztcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yMTI4ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiBSaWNoYXJkIEJyZW50J3MgWG9yZ2VucyB4b3I0MDk2IGFsZ29yaXRobS5cbi8vXG4vLyBUaGlzIGZhc3Qgbm9uLWNyeXB0b2dyYXBoaWMgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgaXMgZGVzaWduZWQgZm9yXG4vLyB1c2UgaW4gTW9udGUtQ2FybG8gYWxnb3JpdGhtcy4gSXQgY29tYmluZXMgYSBsb25nLXBlcmlvZCB4b3JzaGlmdFxuLy8gZ2VuZXJhdG9yIHdpdGggYSBXZXlsIGdlbmVyYXRvciwgYW5kIGl0IHBhc3NlcyBhbGwgY29tbW9uIGJhdHRlcmllc1xuLy8gb2Ygc3Rhc3RpY2lhbCB0ZXN0cyBmb3IgcmFuZG9tbmVzcyB3aGlsZSBjb25zdW1pbmcgb25seSBhIGZldyBuYW5vc2Vjb25kc1xuLy8gZm9yIGVhY2ggcHJuZyBnZW5lcmF0ZWQuICBGb3IgYmFja2dyb3VuZCBvbiB0aGUgZ2VuZXJhdG9yLCBzZWUgQnJlbnQnc1xuLy8gcGFwZXI6IFwiU29tZSBsb25nLXBlcmlvZCByYW5kb20gbnVtYmVyIGdlbmVyYXRvcnMgdXNpbmcgc2hpZnRzIGFuZCB4b3JzLlwiXG4vLyBodHRwOi8vYXJ4aXYub3JnL3BkZi8xMDA0LjMxMTV2MS5wZGZcbi8vXG4vLyBVc2FnZTpcbi8vXG4vLyB2YXIgeG9yNDA5NiA9IHJlcXVpcmUoJ3hvcjQwOTYnKTtcbi8vIHJhbmRvbSA9IHhvcjQwOTYoMSk7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlZCB3aXRoIGludDMyIG9yIHN0cmluZy5cbi8vIGFzc2VydC5lcXVhbChyYW5kb20oKSwgMC4xNTIwNDM2NDUwNTM4NTQ3KTsgLy8gKDAsIDEpIHJhbmdlLCA1MyBiaXRzLlxuLy8gYXNzZXJ0LmVxdWFsKHJhbmRvbS5pbnQzMigpLCAxODA2NTM0ODk3KTsgICAvLyBzaWduZWQgaW50MzIsIDMyIGJpdHMuXG4vL1xuLy8gRm9yIG5vbnplcm8gbnVtZXJpYyBrZXlzLCB0aGlzIGltcGVsZW1lbnRhdGlvbiBwcm92aWRlcyBhIHNlcXVlbmNlXG4vLyBpZGVudGljYWwgdG8gdGhhdCBieSBCcmVudCdzIHhvcmdlbnMgMyBpbXBsZW1lbnRhaW9uIGluIEMuICBUaGlzXG4vLyBpbXBsZW1lbnRhdGlvbiBhbHNvIHByb3ZpZGVzIGZvciBpbml0YWxpemluZyB0aGUgZ2VuZXJhdG9yIHdpdGhcbi8vIHN0cmluZyBzZWVkcywgb3IgZm9yIHNhdmluZyBhbmQgcmVzdG9yaW5nIHRoZSBzdGF0ZSBvZiB0aGUgZ2VuZXJhdG9yLlxuLy9cbi8vIE9uIENocm9tZSwgdGhpcyBwcm5nIGJlbmNobWFya3MgYWJvdXQgMi4xIHRpbWVzIHNsb3dlciB0aGFuXG4vLyBKYXZhc2NyaXB0J3MgYnVpbHQtaW4gTWF0aC5yYW5kb20oKS5cblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHcgPSBtZS53LFxuICAgICAgICBYID0gbWUuWCwgaSA9IG1lLmksIHQsIHY7XG4gICAgLy8gVXBkYXRlIFdleWwgZ2VuZXJhdG9yLlxuICAgIG1lLncgPSB3ID0gKHcgKyAweDYxYzg4NjQ3KSB8IDA7XG4gICAgLy8gVXBkYXRlIHhvciBnZW5lcmF0b3IuXG4gICAgdiA9IFhbKGkgKyAzNCkgJiAxMjddO1xuICAgIHQgPSBYW2kgPSAoKGkgKyAxKSAmIDEyNyldO1xuICAgIHYgXj0gdiA8PCAxMztcbiAgICB0IF49IHQgPDwgMTc7XG4gICAgdiBePSB2ID4+PiAxNTtcbiAgICB0IF49IHQgPj4+IDEyO1xuICAgIC8vIFVwZGF0ZSBYb3IgZ2VuZXJhdG9yIGFycmF5IHN0YXRlLlxuICAgIHYgPSBYW2ldID0gdiBeIHQ7XG4gICAgbWUuaSA9IGk7XG4gICAgLy8gUmVzdWx0IGlzIHRoZSBjb21iaW5hdGlvbi5cbiAgICByZXR1cm4gKHYgKyAodyBeICh3ID4+PiAxNikpKSB8IDA7XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5pdChtZSwgc2VlZCkge1xuICAgIHZhciB0LCB2LCBpLCBqLCB3LCBYID0gW10sIGxpbWl0ID0gMTI4O1xuICAgIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgICAvLyBOdW1lcmljIHNlZWRzIGluaXRpYWxpemUgdiwgd2hpY2ggaXMgdXNlZCB0byBnZW5lcmF0ZXMgWC5cbiAgICAgIHYgPSBzZWVkO1xuICAgICAgc2VlZCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0cmluZyBzZWVkcyBhcmUgbWl4ZWQgaW50byB2IGFuZCBYIG9uZSBjaGFyYWN0ZXIgYXQgYSB0aW1lLlxuICAgICAgc2VlZCA9IHNlZWQgKyAnXFwwJztcbiAgICAgIHYgPSAwO1xuICAgICAgbGltaXQgPSBNYXRoLm1heChsaW1pdCwgc2VlZC5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyBJbml0aWFsaXplIGNpcmN1bGFyIGFycmF5IGFuZCB3ZXlsIHZhbHVlLlxuICAgIGZvciAoaSA9IDAsIGogPSAtMzI7IGogPCBsaW1pdDsgKytqKSB7XG4gICAgICAvLyBQdXQgdGhlIHVuaWNvZGUgY2hhcmFjdGVycyBpbnRvIHRoZSBhcnJheSwgYW5kIHNodWZmbGUgdGhlbS5cbiAgICAgIGlmIChzZWVkKSB2IF49IHNlZWQuY2hhckNvZGVBdCgoaiArIDMyKSAlIHNlZWQubGVuZ3RoKTtcbiAgICAgIC8vIEFmdGVyIDMyIHNodWZmbGVzLCB0YWtlIHYgYXMgdGhlIHN0YXJ0aW5nIHcgdmFsdWUuXG4gICAgICBpZiAoaiA9PT0gMCkgdyA9IHY7XG4gICAgICB2IF49IHYgPDwgMTA7XG4gICAgICB2IF49IHYgPj4+IDE1O1xuICAgICAgdiBePSB2IDw8IDQ7XG4gICAgICB2IF49IHYgPj4+IDEzO1xuICAgICAgaWYgKGogPj0gMCkge1xuICAgICAgICB3ID0gKHcgKyAweDYxYzg4NjQ3KSB8IDA7ICAgICAvLyBXZXlsLlxuICAgICAgICB0ID0gKFhbaiAmIDEyN10gXj0gKHYgKyB3KSk7ICAvLyBDb21iaW5lIHhvciBhbmQgd2V5bCB0byBpbml0IGFycmF5LlxuICAgICAgICBpID0gKDAgPT0gdCkgPyBpICsgMSA6IDA7ICAgICAvLyBDb3VudCB6ZXJvZXMuXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdlIGhhdmUgZGV0ZWN0ZWQgYWxsIHplcm9lczsgbWFrZSB0aGUga2V5IG5vbnplcm8uXG4gICAgaWYgKGkgPj0gMTI4KSB7XG4gICAgICBYWyhzZWVkICYmIHNlZWQubGVuZ3RoIHx8IDApICYgMTI3XSA9IC0xO1xuICAgIH1cbiAgICAvLyBSdW4gdGhlIGdlbmVyYXRvciA1MTIgdGltZXMgdG8gZnVydGhlciBtaXggdGhlIHN0YXRlIGJlZm9yZSB1c2luZyBpdC5cbiAgICAvLyBGYWN0b3JpbmcgdGhpcyBhcyBhIGZ1bmN0aW9uIHNsb3dzIHRoZSBtYWluIGdlbmVyYXRvciwgc28gaXQgaXMganVzdFxuICAgIC8vIHVucm9sbGVkIGhlcmUuICBUaGUgd2V5bCBnZW5lcmF0b3IgaXMgbm90IGFkdmFuY2VkIHdoaWxlIHdhcm1pbmcgdXAuXG4gICAgaSA9IDEyNztcbiAgICBmb3IgKGogPSA0ICogMTI4OyBqID4gMDsgLS1qKSB7XG4gICAgICB2ID0gWFsoaSArIDM0KSAmIDEyN107XG4gICAgICB0ID0gWFtpID0gKChpICsgMSkgJiAxMjcpXTtcbiAgICAgIHYgXj0gdiA8PCAxMztcbiAgICAgIHQgXj0gdCA8PCAxNztcbiAgICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgICB0IF49IHQgPj4+IDEyO1xuICAgICAgWFtpXSA9IHYgXiB0O1xuICAgIH1cbiAgICAvLyBTdG9yaW5nIHN0YXRlIGFzIG9iamVjdCBtZW1iZXJzIGlzIGZhc3RlciB0aGFuIHVzaW5nIGNsb3N1cmUgdmFyaWFibGVzLlxuICAgIG1lLncgPSB3O1xuICAgIG1lLlggPSBYO1xuICAgIG1lLmkgPSBpO1xuICB9XG5cbiAgaW5pdChtZSwgc2VlZCk7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmkgPSBmLmk7XG4gIHQudyA9IGYudztcbiAgdC5YID0gZi5YLnNsaWNlKCk7XG4gIHJldHVybiB0O1xufTtcblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIGlmIChzZWVkID09IG51bGwpIHNlZWQgPSArKG5ldyBEYXRlKTtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuWCkgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcjQwOTYgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2luZG93IG9iamVjdCBvciBnbG9iYWxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yc2hpZnQ3XCIgYWxnb3JpdGhtIGJ5XG4vLyBGcmFuw6dvaXMgUGFubmV0b24gYW5kIFBpZXJyZSBMJ2VjdXllcjpcbi8vIFwiT24gdGhlIFhvcmdzaGlmdCBSYW5kb20gTnVtYmVyIEdlbmVyYXRvcnNcIlxuLy8gaHR0cDovL3NhbHVjLmVuZ3IudWNvbm4uZWR1L3JlZnMvY3J5cHRvL3JuZy9wYW5uZXRvbjA1b250aGV4b3JzaGlmdC5wZGZcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVXBkYXRlIHhvciBnZW5lcmF0b3IuXG4gICAgdmFyIFggPSBtZS54LCBpID0gbWUuaSwgdCwgdiwgdztcbiAgICB0ID0gWFtpXTsgdCBePSAodCA+Pj4gNyk7IHYgPSB0IF4gKHQgPDwgMjQpO1xuICAgIHQgPSBYWyhpICsgMSkgJiA3XTsgdiBePSB0IF4gKHQgPj4+IDEwKTtcbiAgICB0ID0gWFsoaSArIDMpICYgN107IHYgXj0gdCBeICh0ID4+PiAzKTtcbiAgICB0ID0gWFsoaSArIDQpICYgN107IHYgXj0gdCBeICh0IDw8IDcpO1xuICAgIHQgPSBYWyhpICsgNykgJiA3XTsgdCA9IHQgXiAodCA8PCAxMyk7IHYgXj0gdCBeICh0IDw8IDkpO1xuICAgIFhbaV0gPSB2O1xuICAgIG1lLmkgPSAoaSArIDEpICYgNztcbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIGosIHcsIFggPSBbXTtcblxuICAgIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgICAvLyBTZWVkIHN0YXRlIGFycmF5IHVzaW5nIGEgMzItYml0IGludGVnZXIuXG4gICAgICB3ID0gWFswXSA9IHNlZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlZWQgc3RhdGUgdXNpbmcgYSBzdHJpbmcuXG4gICAgICBzZWVkID0gJycgKyBzZWVkO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHNlZWQubGVuZ3RoOyArK2opIHtcbiAgICAgICAgWFtqICYgN10gPSAoWFtqICYgN10gPDwgMTUpIF5cbiAgICAgICAgICAgIChzZWVkLmNoYXJDb2RlQXQoaikgKyBYWyhqICsgMSkgJiA3XSA8PCAxMyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEVuZm9yY2UgYW4gYXJyYXkgbGVuZ3RoIG9mIDgsIG5vdCBhbGwgemVyb2VzLlxuICAgIHdoaWxlIChYLmxlbmd0aCA8IDgpIFgucHVzaCgwKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgOCAmJiBYW2pdID09PSAwOyArK2opO1xuICAgIGlmIChqID09IDgpIHcgPSBYWzddID0gLTE7IGVsc2UgdyA9IFhbal07XG5cbiAgICBtZS54ID0gWDtcbiAgICBtZS5pID0gMDtcblxuICAgIC8vIERpc2NhcmQgYW4gaW5pdGlhbCAyNTYgdmFsdWVzLlxuICAgIGZvciAoaiA9IDI1NjsgaiA+IDA7IC0taikge1xuICAgICAgbWUubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIGluaXQobWUsIHNlZWQpO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54LnNsaWNlKCk7XG4gIHQuaSA9IGYuaTtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICBpZiAoc2VlZCA9PSBudWxsKSBzZWVkID0gKyhuZXcgRGF0ZSk7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLngpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3JzaGlmdDcgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3J3b3dcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gR2VvcmdlIE1hcnNhZ2xpYS4gIFNlZSBodHRwOi8vd3d3LmpzdGF0c29mdC5vcmcvdjA4L2kxNC9wYXBlclxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBzdHJzZWVkID0gJyc7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gKG1lLnggXiAobWUueCA+Pj4gMikpO1xuICAgIG1lLnggPSBtZS55OyBtZS55ID0gbWUuejsgbWUueiA9IG1lLnc7IG1lLncgPSBtZS52O1xuICAgIHJldHVybiAobWUuZCA9IChtZS5kICsgMzYyNDM3IHwgMCkpICtcbiAgICAgICAobWUudiA9IChtZS52IF4gKG1lLnYgPDwgNCkpIF4gKHQgXiAodCA8PCAxKSkpIHwgMDtcbiAgfTtcblxuICBtZS54ID0gMDtcbiAgbWUueSA9IDA7XG4gIG1lLnogPSAwO1xuICBtZS53ID0gMDtcbiAgbWUudiA9IDA7XG5cbiAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUueCA9IHNlZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgbWUueCBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIGlmIChrID09IHN0cnNlZWQubGVuZ3RoKSB7XG4gICAgICBtZS5kID0gbWUueCA8PCAxMCBeIG1lLnggPj4+IDQ7XG4gICAgfVxuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54O1xuICB0LnkgPSBmLnk7XG4gIHQueiA9IGYuejtcbiAgdC53ID0gZi53O1xuICB0LnYgPSBmLnY7XG4gIHQuZCA9IGYuZDtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yd293ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTQgRGF2aWQgQmF1LlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbklOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG5DTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcblNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4qL1xuXG4oZnVuY3Rpb24gKHBvb2wsIG1hdGgpIHtcbi8vXG4vLyBUaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgcmVsYXRlZCB0byBJRUVFIDc1NCBsaW1pdHMuXG4vL1xudmFyIGdsb2JhbCA9IHRoaXMsXG4gICAgd2lkdGggPSAyNTYsICAgICAgICAvLyBlYWNoIFJDNCBvdXRwdXQgaXMgMCA8PSB4IDwgMjU2XG4gICAgY2h1bmtzID0gNiwgICAgICAgICAvLyBhdCBsZWFzdCBzaXggUkM0IG91dHB1dHMgZm9yIGVhY2ggZG91YmxlXG4gICAgZGlnaXRzID0gNTIsICAgICAgICAvLyB0aGVyZSBhcmUgNTIgc2lnbmlmaWNhbnQgZGlnaXRzIGluIGEgZG91YmxlXG4gICAgcm5nbmFtZSA9ICdyYW5kb20nLCAvLyBybmduYW1lOiBuYW1lIGZvciBNYXRoLnJhbmRvbSBhbmQgTWF0aC5zZWVkcmFuZG9tXG4gICAgc3RhcnRkZW5vbSA9IG1hdGgucG93KHdpZHRoLCBjaHVua3MpLFxuICAgIHNpZ25pZmljYW5jZSA9IG1hdGgucG93KDIsIGRpZ2l0cyksXG4gICAgb3ZlcmZsb3cgPSBzaWduaWZpY2FuY2UgKiAyLFxuICAgIG1hc2sgPSB3aWR0aCAtIDEsXG4gICAgbm9kZWNyeXB0bzsgICAgICAgICAvLyBub2RlLmpzIGNyeXB0byBtb2R1bGUsIGluaXRpYWxpemVkIGF0IHRoZSBib3R0b20uXG5cbi8vXG4vLyBzZWVkcmFuZG9tKClcbi8vIFRoaXMgaXMgdGhlIHNlZWRyYW5kb20gZnVuY3Rpb24gZGVzY3JpYmVkIGFib3ZlLlxuLy9cbmZ1bmN0aW9uIHNlZWRyYW5kb20oc2VlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIGtleSA9IFtdO1xuICBvcHRpb25zID0gKG9wdGlvbnMgPT0gdHJ1ZSkgPyB7IGVudHJvcHk6IHRydWUgfSA6IChvcHRpb25zIHx8IHt9KTtcblxuICAvLyBGbGF0dGVuIHRoZSBzZWVkIHN0cmluZyBvciBidWlsZCBvbmUgZnJvbSBsb2NhbCBlbnRyb3B5IGlmIG5lZWRlZC5cbiAgdmFyIHNob3J0c2VlZCA9IG1peGtleShmbGF0dGVuKFxuICAgIG9wdGlvbnMuZW50cm9weSA/IFtzZWVkLCB0b3N0cmluZyhwb29sKV0gOlxuICAgIChzZWVkID09IG51bGwpID8gYXV0b3NlZWQoKSA6IHNlZWQsIDMpLCBrZXkpO1xuXG4gIC8vIFVzZSB0aGUgc2VlZCB0byBpbml0aWFsaXplIGFuIEFSQzQgZ2VuZXJhdG9yLlxuICB2YXIgYXJjNCA9IG5ldyBBUkM0KGtleSk7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgcmFuZG9tIGRvdWJsZSBpbiBbMCwgMSkgdGhhdCBjb250YWluc1xuICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxuICB2YXIgcHJuZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyksICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxuICAgICAgICBkID0gc3RhcnRkZW5vbSwgICAgICAgICAgICAgICAgIC8vICAgYW5kIGRlbm9taW5hdG9yIGQgPSAyIF4gNDguXG4gICAgICAgIHggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBhbmQgbm8gJ2V4dHJhIGxhc3QgYnl0ZScuXG4gICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHsgICAgICAgICAgLy8gRmlsbCB1cCBhbGwgc2lnbmlmaWNhbnQgZGlnaXRzIGJ5XG4gICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAgICAgICAgICAgICAgLy8gICBzaGlmdGluZyBudW1lcmF0b3IgYW5kXG4gICAgICBkICo9IHdpZHRoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkZW5vbWluYXRvciBhbmQgZ2VuZXJhdGluZyBhXG4gICAgICB4ID0gYXJjNC5nKDEpOyAgICAgICAgICAgICAgICAgICAgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cbiAgICB9XG4gICAgd2hpbGUgKG4gPj0gb3ZlcmZsb3cpIHsgICAgICAgICAgICAgLy8gVG8gYXZvaWQgcm91bmRpbmcgdXAsIGJlZm9yZSBhZGRpbmdcbiAgICAgIG4gLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGxhc3QgYnl0ZSwgc2hpZnQgZXZlcnl0aGluZ1xuICAgICAgZCAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgcmlnaHQgdXNpbmcgaW50ZWdlciBtYXRoIHVudGlsXG4gICAgICB4ID4+Pj0gMTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICB3ZSBoYXZlIGV4YWN0bHkgdGhlIGRlc2lyZWQgYml0cy5cbiAgICB9XG4gICAgcmV0dXJuIChuICsgeCkgLyBkOyAgICAgICAgICAgICAgICAgLy8gRm9ybSB0aGUgbnVtYmVyIHdpdGhpbiBbMCwgMSkuXG4gIH07XG5cbiAgcHJuZy5pbnQzMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIHwgMDsgfVxuICBwcm5nLnF1aWNrID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgLyAweDEwMDAwMDAwMDsgfVxuICBwcm5nLmRvdWJsZSA9IHBybmc7XG5cbiAgLy8gTWl4IHRoZSByYW5kb21uZXNzIGludG8gYWNjdW11bGF0ZWQgZW50cm9weS5cbiAgbWl4a2V5KHRvc3RyaW5nKGFyYzQuUyksIHBvb2wpO1xuXG4gIC8vIENhbGxpbmcgY29udmVudGlvbjogd2hhdCB0byByZXR1cm4gYXMgYSBmdW5jdGlvbiBvZiBwcm5nLCBzZWVkLCBpc19tYXRoLlxuICByZXR1cm4gKG9wdGlvbnMucGFzcyB8fCBjYWxsYmFjayB8fFxuICAgICAgZnVuY3Rpb24ocHJuZywgc2VlZCwgaXNfbWF0aF9jYWxsLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAvLyBMb2FkIHRoZSBhcmM0IHN0YXRlIGZyb20gdGhlIGdpdmVuIHN0YXRlIGlmIGl0IGhhcyBhbiBTIGFycmF5LlxuICAgICAgICAgIGlmIChzdGF0ZS5TKSB7IGNvcHkoc3RhdGUsIGFyYzQpOyB9XG4gICAgICAgICAgLy8gT25seSBwcm92aWRlIHRoZSAuc3RhdGUgbWV0aG9kIGlmIHJlcXVlc3RlZCB2aWEgb3B0aW9ucy5zdGF0ZS5cbiAgICAgICAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KGFyYzQsIHt9KTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgY2FsbGVkIGFzIGEgbWV0aG9kIG9mIE1hdGggKE1hdGguc2VlZHJhbmRvbSgpKSwgbXV0YXRlXG4gICAgICAgIC8vIE1hdGgucmFuZG9tIGJlY2F1c2UgdGhhdCBpcyBob3cgc2VlZHJhbmRvbS5qcyBoYXMgd29ya2VkIHNpbmNlIHYxLjAuXG4gICAgICAgIGlmIChpc19tYXRoX2NhbGwpIHsgbWF0aFtybmduYW1lXSA9IHBybmc7IHJldHVybiBzZWVkOyB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCBpcyBhIG5ld2VyIGNhbGxpbmcgY29udmVudGlvbiwgc28gcmV0dXJuIHRoZVxuICAgICAgICAvLyBwcm5nIGRpcmVjdGx5LlxuICAgICAgICBlbHNlIHJldHVybiBwcm5nO1xuICAgICAgfSkoXG4gIHBybmcsXG4gIHNob3J0c2VlZCxcbiAgJ2dsb2JhbCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZ2xvYmFsIDogKHRoaXMgPT0gbWF0aCksXG4gIG9wdGlvbnMuc3RhdGUpO1xufVxubWF0aFsnc2VlZCcgKyBybmduYW1lXSA9IHNlZWRyYW5kb207XG5cbi8vXG4vLyBBUkM0XG4vL1xuLy8gQW4gQVJDNCBpbXBsZW1lbnRhdGlvbi4gIFRoZSBjb25zdHJ1Y3RvciB0YWtlcyBhIGtleSBpbiB0aGUgZm9ybSBvZlxuLy8gYW4gYXJyYXkgb2YgYXQgbW9zdCAod2lkdGgpIGludGVnZXJzIHRoYXQgc2hvdWxkIGJlIDAgPD0geCA8ICh3aWR0aCkuXG4vL1xuLy8gVGhlIGcoY291bnQpIG1ldGhvZCByZXR1cm5zIGEgcHNldWRvcmFuZG9tIGludGVnZXIgdGhhdCBjb25jYXRlbmF0ZXNcbi8vIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBmcm9tIEFSQzQuICBJdHMgcmV0dXJuIHZhbHVlIGlzIGEgbnVtYmVyIHhcbi8vIHRoYXQgaXMgaW4gdGhlIHJhbmdlIDAgPD0geCA8ICh3aWR0aCBeIGNvdW50KS5cbi8vXG5mdW5jdGlvbiBBUkM0KGtleSkge1xuICB2YXIgdCwga2V5bGVuID0ga2V5Lmxlbmd0aCxcbiAgICAgIG1lID0gdGhpcywgaSA9IDAsIGogPSBtZS5pID0gbWUuaiA9IDAsIHMgPSBtZS5TID0gW107XG5cbiAgLy8gVGhlIGVtcHR5IGtleSBbXSBpcyB0cmVhdGVkIGFzIFswXS5cbiAgaWYgKCFrZXlsZW4pIHsga2V5ID0gW2tleWxlbisrXTsgfVxuXG4gIC8vIFNldCB1cCBTIHVzaW5nIHRoZSBzdGFuZGFyZCBrZXkgc2NoZWR1bGluZyBhbGdvcml0aG0uXG4gIHdoaWxlIChpIDwgd2lkdGgpIHtcbiAgICBzW2ldID0gaSsrO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIGtleVtpICUga2V5bGVuXSArICh0ID0gc1tpXSkpXTtcbiAgICBzW2pdID0gdDtcbiAgfVxuXG4gIC8vIFRoZSBcImdcIiBtZXRob2QgcmV0dXJucyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgYXMgb25lIG51bWJlci5cbiAgKG1lLmcgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIC8vIFVzaW5nIGluc3RhbmNlIG1lbWJlcnMgaW5zdGVhZCBvZiBjbG9zdXJlIHN0YXRlIG5lYXJseSBkb3VibGVzIHNwZWVkLlxuICAgIHZhciB0LCByID0gMCxcbiAgICAgICAgaSA9IG1lLmksIGogPSBtZS5qLCBzID0gbWUuUztcbiAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgdCA9IHNbaSA9IG1hc2sgJiAoaSArIDEpXTtcbiAgICAgIHIgPSByICogd2lkdGggKyBzW21hc2sgJiAoKHNbaV0gPSBzW2ogPSBtYXNrICYgKGogKyB0KV0pICsgKHNbal0gPSB0KSldO1xuICAgIH1cbiAgICBtZS5pID0gaTsgbWUuaiA9IGo7XG4gICAgcmV0dXJuIHI7XG4gICAgLy8gRm9yIHJvYnVzdCB1bnByZWRpY3RhYmlsaXR5LCB0aGUgZnVuY3Rpb24gY2FsbCBiZWxvdyBhdXRvbWF0aWNhbGx5XG4gICAgLy8gZGlzY2FyZHMgYW4gaW5pdGlhbCBiYXRjaCBvZiB2YWx1ZXMuICBUaGlzIGlzIGNhbGxlZCBSQzQtZHJvcFsyNTZdLlxuICAgIC8vIFNlZSBodHRwOi8vZ29vZ2xlLmNvbS9zZWFyY2g/cT1yc2ErZmx1aHJlcityZXNwb25zZSZidG5JXG4gIH0pKHdpZHRoKTtcbn1cblxuLy9cbi8vIGNvcHkoKVxuLy8gQ29waWVzIGludGVybmFsIHN0YXRlIG9mIEFSQzQgdG8gb3IgZnJvbSBhIHBsYWluIG9iamVjdC5cbi8vXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5pID0gZi5pO1xuICB0LmogPSBmLmo7XG4gIHQuUyA9IGYuUy5zbGljZSgpO1xuICByZXR1cm4gdDtcbn07XG5cbi8vXG4vLyBmbGF0dGVuKClcbi8vIENvbnZlcnRzIGFuIG9iamVjdCB0cmVlIHRvIG5lc3RlZCBhcnJheXMgb2Ygc3RyaW5ncy5cbi8vXG5mdW5jdGlvbiBmbGF0dGVuKG9iaiwgZGVwdGgpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLCB0eXAgPSAodHlwZW9mIG9iaiksIHByb3A7XG4gIGlmIChkZXB0aCAmJiB0eXAgPT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgICB0cnkgeyByZXN1bHQucHVzaChmbGF0dGVuKG9ialtwcm9wXSwgZGVwdGggLSAxKSk7IH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICB9XG4gIHJldHVybiAocmVzdWx0Lmxlbmd0aCA/IHJlc3VsdCA6IHR5cCA9PSAnc3RyaW5nJyA/IG9iaiA6IG9iaiArICdcXDAnKTtcbn1cblxuLy9cbi8vIG1peGtleSgpXG4vLyBNaXhlcyBhIHN0cmluZyBzZWVkIGludG8gYSBrZXkgdGhhdCBpcyBhbiBhcnJheSBvZiBpbnRlZ2VycywgYW5kXG4vLyByZXR1cm5zIGEgc2hvcnRlbmVkIHN0cmluZyBzZWVkIHRoYXQgaXMgZXF1aXZhbGVudCB0byB0aGUgcmVzdWx0IGtleS5cbi8vXG5mdW5jdGlvbiBtaXhrZXkoc2VlZCwga2V5KSB7XG4gIHZhciBzdHJpbmdzZWVkID0gc2VlZCArICcnLCBzbWVhciwgaiA9IDA7XG4gIHdoaWxlIChqIDwgc3RyaW5nc2VlZC5sZW5ndGgpIHtcbiAgICBrZXlbbWFzayAmIGpdID1cbiAgICAgIG1hc2sgJiAoKHNtZWFyIF49IGtleVttYXNrICYgal0gKiAxOSkgKyBzdHJpbmdzZWVkLmNoYXJDb2RlQXQoaisrKSk7XG4gIH1cbiAgcmV0dXJuIHRvc3RyaW5nKGtleSk7XG59XG5cbi8vXG4vLyBhdXRvc2VlZCgpXG4vLyBSZXR1cm5zIGFuIG9iamVjdCBmb3IgYXV0b3NlZWRpbmcsIHVzaW5nIHdpbmRvdy5jcnlwdG8gYW5kIE5vZGUgY3J5cHRvXG4vLyBtb2R1bGUgaWYgYXZhaWxhYmxlLlxuLy9cbmZ1bmN0aW9uIGF1dG9zZWVkKCkge1xuICB0cnkge1xuICAgIHZhciBvdXQ7XG4gICAgaWYgKG5vZGVjcnlwdG8gJiYgKG91dCA9IG5vZGVjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XG4gICAgICAvLyBUaGUgdXNlIG9mICdvdXQnIHRvIHJlbWVtYmVyIHJhbmRvbUJ5dGVzIG1ha2VzIHRpZ2h0IG1pbmlmaWVkIGNvZGUuXG4gICAgICBvdXQgPSBvdXQod2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBuZXcgVWludDhBcnJheSh3aWR0aCk7XG4gICAgICAoZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG8pLmdldFJhbmRvbVZhbHVlcyhvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9zdHJpbmcob3V0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBicm93c2VyID0gZ2xvYmFsLm5hdmlnYXRvcixcbiAgICAgICAgcGx1Z2lucyA9IGJyb3dzZXIgJiYgYnJvd3Nlci5wbHVnaW5zO1xuICAgIHJldHVybiBbK25ldyBEYXRlLCBnbG9iYWwsIHBsdWdpbnMsIGdsb2JhbC5zY3JlZW4sIHRvc3RyaW5nKHBvb2wpXTtcbiAgfVxufVxuXG4vL1xuLy8gdG9zdHJpbmcoKVxuLy8gQ29udmVydHMgYW4gYXJyYXkgb2YgY2hhcmNvZGVzIHRvIGEgc3RyaW5nXG4vL1xuZnVuY3Rpb24gdG9zdHJpbmcoYSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSgwLCBhKTtcbn1cblxuLy9cbi8vIFdoZW4gc2VlZHJhbmRvbS5qcyBpcyBsb2FkZWQsIHdlIGltbWVkaWF0ZWx5IG1peCBhIGZldyBiaXRzXG4vLyBmcm9tIHRoZSBidWlsdC1pbiBSTkcgaW50byB0aGUgZW50cm9weSBwb29sLiAgQmVjYXVzZSB3ZSBkb1xuLy8gbm90IHdhbnQgdG8gaW50ZXJmZXJlIHdpdGggZGV0ZXJtaW5pc3RpYyBQUk5HIHN0YXRlIGxhdGVyLFxuLy8gc2VlZHJhbmRvbSB3aWxsIG5vdCBjYWxsIG1hdGgucmFuZG9tIG9uIGl0cyBvd24gYWdhaW4gYWZ0ZXJcbi8vIGluaXRpYWxpemF0aW9uLlxuLy9cbm1peGtleShtYXRoLnJhbmRvbSgpLCBwb29sKTtcblxuLy9cbi8vIE5vZGVqcyBhbmQgQU1EIHN1cHBvcnQ6IGV4cG9ydCB0aGUgaW1wbGVtZW50YXRpb24gYXMgYSBtb2R1bGUgdXNpbmdcbi8vIGVpdGhlciBjb252ZW50aW9uLlxuLy9cbmlmICgodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBzZWVkcmFuZG9tO1xuICAvLyBXaGVuIGluIG5vZGUuanMsIHRyeSB1c2luZyBjcnlwdG8gcGFja2FnZSBmb3IgYXV0b3NlZWRpbmcuXG4gIHRyeSB7XG4gICAgbm9kZWNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICB9IGNhdGNoIChleCkge31cbn0gZWxzZSBpZiAoKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBzZWVkcmFuZG9tOyB9KTtcbn1cblxuLy8gRW5kIGFub255bW91cyBzY29wZSwgYW5kIHBhc3MgaW5pdGlhbCB2YWx1ZXMuXG59KShcbiAgW10sICAgICAvLyBwb29sOiBlbnRyb3B5IHBvb2wgc3RhcnRzIGVtcHR5XG4gIE1hdGggICAgLy8gbWF0aDogcGFja2FnZSBjb250YWluaW5nIHJhbmRvbSwgcG93LCBhbmQgc2VlZHJhbmRvbVxuKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGRlZXBsZWFybl8xID0gcmVxdWlyZShcImRlZXBsZWFyblwiKTtcbnZhciBHT09HTEVfQ0xPVURfU1RPUkFHRV9ESVIgPSBcbi8vICAnaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL2xlYXJuanMtZGF0YS9jaGVja3BvaW50X3pvby90cmFuc2Zvcm1uZXQvJztcbmRvY3VtZW50LlVSTC5zdWJzdHIoMCwgZG9jdW1lbnQuVVJMLmxhc3RJbmRleE9mKCcvJykpICsgJy9ja3B0cy8nO1xudmFyIFRyYW5zZm9ybU5ldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtTmV0KG1hdGgsIHN0eWxlKSB7XG4gICAgICAgIHRoaXMubWF0aCA9IG1hdGg7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgdGhpcy52YXJpYWJsZURpY3Rpb25hcnkgPSB7fTtcbiAgICAgICAgdGhpcy50aW1lc1NjYWxhciA9IGRlZXBsZWFybl8xLlNjYWxhcltcIm5ld1wiXSgxNTApO1xuICAgICAgICB0aGlzLnBsdXNTY2FsYXIgPSBkZWVwbGVhcm5fMS5TY2FsYXJbXCJuZXdcIl0oMjU1LiAvIDIpO1xuICAgICAgICB0aGlzLmVwc2lsb25TY2FsYXIgPSBkZWVwbGVhcm5fMS5TY2FsYXJbXCJuZXdcIl0oMWUtMyk7XG4gICAgfVxuICAgIFRyYW5zZm9ybU5ldC5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9hZHMgbmVjZXNzYXJ5IHZhcmlhYmxlcyBmb3IgU3F1ZWV6ZU5ldC4gUmVzb2x2ZXMgdGhlIHByb21pc2Ugd2hlbiB0aGVcbiAgICAgKiB2YXJpYWJsZXMgaGF2ZSBhbGwgYmVlbiBsb2FkZWQuXG4gICAgICovXG4gICAgVHJhbnNmb3JtTmV0LnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hlY2twb2ludExvYWRlciwgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy52YXJpYWJsZURpY3Rpb25hcnlbdGhpcy5zdHlsZV0gPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludExvYWRlciA9IG5ldyBkZWVwbGVhcm5fMS5DaGVja3BvaW50TG9hZGVyKEdPT0dMRV9DTE9VRF9TVE9SQUdFX0RJUiArIHRoaXMuc3R5bGUgKyAnLycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLnZhcmlhYmxlRGljdGlvbmFyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNoZWNrcG9pbnRMb2FkZXIuZ2V0QWxsVmFyaWFibGVzKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYVtfYl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMgPSB0aGlzLnZhcmlhYmxlRGljdGlvbmFyeVt0aGlzLnN0eWxlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbmZlciB0aHJvdWdoIFRyYW5zZm9ybU5ldCwgYXNzdW1lcyB2YXJpYWJsZXMgaGF2ZSBiZWVuIGxvYWRlZC5cbiAgICAgKiBPcmlnaW5hbCBUZW5zb3JmbG93IHZlcnNpb24gb2YgbW9kZWwgY2FuIGJlIGZvdW5kIGF0XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2xlbmdzdHJvbS9mYXN0LXN0eWxlLXRyYW5zZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJlcHJvY2Vzc2VkSW5wdXQgcHJlcHJvY2Vzc2VkIGlucHV0IEFycmF5LlxuICAgICAqIEByZXR1cm4gQXJyYXkzRCBjb250YWluaW5nIHBpeGVscyBvZiBvdXRwdXQgaW1nXG4gICAgICovXG4gICAgVHJhbnNmb3JtTmV0LnByb3RvdHlwZS5wcmVkaWN0ID0gZnVuY3Rpb24gKHByZXByb2Nlc3NlZElucHV0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaW1nO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGltZyA9IHRoaXMubWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCwgdHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnYxID0gX3RoaXMuY29udkxheWVyKHByZXByb2Nlc3NlZElucHV0LCAxLCB0cnVlLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnYyID0gX3RoaXMuY29udkxheWVyKGNvbnYxLCAyLCB0cnVlLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnYzID0gX3RoaXMuY29udkxheWVyKGNvbnYyLCAyLCB0cnVlLCA2KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2lkMSA9IF90aGlzLnJlc2lkdWFsQmxvY2soY29udjMsIDkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzaWQyID0gX3RoaXMucmVzaWR1YWxCbG9jayhyZXNpZDEsIDE1KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2lkMyA9IF90aGlzLnJlc2lkdWFsQmxvY2socmVzaWQyLCAyMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNpZDQgPSBfdGhpcy5yZXNpZHVhbEJsb2NrKHJlc2lkMywgMjcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzaWQ1ID0gX3RoaXMucmVzaWR1YWxCbG9jayhyZXNpZDQsIDMzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnZUMSA9IF90aGlzLmNvbnZUcmFuc3Bvc2VMYXllcihyZXNpZDUsIDY0LCAyLCAzOSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb252VDIgPSBfdGhpcy5jb252VHJhbnNwb3NlTGF5ZXIoY29udlQxLCAzMiwgMiwgNDIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udlQzID0gX3RoaXMuY29udkxheWVyKGNvbnZUMiwgMSwgZmFsc2UsIDQ1KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dFRhbmggPSBfdGhpcy5tYXRoLnRhbmgoY29udlQzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlZCA9IF90aGlzLm1hdGguc2NhbGFyVGltZXNBcnJheShfdGhpcy50aW1lc1NjYWxhciwgb3V0VGFuaCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaGlmdGVkID0gX3RoaXMubWF0aC5zY2FsYXJQbHVzQXJyYXkoX3RoaXMucGx1c1NjYWxhciwgc2NhbGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYW1wZWQgPSBfdGhpcy5tYXRoLmNsaXAoc2hpZnRlZCwgMCwgMjU1KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBfdGhpcy5tYXRoLmRpdmlkZShjbGFtcGVkLCBkZWVwbGVhcm5fMS5TY2FsYXJbXCJuZXdcIl0oMjU1LikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgaW1nXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRyYW5zZm9ybU5ldC5wcm90b3R5cGUuY29udkxheWVyID0gZnVuY3Rpb24gKGlucHV0LCBzdHJpZGVzLCByZWx1LCB2YXJJZCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMubWF0aC5jb252MmQoaW5wdXQsIHRoaXMudmFyaWFibGVzW3RoaXMudmFyTmFtZSh2YXJJZCldLCBudWxsLCBbc3RyaWRlcywgc3RyaWRlc10sICdzYW1lJyk7XG4gICAgICAgIHZhciB5MiA9IHRoaXMuaW5zdGFuY2VOb3JtKHksIHZhcklkICsgMSk7XG4gICAgICAgIGlmIChyZWx1KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRoLnJlbHUoeTIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5MjtcbiAgICB9O1xuICAgIFRyYW5zZm9ybU5ldC5wcm90b3R5cGUuY29udlRyYW5zcG9zZUxheWVyID0gZnVuY3Rpb24gKGlucHV0LCBudW1GaWx0ZXJzLCBzdHJpZGVzLCB2YXJJZCkge1xuICAgICAgICB2YXIgX2EgPSBpbnB1dC5zaGFwZSwgaGVpZ2h0ID0gX2FbMF0sIHdpZHRoID0gX2FbMV07XG4gICAgICAgIHZhciBuZXdSb3dzID0gaGVpZ2h0ICogc3RyaWRlcztcbiAgICAgICAgdmFyIG5ld0NvbHMgPSB3aWR0aCAqIHN0cmlkZXM7XG4gICAgICAgIHZhciBuZXdTaGFwZSA9IFtuZXdSb3dzLCBuZXdDb2xzLCBudW1GaWx0ZXJzXTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLm1hdGguY29udjJkVHJhbnNwb3NlKGlucHV0LCB0aGlzLnZhcmlhYmxlc1t0aGlzLnZhck5hbWUodmFySWQpXSwgbmV3U2hhcGUsIFtzdHJpZGVzLCBzdHJpZGVzXSwgJ3NhbWUnKTtcbiAgICAgICAgdmFyIHkyID0gdGhpcy5pbnN0YW5jZU5vcm0oeSwgdmFySWQgKyAxKTtcbiAgICAgICAgdmFyIHkzID0gdGhpcy5tYXRoLnJlbHUoeTIpO1xuICAgICAgICByZXR1cm4geTM7XG4gICAgfTtcbiAgICBUcmFuc2Zvcm1OZXQucHJvdG90eXBlLnJlc2lkdWFsQmxvY2sgPSBmdW5jdGlvbiAoaW5wdXQsIHZhcklkKSB7XG4gICAgICAgIHZhciBjb252MSA9IHRoaXMuY29udkxheWVyKGlucHV0LCAxLCB0cnVlLCB2YXJJZCk7XG4gICAgICAgIHZhciBjb252MiA9IHRoaXMuY29udkxheWVyKGNvbnYxLCAxLCBmYWxzZSwgdmFySWQgKyAzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0aC5hZGRTdHJpY3QoY29udjIsIGlucHV0KTtcbiAgICB9O1xuICAgIFRyYW5zZm9ybU5ldC5wcm90b3R5cGUuaW5zdGFuY2VOb3JtID0gZnVuY3Rpb24gKGlucHV0LCB2YXJJZCkge1xuICAgICAgICB2YXIgX2EgPSBpbnB1dC5zaGFwZSwgaGVpZ2h0ID0gX2FbMF0sIHdpZHRoID0gX2FbMV0sIGluRGVwdGggPSBfYVsyXTtcbiAgICAgICAgdmFyIG1vbWVudHMgPSB0aGlzLm1hdGgubW9tZW50cyhpbnB1dCwgWzAsIDFdKTtcbiAgICAgICAgdmFyIG11ID0gbW9tZW50cy5tZWFuO1xuICAgICAgICB2YXIgc2lnbWFTcSA9IG1vbWVudHMudmFyaWFuY2U7XG4gICAgICAgIHZhciBzaGlmdCA9IHRoaXMudmFyaWFibGVzW3RoaXMudmFyTmFtZSh2YXJJZCldO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnZhcmlhYmxlc1t0aGlzLnZhck5hbWUodmFySWQgKyAxKV07XG4gICAgICAgIHZhciBlcHNpbG9uID0gdGhpcy5lcHNpbG9uU2NhbGFyO1xuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IHRoaXMubWF0aC5kaXZpZGUodGhpcy5tYXRoLnN1YihpbnB1dCwgbXUpLCB0aGlzLm1hdGguc3FydCh0aGlzLm1hdGguYWRkKHNpZ21hU3EsIGVwc2lsb24pKSk7XG4gICAgICAgIHZhciBzaGlmdGVkID0gdGhpcy5tYXRoLmFkZCh0aGlzLm1hdGgubXVsdGlwbHkoc2NhbGUsIG5vcm1hbGl6ZWQpLCBzaGlmdCk7XG4gICAgICAgIHJldHVybiBzaGlmdGVkLmFzM0QoaGVpZ2h0LCB3aWR0aCwgaW5EZXB0aCk7XG4gICAgfTtcbiAgICBUcmFuc2Zvcm1OZXQucHJvdG90eXBlLnZhck5hbWUgPSBmdW5jdGlvbiAodmFySWQpIHtcbiAgICAgICAgaWYgKHZhcklkID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1ZhcmlhYmxlJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnVmFyaWFibGVfJyArIHZhcklkLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zZm9ybU5ldC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHRoaXMudmFyaWFibGVEaWN0aW9uYXJ5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciB2YXJOYW1lIGluIHRoaXMudmFyaWFibGVEaWN0aW9uYXJ5W3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlRGljdGlvbmFyeVtzdHlsZU5hbWVdW3Zhck5hbWVdLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zZm9ybU5ldDtcbn0oKSk7XG5leHBvcnRzLlRyYW5zZm9ybU5ldCA9IFRyYW5zZm9ybU5ldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmZ1bmN0aW9uIFBvbHltZXJFbGVtZW50KHNwZWMpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgcmV0dXJuIFBvbHltZXIuQ2xhc3Moc3BlYyk7XG59XG5leHBvcnRzLlBvbHltZXJFbGVtZW50ID0gUG9seW1lckVsZW1lbnQ7XG4iLCIvLyAvLyAvLyAvLyBcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxudmFyIGRlZXBsZWFybl8xID0gcmVxdWlyZShcImRlZXBsZWFyblwiKTtcbi8vIGltcG9ydCAqIGFzIGltYWdlbmV0X3V0aWwgZnJvbSAnLi4vbW9kZWxzL2ltYWdlbmV0X3V0aWwnO1xudmFyIG5ldF8xID0gcmVxdWlyZShcIi4vbmV0XCIpO1xudmFyIHBvbHltZXJfc3BlY18xID0gcmVxdWlyZShcIi4vcG9seW1lci1zcGVjXCIpO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWVcbmV4cG9ydHMuU3R5bGVUcmFuc2ZlckRlbW9Qb2x5bWVyID0gcG9seW1lcl9zcGVjXzEuUG9seW1lckVsZW1lbnQoe1xuICAgIGlzOiAnc3R5bGV0cmFuc2Zlci1kZW1vJyxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGNvbnRlbnROYW1lczogU3RyaW5nLFxuICAgICAgICBzZWxlY3RlZENvbnRlbnROYW1lOiBTdHJpbmcsXG4gICAgICAgIHN0eWxlTmFtZXM6IEFycmF5LFxuICAgICAgICBzZWxlY3RlZFN0eWxlTmFtZTogU3RyaW5nXG4gICAgfVxufSk7XG52YXIgQXBwbGljYXRpb25TdGF0ZTtcbihmdW5jdGlvbiAoQXBwbGljYXRpb25TdGF0ZSkge1xuICAgIEFwcGxpY2F0aW9uU3RhdGVbQXBwbGljYXRpb25TdGF0ZVtcIklETEVcIl0gPSAxXSA9IFwiSURMRVwiO1xuICAgIEFwcGxpY2F0aW9uU3RhdGVbQXBwbGljYXRpb25TdGF0ZVtcIlRSQUlOSU5HXCJdID0gMl0gPSBcIlRSQUlOSU5HXCI7XG59KShBcHBsaWNhdGlvblN0YXRlID0gZXhwb3J0cy5BcHBsaWNhdGlvblN0YXRlIHx8IChleHBvcnRzLkFwcGxpY2F0aW9uU3RhdGUgPSB7fSkpO1xudmFyIENPTlRFTlRfTkFNRVMgPSAnVXBsb2FkIGZyb20gZmlsZSc7XG52YXIgU1RZTEVfTUFQUElOR1MgPSB7XG4gICAgJ1VkbmllLCBGcmFuY2lzIFBpY2FiaWEnOiAndWRuaWUnLFxuICAgICdUaGUgU2NyZWFtLCBFZHZhcmQgTXVuY2gnOiAnc2NyZWFtJyxcbiAgICAnTGEgTXVzZSwgUGFibG8gUGljYXNzbyc6ICdsYV9tdXNlJyxcbiAgICAnUmFpbiBQcmluY2VzcywgTGVvbmlkIEFmcmVtb3YnOiAncmFpbl9wcmluY2VzcycsXG4gICAgJ1RoZSBXYXZlLCBLYXRzdXNoaWthIEhva3VzYWknOiAnd2F2ZScsXG4gICAgJ1RoZSBXcmVjayBvZiB0aGUgTWlub3RhdXIsIEouTS5XLiBUdXJuZXInOiAnd3JlY2snXG59O1xudmFyIFNUWUxFX05BTUVTID0gT2JqZWN0LmtleXMoU1RZTEVfTUFQUElOR1MpO1xudmFyIFN0eWxlVHJhbnNmZXJEZW1vID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3R5bGVUcmFuc2ZlckRlbW8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3R5bGVUcmFuc2ZlckRlbW8oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU3R5bGVUcmFuc2ZlckRlbW8ucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBJbml0aWFsaXplIGRlZXBsZWFybi5qcyBzdHVmZlxuICAgICAgICB0aGlzLmNhbnZhcyA9IHRoaXMucXVlcnlTZWxlY3RvcignI2ltYWdlQ2FudmFzJyk7XG4gICAgICAgIHRoaXMuZ2wgPSBkZWVwbGVhcm5fMS5ncGdwdV91dGlsLmNyZWF0ZVdlYkdMQ29udGV4dCh0aGlzLmNhbnZhcyk7XG4gICAgICAgIHRoaXMuZ3BncHUgPSBuZXcgZGVlcGxlYXJuXzEuR1BHUFVDb250ZXh0KHRoaXMuZ2wpO1xuICAgICAgICB0aGlzLm1hdGggPSBuZXcgZGVlcGxlYXJuXzEuTkRBcnJheU1hdGhHUFUodGhpcy5ncGdwdSk7XG4gICAgICAgIHRoaXMubWF0aENQVSA9IG5ldyBkZWVwbGVhcm5fMS5OREFycmF5TWF0aENQVSgpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHBvbHltZXIgcHJvcGVydGllc1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uU3RhdGUgPSBBcHBsaWNhdGlvblN0YXRlLklETEU7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJyc7XG4gICAgICAgIC8vIFJldHJpZXZlIERPTSBmb3IgaW1hZ2VzIC0gSFRNTCBlbGVtZW50IHdhYXIgaGlqIGltZ3MgaW5wbGFhdHN0XG4gICAgICAgIHRoaXMuY29udGVudEltZ0VsZW1lbnQgPVxuICAgICAgICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yKCcjY29udGVudEltZycpO1xuICAgICAgICB0aGlzLnN0eWxlSW1nRWxlbWVudCA9XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJyNzdHlsZUltZycpO1xuICAgICAgICAvLyBSZW5kZXIgRE9NIGZvciBpbWFnZXNcbiAgICAgICAgLy8gbGlua2VyYWZiZWVsZGluZyAtIGpvdXcgZm90bywgZWVyc3RlIGZvdG8gZGllIGVyb3Agc3RhYXRcbiAgICAgICAgdGhpcy5jb250ZW50TmFtZXMgPSBDT05URU5UX05BTUVTO1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ29udGVudE5hbWUgPSAnc3RhdGEnO1xuICAgICAgICB0aGlzLmNvbnRlbnRJbWdFbGVtZW50LnNyYyA9ICdpbWFnZXMvc3RhdGEuanBnJztcbiAgICAgICAgdGhpcy5jb250ZW50SW1nRWxlbWVudC5oZWlnaHQgPSAyNTA7XG4gICAgICAgIC8vIHJlY2h0ZXJhZmJlZWxkaW5nIC0gc3R5bGUgKGVlcnN0ZSBzdGlqbGFmYmVlbGRpbmcpXG4gICAgICAgIHRoaXMuc3R5bGVOYW1lcyA9IFNUWUxFX05BTUVTO1xuICAgICAgICB0aGlzLnNlbGVjdGVkU3R5bGVOYW1lID0gJ1VkbmllLCBGcmFuY2lzIFBpY2FiaWEnO1xuICAgICAgICB0aGlzLnN0eWxlSW1nRWxlbWVudC5zcmMgPSAnaW1hZ2VzL3VkbmllLmpwZyc7XG4gICAgICAgIHRoaXMuc3R5bGVJbWdFbGVtZW50LmhlaWdodCA9IDI1MDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1OZXQgPSBuZXcgbmV0XzEuVHJhbnNmb3JtTmV0KHRoaXMubWF0aCwgU1RZTEVfTUFQUElOR1NbdGhpcy5zZWxlY3RlZFN0eWxlTmFtZV0pO1xuICAgICAgICAvL3RoaXMuaW5pdFdlYmNhbVZhcmlhYmxlcygpO1xuICAgICAgICAvLyBTTElERVIgVk9PUiBERSBHUk9PVFRFIFZBTiBERSBJTUcgQUFOIFRFIFBBU1NFTlxuICAgICAgICAvLyAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgIC8vIHRoaXMuc2l6ZVNsaWRlciA9IHRoaXMucXVlcnlTZWxlY3RvcignI3NpemVTbGlkZXInKSBhcyBhbnk7XG4gICAgICAgIC8vIHRoaXMuc2l6ZVNsaWRlci5hZGRFdmVudExpc3RlbmVyKCdpbW1lZGlhdGUtdmFsdWUtY2hhbmdlJyxcbiAgICAgICAgLy8gLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAvLyAgIChldmVudDogYW55KSA9PiB7XG4gICAgICAgIC8vICAgdGhpcy5zdHlsZUltZ0VsZW1lbnQuaGVpZ2h0ID0gdGhpcy5zaXplU2xpZGVyLmltbWVkaWF0ZVZhbHVlO1xuICAgICAgICAvLyAgIHRoaXMuY29udGVudEltZ0VsZW1lbnQuaGVpZ2h0ID0gdGhpcy5zaXplU2xpZGVyLmltbWVkaWF0ZVZhbHVlO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICAvLyB0aGlzLnNpemVTbGlkZXIuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGV2ZW50OiBhbnkpID0+IHtcbiAgICAgICAgLy8gICB0aGlzLnN0eWxlSW1nRWxlbWVudC5oZWlnaHQgPSB0aGlzLnNpemVTbGlkZXIuaW1tZWRpYXRlVmFsdWU7XG4gICAgICAgIC8vICAgdGhpcy5jb250ZW50SW1nRWxlbWVudC5oZWlnaHQgPSB0aGlzLnNpemVTbGlkZXIuaW1tZWRpYXRlVmFsdWU7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvL0hFVCBTRUxFQ1RFUkVOIEVOIFVQTE9BREVOIFZBTiBERSBJTUFHRVxuICAgICAgICB0aGlzLmZpbGVTZWxlY3QgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJyNmaWxlU2VsZWN0Jyk7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgdGhpcy5maWxlU2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGYgPSBldmVudC50YXJnZXQuZmlsZXNbMF07XG4gICAgICAgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250ZW50SW1nRWxlbWVudC5zcmMgPSB0YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoZik7XG4gICAgICAgICAgICBfdGhpcy5maWxlU2VsZWN0LnZhbHVlID0gJyc7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBZGQgbGlzdGVuZXIgdG8gZHJvcCBkb3duc1xuICAgICAgICAvLyBjb25zdCBjb250ZW50RHJvcGRvd24gPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJyNjb250ZW50LWRyb3Bkb3duJyk7XG4gICAgICAgIC8vIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgLy8gY29udGVudERyb3Bkb3duLmFkZEV2ZW50TGlzdGVuZXIoJ2lyb24tYWN0aXZhdGUnLCAoZXZlbnQ6IGFueSkgPT4ge1xuICAgICAgICAvLyAgIGNvbnN0IHNlbGVjdGVkOiBzdHJpbmcgPSBldmVudC5kZXRhaWwuc2VsZWN0ZWQgYXMgc3RyaW5nO1xuICAgICAgICAvLyAgIC8vIGlmIChzZWxlY3RlZCA9PT0gJ1VzZSB3ZWJjYW0nKSB7XG4gICAgICAgIC8vICAgLy8gICB0aGlzLm9wZW5XZWJjYW1Nb2RhbCgpO1xuICAgICAgICAvLyAgIC8vIH1cbiAgICAgICAgLy8gICBpZiAoc2VsZWN0ZWQgPT09ICdVcGxvYWQgZnJvbSBmaWxlJykge1xuICAgICAgICAvLyAgICAgdGhpcy5maWxlU2VsZWN0LmNsaWNrKCk7XG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyAgIGVsc2Uge1xuICAgICAgICAvLyAgICAgdGhpcy5jb250ZW50SW1nRWxlbWVudC5zcmMgPSAnaW1hZ2VzLycgKyBzZWxlY3RlZCArICcuanBnJztcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vIH0pO1xuICAgICAgICB2YXIgZmlsZVNlbGVjdEJ1dHRvbiA9IHRoaXMucXVlcnlTZWxlY3RvcignI2ZpbGUtdXBsb2FkJyk7XG4gICAgICAgIGZpbGVTZWxlY3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLmZpbGVTZWxlY3QuY2xpY2soKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzdHlsZURyb3Bkb3duID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcjc3R5bGUtZHJvcGRvd24nKTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICBzdHlsZURyb3Bkb3duLmFkZEV2ZW50TGlzdGVuZXIoJ2lyb24tYWN0aXZhdGUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLnN0eWxlSW1nRWxlbWVudC5zcmMgPVxuICAgICAgICAgICAgICAgICdpbWFnZXMvJyArIFNUWUxFX01BUFBJTkdTW2V2ZW50LmRldGFpbC5zZWxlY3RlZF0gKyAnLmpwZyc7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBZGQgbGlzdGVuZXIgdG8gc3RhcnRcbiAgICAgICAgdGhpcy5zdGFydEJ1dHRvbiA9IHRoaXMucXVlcnlTZWxlY3RvcignI3N0YXJ0Jyk7XG4gICAgICAgIHRoaXMuc3RhcnRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY2xpY2snKTtcbiAgICAgICAgICAgIF90aGlzLnF1ZXJ5U2VsZWN0b3IoJyNsb2FkLWVycm9yLW1lc3NhZ2UnKS5zdHlsZS5kaXNwbGF5ID1cbiAgICAgICAgICAgICAgICAnbm9uZSc7XG4gICAgICAgICAgICBfdGhpcy5zdGFydEJ1dHRvbi50ZXh0Q29udGVudCA9XG4gICAgICAgICAgICAgICAgJ1N0YXJ0aW5nIHN0eWxlIHRyYW5zZmVyLi4gRG93bmxvYWRpbmcgKyBydW5uaW5nIG1vZGVsJztcbiAgICAgICAgICAgIF90aGlzLnN0YXJ0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLnRyYW5zZm9ybU5ldC5zZXRTdHlsZShTVFlMRV9NQVBQSU5HU1tfdGhpcy5zZWxlY3RlZFN0eWxlTmFtZV0pO1xuICAgICAgICAgICAgX3RoaXMudHJhbnNmb3JtTmV0LmxvYWQoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydEJ1dHRvbi50ZXh0Q29udGVudCA9ICdQcm9jZXNzaW5nIGltYWdlJztcbiAgICAgICAgICAgICAgICBfdGhpcy5ydW5JbmZlcmVuY2UoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydEJ1dHRvbi50ZXh0Q29udGVudCA9ICdTdGFydCBTdHlsZSBUcmFuc2Zlcic7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0QnV0dG9uLnRleHRDb250ZW50ID0gJ1N0YXJ0IFN0eWxlIFRyYW5zZmVyJztcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBlcnJNZXNzYWdlID0gX3RoaXMucXVlcnlTZWxlY3RvcignI2xvYWQtZXJyb3ItbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIGVyck1lc3NhZ2UudGV4dENvbnRlbnQgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICBlcnJNZXNzYWdlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gcHJpdmF0ZSBpbml0V2ViY2FtVmFyaWFibGVzKCkge1xuICAgIC8vICAgdGhpcy5jYW1EaWFsb2cgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJyN3ZWJjYW0tZGlhbG9nJyk7XG4gICAgLy8gICB0aGlzLndlYmNhbVZpZGVvRWxlbWVudCA9XG4gICAgLy8gICAgICAgdGhpcy5xdWVyeVNlbGVjdG9yKCcjd2ViY2FtVmlkZW8nKSBhcyBIVE1MVmlkZW9FbGVtZW50O1xuICAgIC8vICAgdGhpcy50YWtlUGljQnV0dG9uID1cbiAgICAvLyAgICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJyN0YWtlUGljQnV0dG9uJykgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgLy8gICB0aGlzLmNsb3NlTW9kYWwgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJyNjbG9zZU1vZGFsJykgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgLy9cbiAgICAvLyAgIC8vIENoZWNrIGlmIHdlYmNhbSBpcyBldmVuIGF2YWlsYWJsZVxuICAgIC8vICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIC8vICAgY29uc3QgbmF2aWdhdG9yQW55ID0gbmF2aWdhdG9yIGFzIGFueTtcbiAgICAvLyAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHx8XG4gICAgLy8gICAgICAgbmF2aWdhdG9yQW55LndlYmtpdEdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3JBbnkubW96R2V0VXNlck1lZGlhIHx8XG4gICAgLy8gICAgICAgbmF2aWdhdG9yQW55Lm1zR2V0VXNlck1lZGlhO1xuICAgIC8vICAgaWYgKG5hdmlnYXRvci5nZXRVc2VyTWVkaWEpIHtcbiAgICAvLyAgICAgY29uc3QgY29udGVudE5hbWVzID0gQ09OVEVOVF9OQU1FUy5zbGljZSgpO1xuICAgIC8vICAgICBjb250ZW50TmFtZXMudW5zaGlmdCgnVXNlIHdlYmNhbScpO1xuICAgIC8vICAgICB0aGlzLmNvbnRlbnROYW1lcyA9IGNvbnRlbnROYW1lcztcbiAgICAvLyAgIH1cbiAgICAvL1xuICAgIC8vICAgdGhpcy5jbG9zZU1vZGFsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIC8vICAgICB0aGlzLnN0cmVhbS5nZXRUcmFja3MoKVswXS5zdG9wKCk7XG4gICAgLy8gICB9KTtcbiAgICAvL1xuICAgIC8vICAgdGhpcy50YWtlUGljQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIC8vICAgICBjb25zdCBoaWRkZW5DYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID1cbiAgICAvLyAgICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoJyNoaWRkZW5DYW52YXMnKSBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICAvLyAgICAgY29uc3QgaGlkZGVuQ29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID1cbiAgICAvLyAgICAgICBoaWRkZW5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAvLyAgICAgaGlkZGVuQ2FudmFzLndpZHRoID0gdGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQud2lkdGg7XG4gICAgLy8gICAgIGhpZGRlbkNhbnZhcy5oZWlnaHQgPSB0aGlzLndlYmNhbVZpZGVvRWxlbWVudC5oZWlnaHQ7XG4gICAgLy8gICAgIGhpZGRlbkNvbnRleHQuZHJhd0ltYWdlKHRoaXMud2ViY2FtVmlkZW9FbGVtZW50LCAwLCAwLFxuICAgIC8vICAgICAgIGhpZGRlbkNhbnZhcy53aWR0aCwgaGlkZGVuQ2FudmFzLmhlaWdodCk7XG4gICAgLy8gICAgIGNvbnN0IGltYWdlRGF0YVVSTCA9IGhpZGRlbkNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZycpO1xuICAgIC8vICAgICB0aGlzLmNvbnRlbnRJbWdFbGVtZW50LnNyYyA9IGltYWdlRGF0YVVSTDtcbiAgICAvLyAgICAgdGhpcy5zdHJlYW0uZ2V0VHJhY2tzKClbMF0uc3RvcCgpO1xuICAgIC8vICAgfSk7XG4gICAgLy8gfVxuICAgIC8vIHByaXZhdGUgb3BlbldlYmNhbU1vZGFsKCkge1xuICAgIC8vICAgdGhpcy5jYW1EaWFsb2cub3BlbigpO1xuICAgIC8vICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYShcbiAgICAvLyAgICAge1xuICAgIC8vICAgICAgIHZpZGVvOiB0cnVlXG4gICAgLy8gICAgIH0sXG4gICAgLy8gICAgIChzdHJlYW0pID0+IHtcbiAgICAvLyAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAvLyAgICAgICB0aGlzLndlYmNhbVZpZGVvRWxlbWVudC5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgIC8vICAgICAgIHRoaXMud2ViY2FtVmlkZW9FbGVtZW50LnBsYXkoKTtcbiAgICAvLyAgICAgfSxcbiAgICAvLyAgICAgKGVycikgPT4ge1xuICAgIC8vICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgKTtcbiAgICAvLyB9XG4gICAgU3R5bGVUcmFuc2ZlckRlbW8ucHJvdG90eXBlLnJ1bkluZmVyZW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5tYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwLCB0cmFjaykgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmVwcm9jZXNzZWQsIGluZmVyZW5jZVJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVwcm9jZXNzZWQgPSB0cmFjayhkZWVwbGVhcm5fMS5BcnJheTNELmZyb21QaXhlbHModGhpcy5jb250ZW50SW1nRWxlbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudHJhbnNmb3JtTmV0LnByZWRpY3QocHJlcHJvY2Vzc2VkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mZXJlbmNlUmVzdWx0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2FudmFzU2hhcGUoaW5mZXJlbmNlUmVzdWx0LnNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclNoYWRlciA9IGRlZXBsZWFybl8xLnJlbmRlcl9uZGFycmF5X2dwdV91dGlsLmdldFJlbmRlclJHQlNoYWRlcih0aGlzLmdwZ3B1LCBpbmZlcmVuY2VSZXN1bHQuc2hhcGVbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBsZWFybl8xLnJlbmRlcl9uZGFycmF5X2dwdV91dGlsLnJlbmRlclRvQ2FudmFzKHRoaXMuZ3BncHUsIHRoaXMucmVuZGVyU2hhZGVyLCBpbmZlcmVuY2VSZXN1bHQuZ2V0VGV4dHVyZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvL0hldCByZXN1bHRhYXQgdmFuIGRlIGltYWdlIHdvcmR0IGdldG9vbmRcbiAgICBTdHlsZVRyYW5zZmVyRGVtby5wcm90b3R5cGUuc2V0Q2FudmFzU2hhcGUgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSBzaGFwZVsxXTtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gc2hhcGVbMF07XG4gICAgICAgIGlmIChzaGFwZVsxXSA+IHNoYXBlWzBdKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9ICc1MDBweCc7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSAoc2hhcGVbMF0gLyBzaGFwZVsxXSAqIDUwMCkudG9TdHJpbmcoKSArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnNTAwcHgnO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSAoc2hhcGVbMV0gLyBzaGFwZVswXSAqIDUwMCkudG9TdHJpbmcoKSArICdweCc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdHlsZVRyYW5zZmVyRGVtbztcbn0oZXhwb3J0cy5TdHlsZVRyYW5zZmVyRGVtb1BvbHltZXIpKTtcbmV4cG9ydHMuU3R5bGVUcmFuc2ZlckRlbW8gPSBTdHlsZVRyYW5zZmVyRGVtbztcbmRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChTdHlsZVRyYW5zZmVyRGVtby5wcm90b3R5cGUuaXMsIFN0eWxlVHJhbnNmZXJEZW1vKTtcbiJdfQ==
